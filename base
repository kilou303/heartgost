<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Roguelite – Version PRO – Starglaglax</title>
  <style>
    body {
      margin: 0;
      background: #050811;
      color: white;
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #container {
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
      border: 2px solid #333;
    }
    canvas {
      display: block;
      background: #111122;
    }
  </style>
</head>
<body>
<div id="container">
  <canvas id="game" width="900" height="700"></canvas>
</div>

<script>
// ===================== CONFIG GÉNÉRALE =====================

const WINDOW_WIDTH = 900;
const WINDOW_HEIGHT = 700;

const WORLD_WIDTH = 4000;
const WORLD_HEIGHT = 4000;

const TILE_SIZE = 48;

const MONSTER_LIMIT = 40;
const WORLD_SPAWN_INTERVAL = 4.0;
const POTION_DROP_CHANCE = 0.25;

const ELITE_SPAWN_CHANCE = 0.09;
const CHAMPION_SPAWN_CHANCE = 0.04;

const SPECIAL_DEMON_CHANCE_PORTAL = 0.08;

const TOWN_COUNT = 6;
const FOREST_COUNT = 8;
const ZONE_COUNT = 4;

const TOWN_SHOP_COST = 10;

const KNOCKBACK_HERO = 14.0;
const KNOCKBACK_MONSTER = 14.0;
const KNOCKBACK_SELF = 6.0;

const XP_RADIUS = 70;

const POTION_HEAL_RATIO = 0.35;
const MIN_TOWN_MONSTER_DISTANCE = 220.0;

const ROAD_SAFE_RADIUS = 80.0;
const RIVER_SAFE_RADIUS = 40.0;
const RIVER_COUNT = 2;

const QUEST_REWARD_MIN = 100;
const QUEST_REWARD_MAX = 500;

// ===================== TILESET =====================

const TILE = {
  VOID: 0,
  GRASS: 1,
  FOREST: 2,
  MARSH: 3,
  MOUNTAIN: 4,
  PLAINS: 5,
  ROAD: 6,
  WATER: 7,
  TOWN: 8,
  ZONE: 9
};

const TILE_MOVE_MULT = {
  [TILE.GRASS]: 1.0,
  [TILE.FOREST]: 0.9,
  [TILE.MARSH]: 0.5,
  [TILE.MOUNTAIN]: 0.8,
  [TILE.PLAINS]: 1.05,
  [TILE.ROAD]: 1.15,
  [TILE.WATER]: 0.7,
  [TILE.TOWN]: 1.0,
  [TILE.ZONE]: 1.0,
  [TILE.VOID]: 1.0
};

// ===================== NOMS, TITRES, SORTS =====================

const HERO_NAMES = [
  "Raelan","Kiro","Mira","Lunor","Kael","Nira","Taro","Elyon",
  "Railey","Killian","Oscar","Alara","Hindra","Gloria","Jessica",
  "Nakura","Zander","Djegui","Targan","Azar","Lyra","Soren","Maelis",
  "Ilyas","Kassandra","Vorun","Selene","Orion","Thalia","Jaro",
  "Elwyn","Kaera"
];

const HERO_TITLES = [
  "le Fragmenté","la Fragmentée",
  "le Marcheur des fragments","la Marcheuse des fragments",
  "le Briseur de démons","la Briseuse de démons",
  "le Fils de Kuro","la Fille de Kuro",
  "le Porte-Ongle","la Porte-Ongle",
  "l’Éclat vivant","la Foudre de Starglaglax",
  "le Gardien de Surville","la Gardienne de Kuro"
];

const SPECIAL_DEMON_NAMES = [
  "Azar l’Évolué",
  "Gardien du Nexus",
  "Démon Ancien de Starglaglax",
  "Briseur de Portail",
  "Seigneur des Fragments",
  "Ombre de Hertegost",
  "Hurleur Écarlate",
  "Dévoreur de Kuro"
];

// ======== LISTE DE SORTS (≈ 40) ========

const SPELL_DEFS = [
  // --- Projectiles simples / puissants ---
  { name:"Éclat d’Ongle",           type:"projectile", cost:5,  power:4, range:280, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:1.4 },
  { name:"Cendres de Triota",       type:"projectile", cost:6,  power:5, range:260, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:1.6 },
  { name:"Courroux de Surville",    type:"projectile", cost:7,  power:6, range:260, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:2.0 },
  { name:"Flamme Démoniaque",       type:"projectile", cost:6,  power:4, range:260, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:1.5 },
  { name:"Choc du Fragment Vivant", type:"projectile", cost:8,  power:7, range:260, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:2.3 },
  { name:"Lame d’Azar",             type:"projectile", cost:9,  power:8, range:270, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:2.6 },
  { name:"Griffes Spectrales",      type:"projectile", cost:5,  power:4, range:240, radius:0,   slow_factor:0.15, heal_ratio:0, cooldown:1.4 },
  { name:"Trait de Hertegost",      type:"projectile", cost:6,  power:5, range:290, radius:0,   slow_factor:0.1,  heal_ratio:0, cooldown:1.8 },

  // --- Projectiles complexes (chaîne, vol de vie, mini-AOE) ---
  { name:"Chaîne de Foudre d’Alara", type:"projectile", cost:9,  power:6, range:260, radius:0, slow_factor:0, heal_ratio:0,
    cooldown:2.7, chainRadius:90, chainFactor:0.5 },
  { name:"Piqûre de Bombes Vivantes", type:"projectile", cost:7, power:5, range:250, radius:70, slow_factor:0, heal_ratio:0,
    cooldown:2.0, spawnAoeRadius:70, aoeBonus:2 },
  { name:"Lancer de Fragment Maudit", type:"projectile", cost:8, power:6, range:240, radius:0, slow_factor:0,
    heal_ratio:0.3, cooldown:2.4, lifeSteal:0.4 },
  { name:"Rayon Perçant du Roi",      type:"projectile", cost:10, power:7, range:320, radius:0, slow_factor:0,
    heal_ratio:0, cooldown:2.5, pierceRadius:80 },

  // --- AOE offensifs ---
  { name:"Bras de Starglaglax",     type:"aoe",        cost:8,  power:4, range:0,   radius:210, slow_factor:0,    heal_ratio:0, cooldown:3.0 },
  { name:"Orage d’Hertegost",       type:"aoe",        cost:9,  power:3, range:0,   radius:260, slow_factor:0,    heal_ratio:0, cooldown:3.5 },
  { name:"Pluie de Fragments",      type:"aoe",        cost:10, power:5, range:0,   radius:230, slow_factor:0,    heal_ratio:0, cooldown:4.0 },
  { name:"Anneau de Vachecapone",   type:"aoe",        cost:9,  power:4, range:0,   radius:220, slow_factor:0.15, heal_ratio:0, cooldown:3.3 },
  { name:"Tempête de Frênesang",    type:"aoe",        cost:9,  power:4, range:0,   radius:230, slow_factor:0.2,  heal_ratio:0, cooldown:3.7 },
  { name:"Rune de Bombes Vivantes", type:"aoe",        cost:10, power:5, range:0,   radius:240, slow_factor:0,    heal_ratio:0, cooldown:4.2 },
  { name:"Crève-Cœur des Démons",   type:"aoe",        cost:11, power:6, range:0,   radius:230, slow_factor:0,    heal_ratio:0, cooldown:4.5 },

  // --- AOE + contrôle ---
  { name:"Cri d’Azar",              type:"slow",       cost:7,  power:0, range:0,   radius:260, slow_factor:0.45, heal_ratio:0, cooldown:3.8 },
  { name:"Brume Maudite",           type:"slow",       cost:6,  power:0, range:0,   radius:240, slow_factor:0.5,  heal_ratio:0, cooldown:3.2 },
  { name:"Gel de Gla-Glace",        type:"slow",       cost:7,  power:0, range:0,   radius:260, slow_factor:0.35, heal_ratio:0, cooldown:3.4 },
  { name:"Entrave de Surville",     type:"slow",       cost:8,  power:0, range:0,   radius:250, slow_factor:0.6,  heal_ratio:0, cooldown:4.0 },
  { name:"Carcan de Triota",        type:"slow",       cost:7,  power:0, range:0,   radius:220, slow_factor:0.4,  heal_ratio:0, cooldown:3.0 },

  // --- Soins / soutien ---
  { name:"Pacte de Kuro",           type:"heal",       cost:7,  power:0, range:0,   radius:0,   slow_factor:0,    heal_ratio:0.55, cooldown:4.5 },
  { name:"Aura de Hertegost",       type:"heal",       cost:9,  power:0, range:0,   radius:0,   slow_factor:0,    heal_ratio:0.75, cooldown:5.5 },
  { name:"Lien des Bêtes",          type:"heal",       cost:8,  power:0, range:0,   radius:0,   slow_factor:0,    heal_ratio:0.6,  cooldown:4.8 },
  { name:"Zèle de Gloria",          type:"heal",       cost:6,  power:0, range:0,   radius:0,   slow_factor:0,    heal_ratio:0.45, cooldown:3.8 },
  { name:"Bénédiction des Fragments", type:"heal",     cost:10, power:0, range:0,   radius:0,   slow_factor:0,    heal_ratio:0.9,  cooldown:6.0 },

  // --- Buff de renvoi (Vachecapone style) ---
  { name:"Magie de Renvoi de Vachecapone", type:"reflect", cost:10, power:0, range:0, radius:0,
    slow_factor:0, heal_ratio:0, cooldown:7.0, buffDuration:3.5 },
  { name:"Bouclier Miroir de Surville",    type:"reflect", cost:9,  power:0, range:0, radius:0,
    slow_factor:0, heal_ratio:0, cooldown:6.5, buffDuration:3.0 },
  { name:"Éclat Réversible",              type:"reflect", cost:8,  power:0, range:0, radius:0,
    slow_factor:0, heal_ratio:0, cooldown:6.0, buffDuration:2.7 },

  // --- Slash façon Railey ---
  { name:"Slash de Railey",         type:"slash",      cost:6,  power:6, range:120, radius:0,
    slow_factor:0, heal_ratio:0, cooldown:2.2, slashAngle:Math.PI/3 },
  { name:"Double Slash Fragmenté",  type:"slash",      cost:8,  power:7, range:130, radius:0,
    slow_factor:0, heal_ratio:0.2, cooldown:2.6, slashAngle:Math.PI/2, lifeSteal:0.3 },
  { name:"Tourbillon des Marais",   type:"slash",      cost:9,  power:5, range:140, radius:0,
    slow_factor:0.2, heal_ratio:0, cooldown:3.0, slashAngle:Math.PI*0.75 },
  { name:"Frappe du Méga-Poing",    type:"slash",      cost:10, power:9, range:110, radius:0,
    slow_factor:0.3, heal_ratio:0, cooldown:3.5, slashAngle:Math.PI/2 },

  // --- Slash + élément / contrôle ---
  { name:"Arc de Foudre d’Alara",   type:"slash",      cost:9,  power:7, range:135, radius:0,
    slow_factor:0.4, heal_ratio:0, cooldown:3.2, slashAngle:Math.PI/2 },
  { name:"Tranchant Givré de Hertegost", type:"slash", cost:8, power:6, range:130, radius:0,
    slow_factor:0.45, heal_ratio:0, cooldown:3.0, slashAngle:Math.PI/2 },

  // --- Bonus / utilitaires offensifs ---
  { name:"Volée d’Éclats",          type:"projectile", cost:9,  power:4, range:220, radius:0,
    slow_factor:0, heal_ratio:0, cooldown:2.4, multiProjectiles:3 },
  { name:"Impact du Monstre du Loch", type:"aoe",      cost:11, power:7, range:0,   radius:260,
    slow_factor:0.35, heal_ratio:0, cooldown:4.8 },
  { name:"Souffle du Dragon de Feu", type:"aoe",       cost:12, power:8, range:0,   radius:250,
    slow_factor:0.25, heal_ratio:0, cooldown:5.0 },
  { name:"Corde de Vent de Marc-Jeune", type:"projectile", cost:7, power:4, range:300, radius:0,
    slow_factor:0.3, heal_ratio:0, cooldown:2.0 }
];

const SPELL_COLORS = {};
for(const s of SPELL_DEFS){
  if(s.name.includes("Foudre")) SPELL_COLORS[s.name] = "#64b5f6";
  else if(s.name.includes("Gla-Glace") || s.name.includes("Givré")) SPELL_COLORS[s.name] = "#90caf9";
  else if(s.name.includes("Flamme") || s.name.includes("Feu") || s.name.includes("Cendres")) SPELL_COLORS[s.name] = "#ff8a50";
  else if(s.name.includes("Vachecapone")) SPELL_COLORS[s.name] = "#ffb74d";
  else if(s.name.includes("Starglaglax")) SPELL_COLORS[s.name] = "#d4a5ff";
  else if(s.name.includes("Azar")) SPELL_COLORS[s.name] = "#ffca28";
  else if(s.name.includes("Bombes")) SPELL_COLORS[s.name] = "#ffab91";
  else if(s.name.includes("Hertegost")) SPELL_COLORS[s.name] = "#b2dfdb";
  else if(s.name.includes("Kuro")) SPELL_COLORS[s.name] = "#a5d6a7";
  else if(s.name.includes("Surville")) SPELL_COLORS[s.name] = "#ff5252";
  else if(s.type==="heal") SPELL_COLORS[s.name] = "#c5e1a5";
  else if(s.type==="slow") SPELL_COLORS[s.name] = "#b39ddb";
  else if(s.type==="reflect") SPELL_COLORS[s.name] = "#fff59d";
  else if(s.type==="slash") SPELL_COLORS[s.name] = "#ffe082";
  else SPELL_COLORS[s.name] = "#ffffff";
}

const TOWN_NAMES = [
  "Surville","Kuro","Triota","Eloria","Valpon","Miria","Ormond","Rivendel",
  "Celestia","Silbor","Larion","Brumère","Hertegost","Nerwald","Brisegivre",
  "Fossombre","Rochenoire","Lunebrise","Aubemont","Port-Lumière","Noctefaille",
  "Clairval","Verdelame","Frênesang","Hautecime","Bas-Roc","Coindefer","Gris-Rempart"
];

// ===================== UTILITAIRES =====================

function clamp(v, min, max){ return v < min ? min : (v > max ? max : v); }
function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }
function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

// ===================== HÉROS JOUEUR =====================

class Hero {
  constructor(){
    this.baseName = randChoice(HERO_NAMES);
    this.title = randChoice(HERO_TITLES);
    this.name = this.baseName+" "+this.title;

    this.x = WORLD_WIDTH/2;
    this.y = WORLD_HEIGHT/2;

    this.level = 1;
    this.maxHp = 18;
    this.hp = this.maxHp;

    this.baseAttack = 3;
    this.baseDefense = 1;
    this.baseSpeedStat = 1.0;

    this.inventory = [null,null,null];
    this.backpack = [];
    this.potionsCount = 0;
    this.gold = 0;

    this.maxMp = 20;
    this.mp = this.maxMp;

    this.spell = randChoice(SPELL_DEFS);
    this.spellTimer = 0;

    this.xp = 0;
    this.xpToNext = 12;

    this.attackTimer = 0;

    this.dirX = 1;
    this.dirY = 0;

    this.target = null;

    this.hasVisitedTown = false;
    this.focusZone = null;

    this.reflectTimer = 0;

    this.patrolPoint = null;
    this.patrolTimer = 0;

    this.zoneIdleTicks = 0;

    this.retreatTimer = 0;
    this.retreatCooldown = 0;
  }

  get equipment(){ return this.inventory.filter(it=>it!==null); }
  get attack(){
    let bonus = this.equipment.reduce((s,it)=>s+(it.attackBonus||0),0);
    return this.baseAttack + bonus;
  }
  get defense(){
    let bonus = this.equipment.reduce((s,it)=>s+Math.min(3,it.defenseBonus||0),0);
    return this.baseDefense + bonus;
  }
  get moveSpeed(){
    let bonus = this.equipment.reduce((s,it)=>s+Math.min(10,it.speedBonus||0),0);
    return 120*this.baseSpeedStat + bonus;
  }
  get attackDelay(){
    const base = 0.8;
    const refSpeed = 120;
    const s = this.moveSpeed;
    return clamp(base * (refSpeed / s), 0.3, 1.1);
  }

  isAlive(){ return this.hp>0; }

  gainXp(amount){
    this.xp += amount;
    while(this.xp >= this.xpToNext){
      this.xp -= this.xpToNext;
      this.levelUp();
    }
  }

  levelUp(){
    this.level++;
    this.maxHp += 5;
    this.baseAttack += 1;
    if(this.level % 3 === 0) this.baseDefense += 1;
    this.hp = Math.min(this.maxHp, this.hp + Math.floor(this.maxHp*0.4));
    this.xpToNext = Math.floor(this.xpToNext*1.45);
  }

  addToBackpack(item){ this.backpack.push(item); }

  addEquipment(item){
    for(let i=0;i<3;i++){
      if(this.inventory[i] === null){
        this.inventory[i] = item;
        return;
      }
    }
    const score = it => (it.attackBonus||0)+(it.defenseBonus||0)+(it.speedBonus||0);
    let newScore = score(item);
    let worstIdx = null;
    let worstScore = Infinity;
    for(let i=0;i<3;i++){
      let sc = score(this.inventory[i]);
      if(sc < worstScore){
        worstScore = sc;
        worstIdx = i;
      }
    }
    if(worstIdx !== null && newScore > worstScore){
      this.backpack.push(this.inventory[worstIdx]);
      this.inventory[worstIdx] = item;
    } else {
      this.backpack.push(item);
    }
  }

  tryAutoUsePotion(){
    if(this.potionsCount<=0) return;
    if(this.hp >= this.maxHp*0.5) return;
    this.potionsCount--;
    const heal = Math.floor(this.maxHp*POTION_HEAL_RATIO);
    const mana = Math.floor(this.maxMp*POTION_HEAL_RATIO);
    this.hp = clamp(this.hp+heal,0,this.maxHp);
    this.mp = clamp(this.mp+mana,0,this.maxMp);
  }

  tryCastSpell(game){
    if(!this.spell || this.spellTimer>0) return;
    const cost = this.spell.cost || 5;
    if(this.mp < cost) return;

    const stype = this.spell.type;
    const color = SPELL_COLORS[this.spell.name] || "#ffffff";

    if((stype==="projectile" || stype==="aoe" || stype==="slow" || stype==="slash") && game.monsters.length===0){
      return;
    }

    // -------- PROJECTILE --------
    if(stype==="projectile"){
      let target = null;
      let bestD = Infinity;
      for(const m of game.monsters){
        const d = dist(this.x,this.y,m.x,m.y);
        if(d < bestD){
          bestD = d;
          target = m;
        }
      }
      if(!target) return;
      const dTo = bestD;
      const range = this.spell.range || 260;
      if(dTo>range) return;

      const m = target;
      const baseDmg = (this.spell.power || 3) + Math.floor(this.level/4);
      let dmg = baseDmg;

      m.hp -= dmg;

      if(this.spell.lifeSteal){
        const heal = Math.floor(dmg * this.spell.lifeSteal);
        this.hp = clamp(this.hp + heal, 0, this.maxHp);
      }

      const dx = m.x - this.x;
      const dy = m.y - this.y;
      const d = Math.hypot(dx,dy) || 1;
      const dirx = dx/d, diry = dy/d;
      m.x += dirx*KNOCKBACK_MONSTER;
      m.y += diry*KNOCKBACK_MONSTER;

      if(this.spell.chainRadius && this.spell.chainFactor){
        const cr = this.spell.chainRadius;
        const cf = this.spell.chainFactor;
        let hits = 0;
        for(const other of game.monsters){
          if(other===m) continue;
          if(dist(m.x,m.y,other.x,other.y) <= cr){
            const cdmg = Math.floor(dmg * cf);
            other.hp -= cdmg;
            hits++;
            if(hits>=3) break;
          }
        }
      }

      if(this.spell.spawnAoeRadius){
        const r = this.spell.spawnAoeRadius;
        const bonus = this.spell.aoeBonus || 1;
        for(const other of game.monsters){
          if(other===m) continue;
          if(dist(m.x,m.y,other.x,other.y) <= r){
            other.hp -= Math.max(1,Math.floor((baseDmg/2)+bonus));
          }
        }
        game.spawnEffect("aoe",{center:{x:m.x,y:m.y},radius:r,color});
      }

      if(this.spell.multiProjectiles){
        for(const other of game.monsters){
          if(other===m) continue;
          if(dist(this.x,this.y,other.x,other.y) <= this.spell.range*0.6){
            other.hp -= Math.max(1,Math.floor(baseDmg*0.6));
          }
        }
      }

      game.spawnEffect("projectile",{start:{x:this.x,y:this.y},end:{x:m.x,y:m.y},color});
      this.mp -= cost;
      this.spellTimer = this.spell.cooldown || 1.5;
      return;
    }

    // -------- AOE --------
    if(stype==="aoe"){
      const radius = this.spell.radius || 150;
      const dmg = (this.spell.power || 2) + Math.floor(this.level/5);
      let any=false;
      for(const m of game.monsters){
        if(dist(this.x,this.y,m.x,m.y) <= radius){
          m.hp -= dmg;
          any=true;
        }
      }
      if(!any) return;
      game.spawnEffect("aoe",{center:{x:this.x,y:this.y},radius,color});
      this.mp -= cost;
      this.spellTimer = this.spell.cooldown || 2.5;
      return;
    }

    // -------- HEAL --------
    if(stype==="heal"){
      if(this.hp >= this.maxHp*0.8) return;
      const ratio = this.spell.heal_ratio || 0.4;
      const amount = Math.max(1,Math.floor(this.maxHp*ratio));
      this.hp = clamp(this.hp+amount,0,this.maxHp);
      game.spawnEffect("heal",{center:{x:this.x,y:this.y},color});
      this.mp -= cost;
      this.spellTimer = this.spell.cooldown || 4.0;
      return;
    }

    // -------- SLOW --------
    if(stype==="slow"){
      const radius = this.spell.radius || 200;
      const factor = this.spell.slow_factor || 0.5;
      let affected=false;
      for(const m of game.monsters){
        if(dist(this.x,this.y,m.x,m.y) <= radius){
          m.speed *= factor;
          m.slowed = true;
          affected=true;
        }
      }
      if(!affected) return;
      game.spawnEffect("slow",{center:{x:this.x,y:this.y},radius,color});
      this.mp -= cost;
      this.spellTimer = this.spell.cooldown || 3.0;
      return;
    }

    // -------- REFLECT --------
    if(stype==="reflect"){
      const dur = this.spell.buffDuration || 3.0;
      if(this.reflectTimer > 0.4) return;
      this.reflectTimer = dur;
      game.spawnEffect("reflect",{center:{x:this.x,y:this.y},color});
      this.mp -= cost;
      this.spellTimer = this.spell.cooldown || 6.0;
      return;
    }

    // -------- SLASH --------
    if(stype==="slash"){
      const range = this.spell.range || 120;
      const angle = this.spell.slashAngle || (Math.PI/2);
      const baseDmg = (this.spell.power || 5) + Math.floor(this.level/4);
      const cosMax = Math.cos(angle/2);
      let hitList = [];
      for(const m of game.monsters){
        const dx = m.x - this.x;
        const dy = m.y - this.y;
        const d = Math.hypot(dx,dy);
        if(d > range) continue;
        const ndx = dx/d, ndy = dy/d;
        const dot = ndx*this.dirX + ndy*this.dirY;
        if(dot >= cosMax){
          hitList.push({m, d, ndx, ndy});
        }
      }
      if(hitList.length===0) return;

      for(const h of hitList){
        let dmg = baseDmg;
        h.m.hp -= dmg;
        h.m.x += h.ndx*KNOCKBACK_MONSTER*1.2;
        h.m.y += h.ndy*KNOCKBACK_MONSTER*1.2;
        if(this.spell.slow_factor){
          h.m.speed *= (1-this.spell.slow_factor*0.5);
          h.m.slowed = true;
        }
        if(this.spell.lifeSteal){
          const heal = Math.floor(dmg*this.spell.lifeSteal);
          this.hp = clamp(this.hp+heal,0,this.maxHp);
        }
      }

      game.spawnEffect("slash",{center:{x:this.x,y:this.y},dir:{x:this.dirX,y:this.dirY},range,angle,color});
      this.mp -= cost;
      this.spellTimer = this.spell.cooldown || 2.5;
      return;
    }
  }

  update(dt,game){
    if(!this.isAlive()) return;
    this.tryAutoUsePotion();

    // MANA PLUS LENT
    this.mp = clamp(this.mp + dt*0.3, 0, this.maxMp);

    this.attackTimer = Math.max(0,this.attackTimer-dt);
    this.spellTimer = Math.max(0,this.spellTimer-dt);
    this.reflectTimer = Math.max(0,this.reflectTimer-dt);
    this.patrolTimer = Math.max(0,this.patrolTimer-dt);
    this.retreatTimer = Math.max(0,this.retreatTimer-dt);
    this.retreatCooldown = Math.max(0,this.retreatCooldown-dt);

    this.tryCastSpell(game);
    this.chooseTarget(game);
    this.moveTowardsTarget(dt,game);
  }

  // IA SIMPLIFIÉE ET PLUS INTELLIGENTE
  chooseTarget(game){
    const hero=this;

    let zoneMonsters = [];

    // Nettoyage : si cible invalide ou atteinte, on oublie
    if(this.target && this.target.obj){
      const obj=this.target.obj;
      if(this.target.type==="monster"){
        if(!game.monsters.includes(obj)) this.target=null;
      } else if(["gold","potion"].includes(this.target.type)){
        const collectionRadius = 22;
        const pool = this.target.type==="gold" ? game.goldItems : game.potions;
        const stillExists = pool.includes(obj);
        if(!stillExists || dist(hero.x,hero.y,obj.x,obj.y) < collectionRadius){
          this.target=null;
        }
      } else if(["town","forest","zone"].includes(this.target.type)){
        if(dist(hero.x,hero.y,obj.x,obj.y) < 45){
          if(this.target.type==="town") this.hasVisitedTown = true;
          if(this.target.type==="zone") this.focusZone = obj;
          this.target=null;
        }
      }
    }

    if(this.retreatTimer>0 && this.target && this.target.type==="town"){
      return;
    }

    // Maintenir le focus sur une zone adaptée au niveau
    if(this.focusZone){
      const levelDelta = Math.abs((this.focusZone.level||1) - hero.level);
      if(this.focusZone.completed || levelDelta>3){
        this.focusZone=null;
        this.zoneIdleTicks = 0;
      }
    }

    // 1) Priorité : démon proche
    let nearestMonster=null, nearestDist=Infinity;
    const levelGapLimit = 3;
    for(const m of game.monsters){
      const d = dist(hero.x,hero.y,m.x,m.y);
      const lvlGap = Math.abs((m.level||1)-hero.level);
      if(d < nearestDist && lvlGap<=levelGapLimit){
        nearestDist = d;
        nearestMonster = m;
      }

      if(this.focusZone){
        const dz = dist(m.x,m.y,this.focusZone.x,this.focusZone.y);
        if(dz < 420 && lvlGap<=levelGapLimit){
          zoneMonsters.push({m,d,dz});
        }
      }
    }
    if(this.focusZone){
      if(zoneMonsters.length>0){
        this.zoneIdleTicks = 0;
      } else {
        this.zoneIdleTicks = Math.min(this.zoneIdleTicks+1, 360);
        if(this.zoneIdleTicks>240){
          this.focusZone = null;
          this.patrolPoint = null;
        }
      }
    } else {
      this.zoneIdleTicks = 0;
    }
    if(nearestMonster && nearestDist < 200){
      this.target = {type:"monster",obj:nearestMonster};
      return;
    }

    // 2) Récupération de loot tant que rien ne menace à portée immédiate
    const nearestLoot = ()=>{
      const candidates = [];
      for(const g of game.goldItems){
        candidates.push({type:"gold",obj:g});
      }
      for(const p of game.potions){
        candidates.push({type:"potion",obj:p});
      }
      let best=null;
      for(const entry of candidates){
        const d=dist(hero.x,hero.y,entry.obj.x,entry.obj.y);
        if(!best || d<best.d){ best={entry,d}; }
      }
      return best;
    };

    if(nearestMonster && nearestDist < 420){
      // priorité au combat si un démon rôde
    } else {
      const loot = nearestLoot();
      if(loot){
        const {entry,d} = loot;
        const preferLoot = d < 360 || hero.hp >= hero.maxHp*0.5;
        if(preferLoot){
          this.target={type:entry.type,obj:entry.obj};
          return;
        }
      }
    }

    // 3) Fuite probabiliste vers une ville proche quand la vie est basse
    const lowHp = hero.hp < hero.maxHp*0.3;
    if(lowHp){
      const townsInRange = game.pois.filter(p=>p.type==="town" && dist(hero.x,hero.y,p.x,p.y) < WORLD_WIDTH*0.1);
      if(townsInRange.length>0){
        const nearestTown = townsInRange.reduce((best,t)=>{
          const d=dist(hero.x,hero.y,t.x,t.y);
          return (!best || d<best.d) ? {t,d} : best;
        },null).t;
        if(this.retreatTimer>0 || (this.retreatCooldown<=0 && Math.random()<0.3)){
          this.retreatTimer = 6;
          this.retreatCooldown = 12;
          this.focusZone=null;
          this.patrolPoint=null;
          this.target={type:"town",obj:nearestTown};
          return;
        }
      }
    }

    // 4) Première étape de route : visiter une ville sûre
    if(!this.hasVisitedTown){
      const towns = game.pois.filter(p=>p.type==="town");
      let bestTown=null, bestD=Infinity;
      for(const t of towns){
        const d=dist(hero.x,hero.y,t.x,t.y);
        if(d<bestD){bestD=d;bestTown=t;}
      }
      if(bestTown){
        this.target={type:"town",obj:bestTown};
        return;
      }
    }

    // 5) Caler un focus sur une zone de niveau équivalent (jusqu'à +3 niveaux)
    const withinRange = (poi)=>{
      const lvl=poi.level||1;
      return lvl>=hero.level && lvl<=hero.level+3;
    };
    const zoneCandidates = game.pois.filter(p=>
      p.type==="zone" && !p.completed && withinRange(p)
    );
    const secondaryZones = game.pois.filter(p=>
      p.type==="zone" && !p.completed && Math.abs((p.level||1)-hero.level)<=levelGapLimit
    );

    const pickNearest = (arr)=>{
      if(arr.length===0) return null;
      let best=null;
      for(const p of arr){
        const d=dist(hero.x,hero.y,p.x,p.y);
        if(!best || d<best.d) best={p,d};
      }
      return best ? best.p : null;
    };

    if(!this.focusZone){
      this.focusZone = pickNearest(zoneCandidates) || pickNearest(secondaryZones);
    }

    // 6) Chercher des démons adaptés au niveau, en priorisant la zone ciblée
    if(game.monsters.length>0){
      let best=null;
      if(this.focusZone){
        for(const entry of zoneMonsters){
          const {m,d,dz} = entry;
          if(d>500) continue;
          if(!best || dz<best.dz || (dz===best.dz && d<best.d)){
            best={m,d,dz};
          }
        }
        if(best){
          this.target={type:"monster",obj:best.m};
          return;
        }
        if(zoneMonsters.length>0){
          zoneMonsters.sort((a,b)=>a.d-b.d);
          this.target={type:"monster",obj:zoneMonsters[0].m};
          this.patrolPoint=null;
          return;
        }
      } else {
        for(const m of game.monsters){
          const lvlGap=Math.abs((m.level||1)-hero.level);
          if(lvlGap>levelGapLimit) continue;
          const d=dist(hero.x,hero.y,m.x,m.y);
          if(d>450) continue;
          if(!best || d<best.d){
            best={m,d};
          }
        }
        if(best){
          this.target={type:"monster",obj:best.m};
          return;
        }
      }
    }

    // 7) Vagabondage : se recentrer sur la zone ciblée, sinon un POI de niveau adapté, sinon une ville
    if(this.focusZone){
      const hasNearbyMonsters = zoneMonsters.length>0;

      if(hasNearbyMonsters){
        this.target={type:"zone", obj:this.focusZone};
      } else {
        const shouldRefresh = !this.patrolPoint || this.patrolTimer<=0 || dist(hero.x,hero.y,this.patrolPoint.x,this.patrolPoint.y)<20;
        if(shouldRefresh){
          const angle = Math.random()*Math.PI*2;
          const radius = 120+Math.random()*160;
          const px = clamp(this.focusZone.x + Math.cos(angle)*radius,0,WORLD_WIDTH);
          const py = clamp(this.focusZone.y + Math.sin(angle)*radius,0,WORLD_HEIGHT);
          this.patrolPoint = {x:px,y:py};
          this.patrolTimer = 4 + Math.random()*4;
        }
        this.target={type:"point", obj:this.patrolPoint};
      }
      return;
    }

    const forests = game.pois.filter(p => p.type==="forest");
    const poiRange = game.pois.filter(p => p.level && withinRange(p));
    const towns = game.pois.filter(p => p.type==="town");

    const destPoi = pickNearest(poiRange);
    if(destPoi){
      this.target={type:destPoi.type || "point", obj:destPoi};
      return;
    }

    const destForest = pickNearest(forests);
    if(destForest){
      this.target={type:"forest", obj:destForest};
      return;
    }

    const destTown = pickNearest(towns);
    if(destTown){
      this.target={type:"town", obj:destTown};
      return;
    }

    // 8) Fallback : si vraiment rien, aller vers le centre du monde
    this.target = {type:"point", obj:{x:WORLD_WIDTH/2,y:WORLD_HEIGHT/2}};
  }

  moveTowardsTarget(dt,game){
    if(!this.target) return;
    const obj = this.target.obj;
    const tx=obj.x, ty=obj.y;
    const dx=tx-this.x, dy=ty-this.y;
    const d=Math.hypot(dx,dy);
    if(d<1e-3){ this.dirX=0; this.dirY=0; return;}
    this.dirX=dx/d; this.dirY=dy/d;

    if(["town","forest","zone"].includes(this.target.type) && d<40) return;

    let step=this.moveSpeed*dt;
    const moveMult = game.getMoveMultiplierAt(this.x,this.y);
    step *= moveMult;
    if(step>d) step=d;
    this.x += this.dirX*step;
    this.y += this.dirY*step;
    this.x = clamp(this.x,0,WORLD_WIDTH);
    this.y = clamp(this.y,0,WORLD_HEIGHT);
  }
}

// ===================== HÉROS DES VILLES =====================

class VillageHero {
  constructor(town){
    this.town = town;
    this.baseName = randChoice(HERO_NAMES);
    this.title = randChoice(HERO_TITLES);
    this.name = this.baseName+" "+this.title;

    this.x = town.x + (Math.random()*40-20);
    this.y = town.y + (Math.random()*40-20);
    this.level = clamp((town.level||1)+randInt(-1,1),1,99);

    this.maxHp = 14 + this.level*2;
    this.hp = this.maxHp;
    this.attack = 2 + Math.floor(this.level/2);
    this.defense = 1 + Math.floor(this.level/3);
    this.speed = 95 + this.level*3;

    this.attackTimer = 0;
    this.attackDelay = clamp(0.9*(120/this.speed),0.3,1.2);

    const villageSpells = SPELL_DEFS.filter(s=>["projectile","aoe","heal","slow"].includes(s.type));
    this.spell = randChoice(villageSpells);
    this.spellTimer = 0;

    this.state = "patrol";
    this.target = null;
    this.patrolTarget = null;

    this.bodyColor = randChoice(["#4cc9f0","#a5d6a7","#ffb74d","#ce93d8"]);
    this.borderColor = "#1d3557";

    this.dead = false;
    this.respawnTimer = 0;

    this.xp = 0;
    this.xpToNext = 20 + this.level*4;
  }

  isAlive(){ return !this.dead; }

  gainXp(amount){
    this.xp += amount;
    while(this.xp >= this.xToNext){
      this.xp -= this.xpToNext;
      this.levelUp();
    }
  }

  levelUp(){
    this.level++;
    this.maxHp += 4;
    this.hp = this.maxHp;
    this.attack += 1;
    if(this.level % 3 === 0) this.defense += 1;
    this.speed += 4;
    this.attackDelay = clamp(0.9*(120/this.speed),0.3,1.0);
    this.xpToNext = Math.floor(this.xpToNext*1.45);
  }
}

// ===================== JEU PRINCIPAL =====================

class Game {
  constructor(canvas){
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");

    this.hero = new Hero();
    this.monsters = [];
    this.goldItems = [];
    this.potions = [];
    this.pois = [];

    this.roads=[];
    this.rivers=[];
    this.bridges=[];
    this.crossroads=[];

    this.inZone=false;
    this.currentZone=null;

    this.effects=[];
    this.currentTown=null;

    this.tileCols = Math.ceil(WORLD_WIDTH / TILE_SIZE);
    this.tileRows = Math.ceil(WORLD_HEIGHT / TILE_SIZE);
    this.tileMap = [];

    this.currentQuest = null;
    this.questProgress = 0;

    this.worldSpawnTimer = 0;

    this.lastTime = performance.now();
    this.lastDeathMsg = "";
    this.lastDeathMsgTimer = 0;

    this.villageHeroes = [];
    this.demonNests = [];

    this.createPois();
    this.buildTileMap();
    this.spawnVillageHeroes();

    for(let i=0;i<MONSTER_LIMIT-12;i++){
      this.spawnMonsterInWorld();
    }
  }

  // ---------- MONDE ----------

  createPois(){
    this.pois=[];
    this.roads=[];
    this.rivers=[];
    this.bridges=[];
    this.crossroads=[];
    this.demonNests=[];

    const towns=[];
    const minDist=500;
    let tries=0;
    while(towns.length<TOWN_COUNT && tries<500){
      tries++;
      const name=randChoice(TOWN_NAMES);
      const lvl=1+Math.floor(Math.random()*8);
      const x=400+Math.random()*(WORLD_WIDTH-800);
      const y=400+Math.random()*(WORLD_HEIGHT-800);
      let ok=true;
      for(const t of towns){
        if(dist(x,y,t.x,t.y)<minDist){ok=false;break;}
      }
      if(!ok) continue;
      const town={type:"town",name,level:lvl,x,y};
      towns.push(town);
      this.pois.push(town);
    }

    const addRoad = (t1,t2)=>{
      const a=[t1.x,t1.y], b=[t2.x,t2.y];
      for(const rd of this.roads){
        const same1 = rd.ax===a[0] && rd.ay===a[1] && rd.bx===b[0] && rd.by===b[1];
        const same2 = rd.ax===b[0] && rd.ay===b[1] && rd.bx===a[0] && rd.by===a[1];
        if(same1 || same2) return;
      }
      this.roads.push({ax:a[0],ay:a[1],bx:b[0],by:b[1]});
    };

    if(towns.length>=2){
      for(let i=0;i<towns.length;i++){
        let best=null,bestD=Infinity;
        for(let j=0;j<towns.length;j++){
          if(i===j) continue;
          const d=dist(towns[i].x,towns[j].x,towns[j].x,towns[j].y);
        }
      }
    }

    if(towns.length>=2){
      for(let i=0;i<towns.length;i++){
        let best=null,bestD=Infinity;
        for(let j=0;j<towns.length;j++){
          if(i===j) continue;
          const d=dist(towns[i].x,towns[i].y,towns[j].x,towns[j].y);
          if(d<bestD){bestD=d;best=towns[j];}
        }
        if(best) addRoad(towns[i],best);
      }
      const centerTown = towns.reduce((best,t)=>{
        const d=dist(t.x,t.y,WORLD_WIDTH/2,WORLD_HEIGHT/2);
        return (!best || d<best.d)?{t,d}:{t:best.t,d:best.d};
      },null).t;
      for(const t of towns){
        if(t===centerTown) continue;
        addRoad(centerTown,t);
      }
    }

    this.generateRivers();
    this.generateBridges();

    const forests=[];
    let attempts=0;
    while(forests.length<FOREST_COUNT && attempts<600){
      attempts++;
      const x=200+Math.random()*(WORLD_WIDTH-400);
      const y=200+Math.random()*(WORLD_HEIGHT-400);
      let tooCloseTown=false;
      for(const t of towns){
        if(dist(x,y,t.x,t.y)<250){tooCloseTown=true;break;}
      }
      if(tooCloseTown) continue;
      const forest={type:"forest",x,y};
      forests.push(forest);
      this.pois.push(forest);
    }

    let zonesCreated=0, triesZ=0;
    while(zonesCreated<ZONE_COUNT && triesZ<400){
      triesZ++;
      if(this.roads.length===0) break;
      const rd = this.roads[Math.floor(Math.random()*this.roads.length)];
      const t=Math.random();
      const rx = rd.ax + (rd.bx-rd.ax)*t;
      const ry = rd.ay + (rd.by-rd.ay)*t;
      const ang = Math.random()*Math.PI*2;
      const dOff = 90+Math.random()*110;
      const zx = rx + Math.cos(ang)*dOff;
      const zy = ry + Math.sin(ang)*dOff;
      let bad=false;
      for(const tw of towns){
        if(dist(zx,zy,tw.x,tw.y)<260){bad=true;break;}
      }
      if(bad) continue;
      for(const rv of this.rivers){
        if(this.distancePointSegment(zx,zy,rv.ax,rv.ay,rv.bx,rv.by)<90){bad=true;break;}
      }
      if(bad) continue;
      const lvl=1+Math.floor(Math.random()*8);
      const zone={type:"zone",level:lvl,x:zx,y:zy,completed:false};
      this.pois.push(zone);
      this.demonNests.push({x:zx,y:zy,level:lvl,portal:true});
      zonesCreated++;
    }

    for(const rd of this.roads){
      if(Math.random()<0.4){
        const t=0.3+Math.random()*0.4;
        const cx=rd.ax+(rd.bx-rd.ax)*t;
        const cy=rd.ay+(rd.by-rd.ay)*t;
        const cr={type:"crossroad",x:cx,y:cy};
        this.crossroads.push(cr);
        this.pois.push(cr);
      }
    }

    for(const f of this.pois){
      if(f.type==="forest"){
        this.demonNests.push({x:f.x,y:f.y,level:randInt(1,6),portal:false});
      }
    }

    if(towns.length>0){
      const centerTown = towns.reduce((best,t)=>{
        const d=dist(t.x,t.y,WORLD_WIDTH/2,WORLD_HEIGHT/2);
        return (!best || d<best.d)?{t,d}:{t:best.t,d:best.d};
      },null).t;
      this.hero.x = centerTown.x+40;
      this.hero.y = centerTown.y+40;
    }
  }

  generateRivers(){
    this.rivers=[];
    for(let k=0;k<RIVER_COUNT;k++){
      const orientation = Math.random()<0.5?"vertical":"horizontal";
      let points=[];
      if(orientation==="vertical"){
        const x=600+Math.random()*(WORLD_WIDTH-1200);
        const yStart=-200, yEnd=WORLD_HEIGHT+200;
        const segs=3+Math.floor(Math.random()*3);
        for(let i=0;i<=segs;i++){
          const t=i/segs;
          const yy=yStart+(yEnd-yStart)*t;
          const jitter=-150+Math.random()*300;
          const xx=clamp(x+jitter,100,WORLD_WIDTH-100);
          points.push({x:xx,y:yy});
        }
      } else {
        const y=600+Math.random()*(WORLD_HEIGHT-1200);
        const xStart=-200, xEnd=WORLD_WIDTH+200;
        const segs=3+Math.floor(Math.random()*3);
        for(let i=0;i<=segs;i++){
          const t=i/segs;
          const xx=xStart+(xEnd-xStart)*t;
          const jitter=-150+Math.random()*300;
          const yy=clamp(y+jitter,100,WORLD_HEIGHT-100);
          points.push({x:xx,y:yy});
        }
      }
      for(let i=0;i<points.length-1;i++){
        const a=points[i], b=points[i+1];
        this.rivers.push({ax:a.x,ay:a.y,bx:b.x,by:b.y});
      }
    }
  }

  segmentIntersection(ax,ay,bx,by,cx,cy,dx,dy){
    const cross=(vx,vy,wx,wy)=>vx*wy-vy*wx;
    const rx=bx-ax, ry=by-ay;
    const sx=dx-cx, sy=dy-cy;
    const denom = cross(rx,ry,sx,sy);
    if(Math.abs(denom)<1e-6) return null;
    const t = cross(cx-ax,cy-ay,sx,sy)/denom;
    const u = cross(cx-ax,cy-ay,rx,ry)/denom;
    if(t>=0 && t<=1 && u>=0 && u<=1){
      return {x:ax+t*rx,y:ay+t*ry};
    }
    return null;
  }

  generateBridges(){
    this.bridges=[];
    for(const rd of this.roads){
      for(const rv of this.rivers){
        const ip = this.segmentIntersection(rd.ax,rd.ay,rd.bx,rd.by,rv.ax,rv.ay,rv.bx,rv.by);
        if(!ip) continue;
        let tooClose=false;
        for(const br of this.bridges){
          if(dist(ip.x,ip.y,br.x,br.y)<40){tooClose=true;break;}
        }
        if(tooClose) continue;
        this.bridges.push({x:ip.x,y:ip.y});
      }
    }
  }

  distancePointSegment(px,py,ax,ay,bx,by){
    const abx=bx-ax, aby=by-ay;
    const ab2=abx*abx+aby*aby;
    if(ab2===0) return Math.hypot(px-ax,py-ay);
    let t=((px-ax)*abx+(py-ay)*aby)/ab2;
    t=clamp(t,0,1);
    const projx=ax+t*abx, projy=ay+t*aby;
    return Math.hypot(px-projx,py-projy);
  }

  isNearForest(x,y){
    for(const p of this.pois){
      if(p.type==="forest" && dist(x,y,p.x,p.y)<350) return true;
    }
    return false;
  }

  getBiome(x,y){
    for(const rv of this.rivers){
      if(this.distancePointSegment(x,y,rv.ax,rv.ay,rv.bx,rv.by)<80) return "marais";
    }
    for(const p of this.pois){
      if(p.type==="forest" && dist(x,y,p.x,p.y)<280) return "forêt";
    }
    if(y < WORLD_HEIGHT*0.25) return "montagnes";
    if(y > WORLD_HEIGHT*0.75) return "plaines";
    return "collines";
  }

  // ---------- TILEMAP ----------

  buildTileMap(){
    this.tileMap = [];
    for(let gy=0;gy<this.tileRows;gy++){
      const row=[];
      for(let gx=0;gx<this.tileCols;gx++){
        const wx=gx*TILE_SIZE + TILE_SIZE/2;
        const wy=gy*TILE_SIZE + TILE_SIZE/2;

        let tile = TILE.GRASS;
        const biome = this.getBiome(wx,wy);
        if(biome==="forêt") tile = TILE.FOREST;
        else if(biome==="marais") tile = TILE.MARSH;
        else if(biome==="montagnes") tile = TILE.MOUNTAIN;
        else if(biome==="plaines") tile = TILE.PLAINS;
        else tile = TILE.GRASS;

        for(const rv of this.rivers){
          const d=this.distancePointSegment(wx,wy,rv.ax,rv.ay,rv.bx,rv.by);
          if(d<26) tile = TILE.WATER;
          else if(d<70 && tile!==TILE.WATER) tile = TILE.MARSH;
        }

        for(const rd of this.roads){
          const d=this.distancePointSegment(wx,wy,rd.ax,rd.ay,rd.bx,rd.by);
          if(d<22) tile = TILE.ROAD;
        }

        for(const poi of this.pois){
          const d = dist(wx,wy,poi.x,poi.y);
          if(poi.type==="town" && d<40) tile = TILE.TOWN;
          if(poi.type==="zone" && d<34) tile = TILE.ZONE;
        }

        row.push(tile);
      }
      this.tileMap.push(row);
    }
  }

  getTileAt(x,y){
    const gx = Math.floor(x / TILE_SIZE);
    const gy = Math.floor(y / TILE_SIZE);
    if(gx<0 || gy<0 || gx>=this.tileCols || gy>=this.tileRows) return TILE.VOID;
    return this.tileMap[gy][gx];
  }

  getMoveMultiplierAt(x,y){
    const tile = this.getTileAt(x,y);
    return TILE_MOVE_MULT[tile] || 1.0;
  }

  // ---------- HÉROS DES VILLES ----------

  spawnVillageHeroes(){
    this.villageHeroes = [];
    for(const poi of this.pois){
      if(poi.type!=="town") continue;
      const count = 1 + (Math.random()<0.4 ? 1 : 0);
      for(let i=0;i<count;i++){
        this.villageHeroes.push(new VillageHero(poi));
      }
    }
  }

  // ---------- LOOP ----------

  step(){
    const now = performance.now();
    let dt = (now - this.lastTime)/1000;
    if(dt>0.1) dt=0.1;
    this.lastTime = now;
    this.update(dt);
    this.draw();
  }

  update(dt){
    const hero=this.hero;
    if(!hero.isAlive()){
      this.handleHeroDeath();
      return;
    }

    this.worldSpawnTimer += dt;
    if(this.worldSpawnTimer>=WORLD_SPAWN_INTERVAL){
      this.worldSpawnTimer=0;
      if(this.monsters.length < MONSTER_LIMIT){
        this.spawnMonsterInWorld();
      }
    }

    hero.update(dt,this);
    this.updateVillageHeroes(dt);
    this.updateMonsters(dt);
    this.checkLootCollisions();
    this.checkTownInteractions();
    this.checkZoneInteractions();
    if(this.inZone) this.updateZoneState();
    this.updateEffects(dt);

    if(this.lastDeathMsgTimer>0) this.lastDeathMsgTimer-=dt;
  }

  handleHeroDeath(){
    const deadName = this.hero.name;
    const deadLvl = this.hero.level;

    this.monsters=[];
    this.goldItems=[];
    this.potions=[];
    this.effects=[];
    this.inZone=false;
    this.currentZone=null;
    this.currentTown=null;
    this.currentQuest=null;
    this.questProgress=0;

    this.hero = new Hero();
    this.lastDeathMsg = `${deadName} est tombé (niv ${deadLvl})… Un nouveau héros apparaît !`;
    this.lastDeathMsgTimer = 4;
  }

  // ---------- SPAWN DES DÉMONS ----------

  spawnMonsterInWorld(){
    if(this.monsters.length>=MONSTER_LIMIT) return;
    if(this.demonNests.length===0) return;

    const nest = randChoice(this.demonNests);
    const isPortalNest = !!nest.portal;

    let attempts=0, spawnX=null, spawnY=null;
    const towns = this.pois.filter(p=>p.type==="town");

    while(attempts<15){
      attempts++;
      const ang=Math.random()*Math.PI*2;
      const d = 80+Math.random()*260;
      const mx = clamp(nest.x + Math.cos(ang)*d,0,WORLD_WIDTH);
      const my = clamp(nest.y + Math.sin(ang)*d,0,WORLD_HEIGHT);
      let tooCloseTown=false;
      for(const t of towns){
        if(dist(mx,my,t.x,t.y)<MIN_TOWN_MONSTER_DISTANCE){tooCloseTown=true;break;}
      }
      if(tooCloseTown) continue;
      const tile=this.getTileAt(mx,my);
      if(tile===TILE.WATER || tile===TILE.TOWN) continue;
      spawnX=mx; spawnY=my; break;
    }
    if(spawnX===null) return;

    const baseLevel = clamp(nest.level + randInt(-1,2),1,99);
    let lvl = baseLevel;
    const biome = this.getBiome(spawnX,spawnY);

    let hpBoost=0, atkBoost=0, speedMult=1;
    if(biome==="montagnes"){ hpBoost=3; atkBoost=1; speedMult=0.95; }
    else if(biome==="marais"){ hpBoost=2; atkBoost=0; speedMult=0.9; }
    else if(biome==="forêt"){ hpBoost=1; atkBoost=0; speedMult=1.05; }

    const roll=Math.random();
    let rarity="common";

    const m={
      x:spawnX,y:spawnY,
      biome,
      hp:0,maxHp:0,
      attack:0,defense:0,
      speed:0,
      attackTimer:0,
      level:lvl,
      elite:false,
      champion:false,
      slowed:false,
      spell:null,
      spellTimer:0,
      wanderTarget:null,
      name:"Démon mineur",
      special:false
    };

    if(roll<CHAMPION_SPAWN_CHANCE){
      const maxHp=14+lvl+6+hpBoost;
      m.maxHp=maxHp;m.hp=maxHp;
      m.attack=4+Math.floor(lvl/2)+atkBoost;
      m.defense=2+Math.floor(lvl/3);
      m.speed=(65+Math.random()*30)*speedMult;
      m.elite=true;m.champion=true;
      m.name=randChoice(["Démon majeur","Démon du Fragment","Démon exalté"]);
      rarity="champion";
    }else if(roll<CHAMPION_SPAWN_CHANCE+ELITE_SPAWN_CHANCE){
      const maxHp=10+lvl+Math.floor(Math.random()*4)+hpBoost;
      m.maxHp=maxHp;m.hp=maxHp;
      m.attack=3+Math.floor(lvl/2)+atkBoost;
      m.defense=1+Math.floor(lvl/3);
      m.speed=(70+Math.random()*30)*speedMult;
      m.elite=true;m.champion=false;
      m.name=randChoice(["Démon élite","Démon des ruines","Démon sanguinaire"]);
      rarity="elite";
    }else{
      const maxHp=6+lvl+Math.floor(Math.random()*3)+hpBoost;
      m.maxHp=maxHp;m.hp=maxHp;
      m.attack=2+Math.floor(lvl/2)+atkBoost;
      m.defense=0+Math.floor(lvl/4);
      m.speed=(60+Math.random()*40)*speedMult;
      m.elite=false;m.champion=false;
      m.name=randChoice(["Démon mineur","Démon rôdeur","Démon errant"]);
      rarity="common";
    }

    if(lvl>=10){
      const demonSpells = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
      m.spell = randChoice(demonSpells);
      m.spellTimer = 0;
    }

    if(isPortalNest && Math.random() < SPECIAL_DEMON_CHANCE_PORTAL){
      m.special = true;
      m.elite = true;
      m.champion = true;
      m.name = randChoice(SPECIAL_DEMON_NAMES);
      m.maxHp = Math.floor(m.maxHp * 2.4);
      m.hp = m.maxHp;
      m.attack += 3;
      m.defense += 2;
      m.speed *= 1.08;
      const offensiveSpells = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
      m.spell = randChoice(offensiveSpells);
      m.spellTimer = 0;
      rarity = "special";
    }

    m.rarity=rarity;
    this.monsters.push(m);
  }

  getMonsterRarity(m){
    if(m.special) return "special";
    if(m.champion) return "champion";
    if(m.elite) return "elite";
    return "common";
  }

  // ---------- IA HÉROS DE VILLAGE ----------

  updateVillageHeroes(dt){
    const hero = this.hero;

    for(const vh of this.villageHeroes){
      if(vh.dead){
        vh.respawnTimer -= dt;
        if(vh.respawnTimer<=0){
          vh.dead=false;
          vh.hp = vh.maxHp;
          vh.x = vh.town.x + (Math.random()*40-20);
          vh.y = vh.town.y + (Math.random()*40-20);
        }
        continue;
      }

      vh.attackTimer = Math.max(0,vh.attackTimer-dt);
      vh.spellTimer = Math.max(0,vh.spellTimer-dt);

      let best=null;
      for(const m of this.monsters){
        const d = dist(vh.x,vh.y,m.x,m.y);
        if(d>260) continue;
        if(!best || d<best.d) best={m,d};
      }
      if(best){
        const target = best.m;
        const dx=target.x-vh.x, dy=target.y-vh.y;
        const d = Math.hypot(dx,dy)||1;
        const dirx=dx/d, diry=dy/d;

        if(d>32){
          let step=vh.speed*dt;
          step *= this.getMoveMultiplierAt(vh.x,vh.y);
          if(step>d) step=d;
          vh.x+=dirx*step; vh.y+=diry*step;
        }

        if(vh.spell && vh.spellTimer<=0 && d<(vh.spell.range||220) && vh.spell.type==="projectile"){
          const color = SPELL_COLORS[vh.spell.name] || "#ffffff";
          const dmg = (vh.spell.power||3) + Math.floor(vh.level/4);
          target.hp -= dmg;
          target.x += dirx*KNOCKBACK_MONSTER;
          target.y += diry*KNOCKBACK_MONSTER;
          this.spawnEffect("projectile",{start:{x:vh.x,y:vh.y},end:{x:target.x,y:target.y},color});
          vh.spellTimer = vh.spell.cooldown || 2.0;
        }

        if(d<34 && vh.attackTimer<=0){
          const dmg = Math.max(1,vh.attack-(target.defense||0));
          target.hp -= dmg;
          vh.attackTimer = vh.attackDelay;
          target.x += dirx*KNOCKBACK_MONSTER;
          target.y += diry*KNOCKBACK_MONSTER;
          vh.x -= dirx*KNOCKBACK_SELF;
          vh.y -= diry*KNOCKBACK_SELF;
        }

      } else {
        if(!vh.patrolTarget || dist(vh.x,vh.y,vh.patrolTarget.x,vh.patrolTarget.y)<10){
          const ang=Math.random()*Math.PI*2;
          const rad=60+Math.random()*160;
          vh.patrolTarget={
            x: vh.town.x + Math.cos(ang)*rad,
            y: vh.town.y + Math.sin(ang)*rad
          };
        }
        const tx=vh.patrolTarget.x, ty=vh.patrolTarget.y;
        const dx=tx-vh.x, dy=ty-vh.y;
        const d=Math.hypot(dx,dy)||1;
        const dirx=dx/d, diry=dy/d;
        let step=vh.speed*dt*0.7;
        step *= this.getMoveMultiplierAt(vh.x,vh.y);
        if(step>d) step=d;
        vh.x+=dirx*step; vh.y+=diry*step;
      }

      if(vh.hp<=0){
        vh.dead=true;
        vh.respawnTimer=12;
      }
    }
  }

  // ---------- XP PARTAGÉE ----------

  distributeExperience(monster,xpGain){
    const hero = this.hero;
    const r = XP_RADIUS;

    if(hero.isAlive() && dist(hero.x,hero.y,monster.x,monster.y) <= r){
      hero.gainXp(xpGain);
    }

    for(const vh of this.villageHeroes){
      if(!vh.isAlive()) continue;
      if(dist(vh.x,vh.y,monster.x,monster.y) <= r){
        vh.gainXp(xpGain);
      }
    }
  }

  // ---------- MONSTRE QUI TUE UN HÉROS = LEVEL UP ----------

  onHeroKilledByMonster(victim,monster){
    monster.level = (monster.level || 1) + 1;
    monster.maxHp = Math.floor((monster.maxHp || 10) * 1.25);
    monster.hp = monster.maxHp;
    monster.attack = (monster.attack || 2) + 1;
    monster.defense = (monster.defense || 0) + 1;
    monster.speed = (monster.speed || 60) * 1.05;

    if(!monster.spell){
      const offensiveSpells = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
      monster.spell = randChoice(offensiveSpells);
      monster.spellTimer = 0;
    }
  }

  // ---------- IA DES DÉMONS ----------

  updateMonsters(dt){
    const hero=this.hero;
    const toRemove=[];
    for(const m of this.monsters){
      let bestTarget = {obj:hero,dist:dist(m.x,m.y,hero.x,hero.y),type:"hero"};
      for(const vh of this.villageHeroes){
        if(!vh.isAlive()) continue;
        const d=dist(m.x,m.y,vh.x,vh.y);
        if(d<bestTarget.dist){
          bestTarget={obj:vh,dist:d,type:"villageHero"};
        }
      }

      const target = bestTarget.obj;
      const d = bestTarget.dist;
      const dx=target.x-m.x, dy=target.y-m.y;
      const norm = Math.hypot(dx,dy)||1;
      const dirx=dx/norm, diry=dy/norm;

      const detectRange = 260;
      if(d < detectRange){
        if(d>26){
          let step=m.speed*dt;
          step *= this.getMoveMultiplierAt(m.x,m.y);
          if(step>d) step=d;
          m.x+=dirx*step; m.y+=diry*step;
        }
      } else {
        if(!m.wanderTarget || dist(m.x,m.y,m.wanderTarget.x,m.wanderTarget.y)<6 || Math.random()<0.01){
          const ang=Math.random()*Math.PI*2;
          const rad=80+Math.random()*150;
          m.wanderTarget={x: clamp(m.x+Math.cos(ang)*rad,0,WORLD_WIDTH),
                          y: clamp(m.y+Math.sin(ang)*rad,0,WORLD_HEIGHT)};
        }
        const tx=m.wanderTarget.x, ty=m.wanderTarget.y;
        const ddx=tx-m.x, ddy=ty-m.y;
        const dd=Math.hypot(ddx,ddy)||1;
        const dir2x=ddx/dd, dir2y=ddy/dd;
        let step=m.speed*dt*0.6;
        step *= this.getMoveMultiplierAt(m.x,m.y);
        if(step>dd) step=dd;
        m.x+=dir2x*step; m.y+=dir2y*step;
      }

      m.attackTimer = Math.max(0,m.attackTimer-dt);
      if(m.spell) m.spellTimer = Math.max(0,m.spellTimer-dt);

      // Sorts des démons (avec gestion du renvoi)
      if(m.spell && m.spellTimer<=0 && d<(m.spell.range||240) && d>40 &&
         (m.spell.type==="projectile" || m.spell.type==="aoe")){
        const color = SPELL_COLORS[m.spell.name] || "#ff8888";
        const dmg = (m.spell.power||3) + Math.floor(m.level/4);

        if(bestTarget.type==="hero" && hero.reflectTimer>0){
          m.hp -= dmg;
          m.x -= dirx*KNOCKBACK_MONSTER;
          m.y -= diry*KNOCKBACK_MONSTER;
          hero.x -= dirx*KNOCKBACK_SELF*0.4;
          hero.y -= diry*KNOCKBACK_SELF*0.4;
          this.spawnEffect("reflectHit",{start:{x:hero.x,y:hero.y},end:{x:m.x,y:m.y},color});
        } else {
          const beforeHp = target.hp;
          target.hp -= dmg;
          target.x += dirx*KNOCKBACK_HERO*0.7;
          target.y += diry*KNOCKBACK_HERO*0.7;
          m.x -= dirx*KNOCKBACK_SELF*0.6;
          m.y -= diry*KNOCKBACK_SELF*0.6;
          this.spawnEffect("projectile",{start:{x:m.x,y:m.y},end:{x:target.x,y:target.y},color});
          if(beforeHp>0 && target.hp<=0){
            this.onHeroKilledByMonster(target,m);
          }
        }

        m.spellTimer = m.spell.cooldown || 2.5;
      }

      if(d<34){
        if(bestTarget.type==="hero" && hero.isAlive() && hero.attackTimer<=0){
          const dmg=Math.max(1,hero.attack-(m.defense||0));
          m.hp -= dmg;
          hero.attackTimer = hero.attackDelay;
          m.x -= dirx*KNOCKBACK_MONSTER;
          m.y -= diry*KNOCKBACK_MONSTER;
          hero.x += dirx*KNOCKBACK_SELF;
          hero.y += diry*KNOCKBACK_SELF;
        }
        if(bestTarget.type==="villageHero" && target.isAlive && target.attackTimer<=0){
          const vh=target;
          const dmg = Math.max(1,vh.attack-(m.defense||0));
          m.hp -= dmg;
          vh.attackTimer = vh.attackDelay;
          m.x -= dirx*KNOCKBACK_MONSTER;
          m.y -= diry*KNOCKBACK_MONSTER;
          vh.x += dirx*KNOCKBACK_SELF;
          vh.y += diry*KNOCKBACK_SELF;
        }

        if(m.attackTimer<=0){
          const defTarget = (bestTarget.type==="hero")?hero:target;
          const dmgH=Math.max(1,m.attack - (defTarget.defense||0));
          const beforeHp = defTarget.hp;
          defTarget.hp -= dmgH;
          m.attackTimer = 0.9;
          defTarget.x += dirx*KNOCKBACK_HERO;
          defTarget.y += diry*KNOCKBACK_HERO;
          m.x -= dirx*(KNOCKBACK_MONSTER*0.4);
          m.y -= diry*(KNOCKBACK_MONSTER*0.4);

          if(beforeHp>0 && defTarget.hp<=0){
            this.onHeroKilledByMonster(defTarget,m);
          }
        }

        hero.x=clamp(hero.x,0,WORLD_WIDTH);
        hero.y=clamp(hero.y,0,WORLD_HEIGHT);
      }

      if(m.hp<=0){
        toRemove.push(m);
        const lvl=m.level||1;
        let baseXp=1+lvl;
        let baseGold=Math.max(1,Math.floor(lvl/2));
        let mult=1;
        const rarity=this.getMonsterRarity(m);
        if(rarity==="elite") mult+=0.4;
        if(rarity==="champion") mult+=0.8;
        if(rarity==="special") mult+=1.2;
        const xpGain=Math.max(1,Math.floor(baseXp*mult));
        const goldGain=Math.max(1,Math.floor((baseGold+1)*mult));

        this.distributeExperience(m,xpGain);

        this.goldItems.push({x:m.x,y:m.y,amount:goldGain});
        if(Math.random()<POTION_DROP_CHANCE){
          this.potions.push({x:m.x,y:m.y});
        }
        this.handleMonsterKillForQuest();
      }
    }
    this.monsters = this.monsters.filter(m=>!toRemove.includes(m));
  }

  // ---------- QUÊTES SIMPLIFIÉES ----------

  handleMonsterKillForQuest(){
    if(!this.currentQuest) return;
    this.questProgress++;
    if(this.questProgress >= this.currentQuest.targetCount){
      this.hero.gold += this.currentQuest.reward;
      this.currentQuest = null;
      this.questProgress = 0;
    }
  }

  maybeGiveQuest(town){
    if(this.currentQuest) return;
    const hero=this.hero;

    const base = randInt(4,7);
    const extra = Math.floor(hero.level/3);
    const targetCount = base + extra;

    const rewardBase = randInt(QUEST_REWARD_MIN,QUEST_REWARD_MAX);
    const reward = rewardBase + hero.level*10;

    this.currentQuest = {
      targetCount,
      reward
    };
    this.questProgress = 0;
  }

  tryCompleteQuest(town){
    // Récompense déjà donnée automatiquement
  }

  // ---------- LOOT & VILLES ----------

  checkLootCollisions(){
    const hero=this.hero;
    this.goldItems = this.goldItems.filter(g=>{
      if(dist(hero.x,hero.y,g.x,g.y)<25){ hero.gold += g.amount; return false; }
      return true;
    });
    this.potions = this.potions.filter(p=>{
      if(dist(hero.x,hero.y,p.x,p.y)<25){ hero.potionsCount++; return false; }
      return true;
    });
  }

  checkTownInteractions(){
    const hero=this.hero;
    if(this.currentTown && dist(hero.x,hero.y,this.currentTown.x,this.currentTown.y)>60){
      this.currentTown=null;
    }
    for(const p of this.pois){
      if(p.type!=="town") continue;
      if(dist(hero.x,hero.y,p.x,p.y)<50){
        if(!this.currentTown || this.currentTown!==p){
          this.currentTown=p;
          this.handleTownVisit(p);
        }
        break;
      }
    }
  }

  handleTownVisit(town){
    const hero=this.hero;

    if(hero.backpack.length>0){
      let sellGold=0;
      for(const it of hero.backpack){
        const val=(it.attackBonus||0)+(it.defenseBonus||0)+(it.speedBonus||0);
        sellGold += Math.max(1,val);
      }
      hero.gold += sellGold;
      hero.backpack=[];
    }

    if(hero.hp<hero.maxHp*0.5 && hero.gold>=TOWN_SHOP_COST){
      hero.gold -= TOWN_SHOP_COST;
      hero.hp = hero.maxHp;
    }

    if(Math.random()<0.08){
      hero.maxMp += 4;
      hero.mp = hero.maxMp;
    }

    this.tryCompleteQuest(town);
    if(!this.currentQuest){
      this.maybeGiveQuest(town);
    }
  }

  // ---------- PORTAILS (zones) ----------

  checkZoneInteractions(){
    if(this.inZone) return;
    const hero=this.hero;
    for(const poi of this.pois){
      if(poi.type!=="zone") continue;
      if(poi.completed) continue;
      if(hero.level < (poi.level||1)) continue;
      if(dist(hero.x,hero.y,poi.x,poi.y)<60){
        this.enterZone(poi);
        break;
      }
    }
  }

  enterZone(zone){
    if(this.inZone) return;
    this.inZone=true;
    const roomCount=3+Math.floor(Math.random()*3);
    this.currentZone={poi:zone,level:zone.level||1,roomIndex:0,roomCount,bossSpawned:false};
    this.monsters=[];
    this.goldItems=[];
    this.potions=[];
    this.hero.x=zone.x;
    this.hero.y=zone.y;
    this.spawnZoneRoom();
  }

  spawnZoneRoom(){
    if(!this.inZone || !this.currentZone) return;
    const cd=this.currentZone;
    const lvl=cd.level, idx=cd.roomIndex, rc=cd.roomCount;
    this.monsters=[];
    const cx=this.hero.x, cy=this.hero.y;
    if(idx<rc-1){
      const count=Math.min(2+lvl,8);
      for(let i=0;i<count;i++){
        const ang=Math.random()*Math.PI*2;
        const d=100+Math.random()*100;
        const mx=cx+Math.cos(ang)*d;
        const my=cy+Math.sin(ang)*d;
        let maxHp=5+lvl+Math.floor(Math.random()*3);
        let atk=1+Math.floor(lvl/2);
        let def=0+Math.floor(lvl/4);
        let spd=60+Math.random()*40;
        let special=false;
        let name="Démon de donjon";
        let spell=null;

        if(Math.random()<0.06){
          special=true;
          name=randChoice(SPECIAL_DEMON_NAMES);
          maxHp = Math.floor(maxHp*2);
          atk += 3;
          def += 2;
          spd *= 1.1;
          const offensiveSpells = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
          spell = randChoice(offensiveSpells);
        }

        this.monsters.push({
          x:mx,y:my,
          hp:maxHp,maxHp,
          attack:atk,
          defense:def,
          speed:spd,
          attackTimer:0,
          elite:special,
          champion:special,
          special,
          level:lvl,
          biome:"donjon",
          slowed:false,
          spell,
          spellTimer:0,
          wanderTarget:null,
          name
        });
      }
    }else{
      const maxHp=12+lvl*4;
      const bossName=randChoice([
        "Gardien du Portail",
        "Seigneur du Nexus",
        "Azar l’Éclaté",
        "Ancien Démon du Fragment"
      ]);
      const offensiveSpells = SPELL_DEFS.filter(s=>s.type==="aoe" || s.type==="projectile");
      this.monsters.push({
        x:cx,y:cy-120,
        hp:maxHp*2,maxHp:maxHp*2,
        attack:3+lvl+2,
        defense:2+Math.floor(lvl/2)+1,
        speed:70,
        attackTimer:0,
        elite:true,champion:true,
        special:true,
        level:lvl,
        biome:"donjon",
        slowed:false,
        spell:randChoice(offensiveSpells),
        spellTimer:0,
        wanderTarget:null,
        name:bossName
      });
      cd.bossSpawned=true;
    }
  }

  updateZoneState(){
    if(!this.inZone || !this.currentZone) return;
    if(this.monsters.length>0) return;
    const cd=this.currentZone;
    if(cd.roomIndex<cd.roomCount-1){
      cd.roomIndex++;
      this.spawnZoneRoom();
    }else{
      this.rewardZoneClear();
      this.exitZone();
    }
  }

  rewardZoneClear(){
    const hero=this.hero;
    const lvl=this.currentZone ? this.currentZone.level : 1;
    const bonusGold=8+lvl*4;
    hero.gold += bonusGold;
    if(Math.random()<0.5){
      const slotTypes=["armure","épée","relique","objet"];
      const slotType=randChoice(slotTypes);
      const defenseBonus=Math.floor(Math.random()*4);
      const attackBonus=Math.floor(Math.random()*11);
      const speedBonus=Math.floor(Math.random()*11);
      const names={
        armure:"Armure ancienne",
        "épée":"Épée runique",
        relique:"Relique mystique",
        objet:"Talisman étrange"
      };
      const item={
        name:names[slotType],
        slotType,
        attackBonus,
        defenseBonus,
        speedBonus
      };
      hero.addEquipment(item);
    }
  }

  exitZone(){
    if(!this.inZone || !this.currentZone) return;
    const poi=this.currentZone.poi;
    poi.completed=true;
    this.pois=this.pois.filter(p=>p!==poi);
    this.demonNests = this.demonNests.filter(n=>!(n.portal && Math.abs(n.x-poi.x)<1 && Math.abs(n.y-poi.y)<1));

    this.monsters=[];
    this.goldItems=[];
    this.potions=[];
    this.hero.x=poi.x+40;
    this.hero.y=poi.y+40;
    this.inZone=false;
    this.currentZone=null;
  }

  // ---------- EFFETS ----------

  spawnEffect(type,params){
    const eff={
      type,
      age:0,
      duration:params.duration || (
        type==="projectile" || type==="reflectHit" ? 0.3 :
        type==="heal" || type==="reflect" || type==="slash" ? 0.5 :
        0.4
      ),
      color:params.color || "#ffffff",
      start:params.start||null,
      end:params.end||null,
      center:params.center||null,
      radius:params.radius||null,
      dir:params.dir||null,
      angle:params.angle||null
    };
    this.effects.push(eff);
  }

  updateEffects(dt){
    this.effects = this.effects.filter(e=>{
      e.age += dt;
      return e.age < e.duration;
    });
  }

  // ---------- DRAW ----------

  worldToScreen(x,y,camX,camY){
    return {x:x-camX,y:y-camY};
  }

  draw(){
    const ctx=this.ctx;
    ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
    const hero=this.hero;
    const camX = clamp(hero.x - WINDOW_WIDTH/2,0,WORLD_WIDTH-WINDOW_WIDTH);
    const camY = clamp(hero.y - WINDOW_HEIGHT/2,0,WORLD_HEIGHT-WINDOW_HEIGHT);
    this.drawBackground(camX,camY);
    this.drawRivers(camX,camY); // vide, on laisse juste pour structure
    this.drawBridges(camX,camY);
    for(const p of this.pois) this.drawPoi(p,camX,camY);
    for(const g of this.goldItems) this.drawGold(g,camX,camY);
    for(const p of this.potions) this.drawPotion(p,camX,camY);
    for(const m of this.monsters) this.drawMonster(m,camX,camY);
    for(const vh of this.villageHeroes) this.drawVillageHero(vh,camX,camY);
    this.drawHero(hero,camX,camY);
    this.drawEffects(camX,camY);
    this.drawUI();
  }

  drawBackground(camX,camY){
    const ctx=this.ctx;
    const size=TILE_SIZE;
    const x0 = Math.floor(camX/size)-2;
    const x1 = Math.floor((camX+WINDOW_WIDTH)/size)+2;
    const y0 = Math.floor(camY/size)-2;
    const y1 = Math.floor((camY+WINDOW_HEIGHT)/size)+2;
    for(let gx=x0;gx<=x1;gx++){
      for(let gy=y0;gy<=y1;gy++){
        const wx=gx*size, wy=gy*size;
        const cx=wx+size/2, cy=wy+size/2;
        if(cx<0||cx>WORLD_WIDTH||cy<0||cy>WORLD_HEIGHT) continue;
        const tile = this.getTileAt(cx,cy);
        let c1="#35532d", c2="#3a5b34";
        if(tile===TILE.FOREST){ c1="#234f2b"; c2="#275733"; }
        else if(tile===TILE.MARSH){ c1="#26352c"; c2="#2b3b32"; }
        else if(tile===TILE.MOUNTAIN){ c1="#4b4f5a"; c2="#555b66"; }
        else if(tile===TILE.PLAINS){ c1="#3f6b29"; c2="#44752e"; }
        else if(tile===TILE.ROAD){ c1="#5c5243"; c2="#665b48"; }
        else if(tile===TILE.WATER){ c1="#1e88e5"; c2="#42a5f5"; }
        else if(tile===TILE.TOWN){ c1="#8d6e63"; c2="#a1887f"; }
        else if(tile===TILE.ZONE){ c1="#4e342e"; c2="#6d4c41"; }

        const col = ((gx+gy)&1)===0 ? c1 : c2;
        const s=this.worldToScreen(wx,wy,camX,camY);
        ctx.fillStyle=col;
        ctx.fillRect(s.x,s.y,size+1,size+1);

        // Contour léger pour toutes les cases SAUF l'eau (rivières sans traits)
        if(tile !== TILE.WATER){
          ctx.strokeStyle="rgba(0,0,0,0.18)";
          ctx.lineWidth=1;
          ctx.strokeRect(s.x,s.y,size+1,size+1);
        }
      }
    }
  }

  drawRivers(camX,camY){
    // plus aucun trait sur les rivières : elles existent seulement via les tiles WATER / MARSH
  }

  drawBridges(camX,camY){
    const ctx=this.ctx;
    for(const br of this.bridges){
      const s=this.worldToScreen(br.x,br.y,camX,camY);
      const w=42,h=16;
      ctx.fillStyle="#6d4c41";
      ctx.strokeStyle="#3e2723";
      ctx.lineWidth=2;
      ctx.fillRect(s.x-w/2,s.y-h/2,w,h);
      ctx.strokeRect(s.x-w/2,s.y-h/2,w,h);
      ctx.strokeStyle="#bcaaa4";
      ctx.beginPath(); ctx.moveTo(s.x-w/2,s.y-h/4); ctx.lineTo(s.x+w/2,s.y-h/4); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(s.x-w/2,s.y+h/4); ctx.lineTo(s.x+w/2,s.y+h/4); ctx.stroke();
    }
  }

  drawPoi(p,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(p.x,p.y,camX,camY);
    const r=20;
    ctx.save();
    if(p.type==="town"){
      ctx.fillStyle="#e0cda1";
      ctx.strokeStyle="#a38c6a";
      ctx.fillRect(s.x-r,s.y-r,2*r,2*r);
      ctx.strokeRect(s.x-r,s.y-r,2*r,2*r);
      ctx.beginPath();
      ctx.moveTo(s.x-r,s.y-r);
      ctx.lineTo(s.x,s.y-r-15);
      ctx.lineTo(s.x+r,s.y-r);
      ctx.closePath();
      ctx.fillStyle="#c14953";
      ctx.strokeStyle="#7b2f36";
      ctx.fill(); ctx.stroke();
      ctx.fillStyle="white";
      ctx.font="8px Helvetica";
      ctx.textAlign="center";
      const name=p.name||"Ville";
      const lvl=p.level||1;
      ctx.fillText(`${name} (Lv ${lvl})`,s.x,s.y+r+10);
    } else if(p.type==="forest"){
      for(let i=-1;i<=1;i++){
        const ox=s.x+i*12;
        ctx.fillStyle="#5b3b1f";
        ctx.fillRect(ox-2,s.y,4,6);
        ctx.beginPath();
        ctx.ellipse(ox,s.y-4,6,8,0,0,Math.PI*2);
        ctx.fillStyle="#1f7a3a";
        ctx.fill();
      }
      ctx.fillStyle="white";
      ctx.font="8px Helvetica";
      ctx.textAlign="center";
      ctx.fillText("Forêt",s.x,s.y+r+10);
    } else if(p.type==="zone"){
      ctx.save();
      ctx.translate(s.x,s.y);
      ctx.beginPath();
      ctx.arc(0,0,r,0,Math.PI*2);
      ctx.fillStyle="#311b92";
      ctx.fill();
      ctx.strokeStyle="#b388ff";
      ctx.lineWidth=2;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(0,0,r-6,0,Math.PI*2);
      ctx.strokeStyle="#ff5252";
      ctx.setLineDash([3,3]);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.moveTo(-5,-8);
      ctx.lineTo(0,8);
      ctx.lineTo(5,-8);
      ctx.strokeStyle="#ffcc80";
      ctx.stroke();
      ctx.restore();

      ctx.fillStyle="white";
      ctx.font="8px Helvetica";
      ctx.textAlign="center";
      const lvl=p.level||1;
      ctx.fillText(`Portail démoniaque Lv ${lvl}`,s.x,s.y+r+12);
    } else if(p.type==="crossroad"){
      const rr=10;
      ctx.beginPath();
      ctx.arc(s.x,s.y,rr,0,Math.PI*2);
      ctx.fillStyle="#60606a"; ctx.fill();
      ctx.strokeStyle="#bbbbbb"; ctx.stroke();
      ctx.fillStyle="#8d6e63";
      ctx.fillRect(s.x-2,s.y-rr-6,4,6);
      ctx.beginPath();
      ctx.moveTo(s.x-7,s.y-rr-6);
      ctx.lineTo(s.x+7,s.y-rr-6);
      ctx.lineTo(s.x,s.y-rr-14);
      ctx.closePath();
      ctx.fillStyle="#f5f5f5"; ctx.fill();
      ctx.strokeStyle="#b0b0b0"; ctx.stroke();
      ctx.fillStyle="#e0e0e0";
      ctx.font="7px Helvetica";
      ctx.textAlign="center";
      ctx.fillText("Croisement",s.x,s.y+rr+6);
    }
    ctx.restore();
  }

  drawGold(g,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(g.x,g.y,camX,camY);
    const r=6;
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle="#ffdd33"; ctx.fill();
    ctx.strokeStyle="#aa9900"; ctx.stroke();
  }

  drawPotion(p,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(p.x,p.y,camX,camY);
    const r=7;
    ctx.fillStyle="#3399ff";
    ctx.strokeStyle="#115577";
    ctx.fillRect(s.x-r,s.y-r,2*r,2*r);
    ctx.strokeRect(s.x-r,s.y-r,2*r,2*r);
    ctx.fillStyle="#e6e6e6";
    ctx.fillRect(s.x-2,s.y-r-4,4,4);
    ctx.strokeStyle="#b0b0b0";
    ctx.strokeRect(s.x-2,s.y-r-4,4,4);
  }

  drawMonster(m,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(m.x,m.y,camX,camY);
    const r=14;

    let body;
    if(m.special) body="#4a148c";
    else if(m.champion) body="#d4af37";
    else if(m.elite) body="#884444";
    else body="#557755";

    let ring=null;
    if(m.special) ring="#ff80ff";
    else if(m.biome==="montagnes") ring="#bcaaa4";
    else if(m.biome==="marais") ring="#004d40";
    else if(m.biome==="forêt") ring="#1b5e20";
    else if(m.biome==="plaines") ring="#fdd835";
    else if(m.biome==="collines") ring="#827717";
    else if(m.biome==="donjon") ring="#9c27b0";

    ctx.save();
    if(ring){
      ctx.beginPath();
      ctx.arc(s.x,s.y,r+3,0,Math.PI*2);
      ctx.strokeStyle=ring;
      ctx.lineWidth= m.special ? 3 : 2;
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle=body; ctx.fill();
    ctx.strokeStyle="#222"; ctx.stroke();

    if(m.special){
      ctx.beginPath();
      ctx.moveTo(s.x-6,s.y-8);
      ctx.lineTo(s.x-2,s.y-12);
      ctx.lineTo(s.x+2,s.y-8);
      ctx.moveTo(s.x+6,s.y-8);
      ctx.lineTo(s.x+2,s.y-12);
      ctx.strokeStyle="#ffeb3b";
      ctx.stroke();
    }

    ctx.fillStyle="#fff";
    ctx.fillRect(s.x-4,s.y-2,3,3);
    ctx.fillRect(s.x+1,s.y-2,3,3);
    ctx.fillStyle="#000";
    ctx.fillRect(s.x-3,s.y-1,1,1);
    ctx.fillRect(s.x+2,s.y-1,1,1);

    const ratio = m.maxHp>0 ? m.hp/m.maxHp : 0;
    const bw=26,bh=4;
    const bx1=s.x-bw/2, by1=s.y-r-8;
    ctx.fillStyle="#220000"; ctx.fillRect(bx1,by1,bw,bh);
    ctx.fillStyle= m.special ? "#ff80ab" : "#ff5555";
    ctx.fillRect(bx1,by1,bw*ratio,bh);
    ctx.strokeStyle="#440000"; ctx.strokeRect(bx1,by1,bw,bh);

    ctx.fillStyle= m.special ? "#ffb3ff" : "#ffcc66";
    ctx.font="8px Helvetica";
    ctx.textAlign="center";
    const name=m.name||"Démon";
    const lvl=m.level||1;
    ctx.fillText(`${name} (Lv ${lvl})`,s.x,s.y-r-14);
    ctx.restore();
  }

  drawVillageHero(vh,camX,camY){
    if(vh.dead) return;
    const ctx=this.ctx;
    const s=this.worldToScreen(vh.x,vh.y,camX,camY);
    const r=13;
    ctx.save();
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle=vh.bodyColor;
    ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle=vh.borderColor;
    ctx.stroke();

    ctx.fillStyle="#f1e0c5";
    ctx.fillRect(s.x-6,s.y-6,12,6);
    ctx.fillStyle="#000";
    ctx.fillRect(s.x-3,s.y-5,2,2);
    ctx.fillRect(s.x+1,s.y-5,2,2);
    ctx.fillStyle="rgba(0,0,0,0.4)";
    ctx.fillRect(s.x-7,s.y-8,14,3);

    const ratio = vh.maxHp>0 ? vh.hp/vh.maxHp : 0;
    const bw=24,bh=4;
    const bx=s.x-bw/2, by=s.y-r-8;
    ctx.fillStyle="#220000";
    ctx.fillRect(bx,by,bw,bh);
    ctx.fillStyle="#66bb6a";
    ctx.fillRect(bx,by,bw*ratio,bh);
    ctx.strokeStyle="#335533";
    ctx.strokeRect(bx,by,bw,bh);

    ctx.fillStyle="#ffffff";
    ctx.font="8px Helvetica";
    ctx.textAlign="center";
    ctx.fillText(`${vh.name} (Lv ${vh.level})`, s.x, s.y-r-16);

    ctx.restore();
  }

  drawHero(hero,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(hero.x,hero.y,camX,camY);
    const r=16;
    ctx.save();
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle="#4cc9f0"; ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle="#1d3557"; ctx.stroke();
    ctx.fillStyle="#f1e0c5";
    ctx.fillRect(s.x-6,s.y-6,12,6);
    ctx.fillStyle="#000";
    ctx.fillRect(s.x-3,s.y-5,2,2);
    ctx.fillRect(s.x+1,s.y-5,2,2);
    const ang=Math.atan2(hero.dirY,hero.dirX);
    const tipx=s.x+Math.cos(ang)*(r+6);
    const tipy=s.y+Math.sin(ang)*(r+6);
    const lx=s.x+Math.cos(ang+2.5)*r;
    const ly=s.y+Math.sin(ang+2.5)*r;
    const rx=s.x+Math.cos(ang-2.5)*r;
    const ry=s.y+Math.sin(ang-2.5)*r;
    ctx.beginPath();
    ctx.moveTo(tipx,tipy);
    ctx.lineTo(lx,ly);
    ctx.lineTo(rx,ry);
    ctx.closePath();
    ctx.fillStyle="#ffdd57";
    ctx.strokeStyle="#b38a00";
    ctx.fill(); ctx.stroke();

    if(hero.reflectTimer>0){
      const t = hero.reflectTimer;
      ctx.globalAlpha = 0.4 + 0.2*Math.sin(t*8);
      ctx.beginPath();
      ctx.arc(s.x,s.y,r+6,0,Math.PI*2);
      ctx.strokeStyle="#fff59d";
      ctx.lineWidth=3;
      ctx.stroke();
    }

    ctx.restore();
  }

  drawEffects(camX,camY){
    const ctx=this.ctx;
    for(const e of this.effects){
      const t=e.age/e.duration;
      const col=e.color;
      ctx.save();
      if((e.type==="projectile" || e.type==="reflectHit") && e.start && e.end){
        const s=this.worldToScreen(e.start.x,e.start.y,camX,camY);
        const f=this.worldToScreen(e.end.x,e.end.y,camX,camY);
        ctx.strokeStyle=col;
        ctx.globalAlpha = e.type==="reflectHit" ? (0.7*(1-t)) : (0.9*(1-t));
        ctx.lineWidth= e.type==="reflectHit" ? 5*(1-t) : 4*(1-t);
        ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(f.x,f.y); ctx.stroke();
      } else if(e.type==="aoe" && e.center){
        const c=this.worldToScreen(e.center.x,e.center.y,camX,camY);
        const radius=e.radius||100;
        const cr=radius*(0.5+0.5*t);
        ctx.fillStyle=col;
        ctx.globalAlpha=0.4*(1-t);
        ctx.beginPath(); ctx.arc(c.x,c.y,cr,0,Math.PI*2); ctx.fill();
      } else if(e.type==="heal" && e.center){
        const c=this.worldToScreen(e.center.x,e.center.y,camX,camY);
        const maxR=30;
        const cr=maxR*(0.5+0.5*Math.sin(Math.PI*t));
        ctx.fillStyle=col;
        ctx.globalAlpha=0.4;
        ctx.beginPath(); ctx.arc(c.x,c.y,cr,0,Math.PI*2); ctx.fill();
      } else if(e.type==="slow" && e.center){
        const c=this.worldToScreen(e.center.x,e.center.y,camX,camY);
        const radius=e.radius||150;
        ctx.strokeStyle=col;
        ctx.lineWidth=Math.max(1,6*(1-t));
        ctx.globalAlpha=0.7*(1-t);
        ctx.beginPath(); ctx.arc(c.x,c.y,radius,0,Math.PI*2); ctx.stroke();
      } else if(e.type==="reflect" && e.center){
        const c=this.worldToScreen(e.center.x,e.center.y,camX,camY);
        const r1=24+8*Math.sin(t*Math.PI);
        ctx.globalAlpha=0.4;
        ctx.strokeStyle=col;
        ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(c.x,c.y,r1,0,Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(c.x,c.y,r1+6,0,Math.PI*2); ctx.stroke();
      } else if(e.type==="slash" && e.center && e.dir){
        const c=this.worldToScreen(e.center.x,e.center.y,camX,camY);
        const ang = Math.atan2(e.dir.y,e.dir.x);
        const range = e.range || 120;
        const half = (e.angle||Math.PI/2)/2;
        ctx.globalAlpha = 0.45*(1-t);
        ctx.fillStyle=col;
        ctx.beginPath();
        ctx.moveTo(c.x,c.y);
        ctx.arc(c.x,c.y,range,ang-half,ang+half);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle="#ffecb3";
        ctx.lineWidth=1;
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  drawStatIcon(ctx,cx,cy,kind){
    const size=6;
    if(kind==="hp"){
      ctx.beginPath();
      ctx.moveTo(cx,cy+size);
      ctx.lineTo(cx-size*0.8,cy+size*0.2);
      ctx.lineTo(cx-size*0.8,cy-size*0.4);
      ctx.lineTo(cx,cy-size);
      ctx.lineTo(cx+size*0.8,cy-size*0.4);
      ctx.lineTo(cx+size*0.8,cy+size*0.2);
      ctx.closePath();
      ctx.fillStyle="#e66a6a"; ctx.fill();
      ctx.strokeStyle="#a64242"; ctx.stroke();
    } else if(kind==="mp"){
      ctx.beginPath();
      ctx.ellipse(cx,cy,size*0.7,size*0.6,0,0,Math.PI*2);
      ctx.fillStyle="#5b7bdc"; ctx.fill();
      ctx.strokeStyle="#3a4f8a"; ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx-size*0.4,cy-size*0.5);
      ctx.lineTo(cx+size*0.4,cy-size*0.5);
      ctx.lineTo(cx,cy-size);
      ctx.closePath();
      ctx.fill(); ctx.stroke();
    } else if(kind==="xp"){
      const pts=[];
      for(let i=0;i<5;i++){
        const ang=i*(2*Math.PI/5);
        const or=size*0.9, ir=size*0.4;
        pts.push([cx+or*Math.cos(ang),cy+or*Math.sin(ang)]);
        const ang2=ang+Math.PI/5;
        pts.push([cx+ir*Math.cos(ang2),cy+ir*Math.sin(ang2)]);
      }
      ctx.beginPath();
      ctx.moveTo(pts[0][0],pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
      ctx.closePath();
      ctx.fillStyle="#c0bf63"; ctx.fill();
      ctx.strokeStyle="#807f3d"; ctx.stroke();
    }
  }

  drawItemIcon(ctx,cx,cy,slotType){
    const r=10;
    if(slotType==="armure"){
      const pts=[
        [cx,cy-r],
        [cx+r*0.8,cy-r*0.3],
        [cx+r*0.8,cy+r*0.4],
        [cx,cy+r],
        [cx-r*0.8,cy+r*0.4],
        [cx-r*0.8,cy-r*0.3]
      ];
      ctx.beginPath();
      ctx.moveTo(pts[0][0],pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
      ctx.closePath();
      ctx.fillStyle="#779ecb"; ctx.fill();
      ctx.strokeStyle="#445d8e"; ctx.stroke();
    } else if(slotType==="épée"){
      ctx.strokeStyle="#d4af37";
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(cx,cy-r); ctx.lineTo(cx,cy+r*0.6); ctx.stroke();
      ctx.fillStyle="#8d6e63";
      ctx.beginPath();
      ctx.moveTo(cx-r*0.3,cy+r*0.6);
      ctx.lineTo(cx+r*0.3,cy+r*0.6);
      ctx.lineTo(cx,cy+r);
      ctx.closePath();
      ctx.fill();
    } else if(slotType==="relique"){
      const pts=[];
      for(let i=0;i<6;i++){
        const ang=i*(2*Math.PI/6);
        pts.push([cx+r*0.8*Math.cos(ang),cy+r*0.8*Math.sin(ang)]);
      }
      ctx.beginPath();
      ctx.moveTo(pts[0][0],pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
      ctx.closePath();
      ctx.fillStyle="#b39ddb"; ctx.fill();
      ctx.strokeStyle="#7e57c2"; ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.ellipse(cx,cy,r*0.8,r*0.8,0,0,Math.PI*2);
      ctx.fillStyle="#d7ccc8"; ctx.fill();
      ctx.strokeStyle="#8d6e63"; ctx.stroke();
    }
  }

  drawBar(ctx,x,y,w,h,ratio,color){
    ratio=clamp(ratio,0,1);
    ctx.fillStyle="#222b40";
    ctx.strokeStyle="#444c66";
    ctx.fillRect(x,y,w,h);
    ctx.strokeRect(x,y,w,h);
    ctx.fillStyle=color;
    ctx.fillRect(x,y,w*ratio,h);
  }

  drawSpellIcon(ctx, cx, cy, spell){
    if(!spell) return;
    const type = spell.type;
    const col = SPELL_COLORS[spell.name] || "#ffffff";
    ctx.save();
    ctx.translate(cx,cy);
    ctx.strokeStyle=col;
    ctx.fillStyle=col;
    ctx.lineWidth=2;

    if(type==="projectile"){
      ctx.beginPath();
      ctx.moveTo(-8,0);
      ctx.lineTo(6,0);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(6,0);
      ctx.lineTo(0,-5);
      ctx.lineTo(0,5);
      ctx.closePath();
      ctx.fill();
    } else if(type==="aoe"){
      ctx.globalAlpha=0.9;
      ctx.beginPath();
      ctx.arc(0,0,8,0,Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha=0.4;
      ctx.beginPath();
      ctx.arc(0,0,4,0,Math.PI*2);
      ctx.fill();
    } else if(type==="heal"){
      ctx.beginPath();
      ctx.rect(-6,-2,12,4);
      ctx.rect(-2,-6,4,12);
      ctx.fill();
    } else if(type==="slow"){
      ctx.beginPath();
      ctx.arc(0,0,7,0,Math.PI*1.5);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(4,4);
      ctx.stroke();
    } else if(type==="reflect"){
      ctx.beginPath();
      ctx.arc(0,0,7,0,Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(0,0,4,0,Math.PI*2);
      ctx.stroke();
    } else if(type==="slash"){
      ctx.beginPath();
      ctx.moveTo(-6,4);
      ctx.lineTo(0,-6);
      ctx.lineTo(6,4);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  drawUI(){
    const ctx=this.ctx;
    const hero=this.hero;
    const panelX=10,panelY=10,panelW=360,panelH=270;

    ctx.save();
    ctx.fillStyle="#0d1522";
    ctx.fillRect(panelX+2,panelY+2,panelW+2,panelH+2);
    ctx.fillStyle="#1a2435";
    ctx.strokeStyle="#445070";
    ctx.lineWidth=2;
    ctx.fillRect(panelX,panelY,panelW,panelH);
    ctx.strokeRect(panelX,panelY,panelW,panelH);

    const barW=230,barH=16;
    const mx=panelX+20,my=panelY+15;

    const hpRatio = hero.maxHp>0?hero.hp/hero.maxHp:0;
    this.drawStatIcon(ctx,mx-18,my+barH/2,"hp");
    this.drawBar(ctx,mx,my,barW,barH,hpRatio,"#e05555");
    ctx.fillStyle="white"; ctx.font="9px Helvetica"; ctx.textAlign="center";
    ctx.fillText(`PV ${hero.hp}/${hero.maxHp}`,mx+barW/2,my+barH/2+3);

    const mpY=my+barH+8;
    const mpRatio = hero.maxMp>0?hero.mp/hero.maxMp:0;
    this.drawStatIcon(ctx,mx-18,mpY+barH/2,"mp");
    this.drawBar(ctx,mx,mpY,barW,barH,mpRatio,"#5577dd");
    ctx.fillStyle="white";
    ctx.fillText(`MP ${Math.floor(hero.mp)}/${hero.maxMp}`,mx+barW/2,mpY+barH/2+3);

    const xpY=mpY+barH+8;
    const xpRatio = hero.xpToNext>0?hero.xp/hero.xpToNext:0;
    this.drawStatIcon(ctx,mx-18,xpY+barH/2,"xp");
    this.drawBar(ctx,mx,xpY,barW,barH,xpRatio,"#88bb44");
    ctx.fillStyle="black";
    ctx.fillText(`XP ${hero.xp}/${hero.xpToNext} (Niv ${hero.level})`,mx+barW/2,xpY+barH/2+3);

    let infoY=xpY+barH+12;
    ctx.fillStyle="white"; ctx.font="11px Helvetica"; ctx.textAlign="left";
    ctx.fillText(`Héros : ${hero.name}`,mx,infoY);
    let statsY=infoY+18;
    ctx.fillStyle="#cccccc"; ctx.font="9px Helvetica";
    ctx.fillText(`ATK ${hero.attack}   DEF ${hero.defense}   VIT ${Math.floor(hero.moveSpeed)}`,mx,statsY);
    let info2Y=statsY+16;
    ctx.fillText(`Or : ${hero.gold}   Potions : ${hero.potionsCount}   Sac : ${hero.backpack.length}`,mx,info2Y);

    const biome=this.getBiome(hero.x,hero.y);
    let biomeY=info2Y+16;
    ctx.fillStyle="#a5d6a7"; ctx.font="9px Helvetica";
    ctx.fillText(`Biome : ${biome.charAt(0).toUpperCase()+biome.slice(1)}`,mx,biomeY);

    const targetDesc = (()=>{
      const target=hero.target;
      if(!target || !target.obj) return "Aucune";
      const obj=target.obj;
      if(obj.x===undefined || obj.y===undefined) return "Aucune";
      const distTo=Math.floor(dist(hero.x,hero.y,obj.x,obj.y));
      const suffix = `- ${distTo}u`;
      if(target.type==="monster"){
        const name=obj.name||"Démon";
        const lvl=obj.level||1;
        return `${name} niv ${lvl} ${suffix}`;
      }
      if(target.type==="potion") return `Potion ${suffix}`;
      if(target.type==="zone"){
        const lvl=obj.level||1;
        return `Portail niv ${lvl} ${suffix}`;
      }
      if(target.type==="town"){
        const name=obj.name||"Ville";
        return `${name} ${suffix}`;
      }
      if(target.type==="forest") return `Forêt ${suffix}`;
      if(target.type==="point") return `Position ${suffix}`;
      return "Aucune";
    })();
    const targetY=biomeY+16;
    ctx.fillStyle="#cfd8dc"; ctx.font="9px Helvetica";
    ctx.fillText(`Cible : ${targetDesc}`,mx,targetY);

    const spellName = hero.spell?hero.spell.name:"Aucun";
    const iconBoxX=panelX+panelW-84, iconBoxY=my;
    ctx.fillStyle="#2b3248";
    ctx.fillRect(iconBoxX,iconBoxY,54,54);
    ctx.strokeStyle="#707890"; ctx.strokeRect(iconBoxX,iconBoxY,54,54);
    this.drawSpellIcon(ctx,iconBoxX+27,iconBoxY+22,hero.spell);
    ctx.fillStyle="white"; ctx.font="8px Helvetica"; ctx.textAlign="center";
    ctx.fillText(spellName,iconBoxX+27,iconBoxY+52);

    const buffBoxX = iconBoxX;
    const buffBoxY = iconBoxY + 58;
    ctx.fillStyle="#191f30";
    ctx.fillRect(buffBoxX,buffBoxY,54,32);
    ctx.strokeStyle="#445070";
    ctx.strokeRect(buffBoxX,buffBoxY,54,32);
    ctx.font="8px Helvetica";
    ctx.fillStyle="#bbbbbb";
    ctx.textAlign="center";
    ctx.fillText("Buffs", buffBoxX+27, buffBoxY+9);

    if(hero.reflectTimer>0){
      ctx.save();
      ctx.translate(buffBoxX+12,buffBoxY+19);
      ctx.strokeStyle="#fff59d";
      ctx.fillStyle="#fff59d";
      ctx.lineWidth=1.5;
      ctx.beginPath();
      ctx.arc(0,0,6,0,Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-3,0);
      ctx.lineTo(0,-4);
      ctx.lineTo(3,0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      ctx.fillStyle="#fff59d";
      ctx.textAlign="left";
      ctx.fillText(`Renvoi ${hero.reflectTimer.toFixed(1)}s`, buffBoxX+20, buffBoxY+20);
    }

    const invX=panelX+20, invY=panelY+panelH-80;
    const slotSize=42, spacing=12;
    for(let i=0;i<3;i++){
      const sx=invX+i*(slotSize+spacing), sy=invY;
      const item=hero.inventory[i];
      let fill="#2a324a";
      if(item){
        const t=item.slotType;
        if(t==="armure") fill="#394d6a";
        else if(t==="épée") fill="#6a4d39";
        else if(t==="relique") fill="#5d3c5a";
        else fill="#5a5639";
      }
      ctx.fillStyle=fill;
      ctx.strokeStyle="#8890a8";
      ctx.fillRect(sx,sy,slotSize,slotSize);
      ctx.strokeRect(sx,sy,slotSize,slotSize);
      if(item){
        this.drawItemIcon(ctx,sx+slotSize/2,sy+slotSize/2,item.slotType);
        ctx.fillStyle="#eeeeee"; ctx.font="7px Helvetica"; ctx.textAlign="center";
        const stats=`${item.defenseBonus}/${item.attackBonus}/${item.speedBonus}`;
        ctx.fillText(stats,sx+slotSize/2,sy+slotSize-4);
      }
    }

    const qY = panelY+panelH+2;
    if(this.currentQuest){
      const q=this.currentQuest;
      ctx.fillStyle="#141a28";
      ctx.fillRect(panelX,qY,panelW,52);
      ctx.strokeStyle="#445070"; ctx.strokeRect(panelX,qY,panelW,52);
      ctx.fillStyle="#ffeb3b"; ctx.font="10px Helvetica"; ctx.textAlign="left";
      ctx.fillText(`Quête : Tuer ${q.targetCount} démons`,panelX+8,qY+14);
      ctx.fillStyle="#dddddd"; ctx.font="9px Helvetica";
      ctx.fillText(`Progression : ${this.questProgress}/${q.targetCount}`,panelX+8,qY+28);
      ctx.fillText(`Récompense : ${q.reward} or`,panelX+8,qY+40);
    }

    if(this.lastDeathMsgTimer>0){
      ctx.fillStyle="rgba(0,0,0,0.5)";
      ctx.fillRect(0,WINDOW_HEIGHT-40,WINDOW_WIDTH,40);
      ctx.fillStyle="white";
      ctx.font="11px Helvetica";
      ctx.textAlign="center";
      ctx.fillText(this.lastDeathMsg,WINDOW_WIDTH/2,WINDOW_HEIGHT-18);
    }

    ctx.restore();
  }
}

// ===================== LANCEMENT =====================

const canvas = document.getElementById("game");
const game = new Game(canvas);

function loop(){
  game.step();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>

