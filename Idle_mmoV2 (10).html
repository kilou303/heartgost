<!DOCTYPE html> 
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Roguelite – Version PRO – Starglaglax</title>
  <style>
    body {
      margin: 0;
      background: #050811;
      color: white;
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #container {
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
      border: 2px solid #333;
    }
    canvas {
      display: block;
      background: #111122;
    }
  </style>
</head>
<body>
<div id="container">
  <canvas id="game" width="900" height="700"></canvas>
</div>

<script>
// ===================== CONFIG GÉNÉRALE =====================

const WINDOW_WIDTH = 900;
const WINDOW_HEIGHT = 700;

const WORLD_WIDTH = 10000;
const WORLD_HEIGHT = 10000;

const TILE_SIZE = 48;

// Temps : 20 secondes IRL = 1 an en jeu
const YEAR_DURATION = 20.0;      // 20s -> 1 an

const MONSTER_LIMIT = 600; // limite globale de démons vivants

// Spawn démons : chaque nid (forêt ou zone) spawn toutes les 4s, max de démons configurables
const NEST_SPAWN_INTERVAL = 4.0;
const NEST_MONSTER_LIMIT = 4;           // par défaut
const FOREST_NEST_MONSTER_LIMIT = 6;    // nombre max de démons par nid en forêt (facile à ajuster)

// Neutres (vaches/poules)
const NEUTRAL_SPAWN_INTERVAL = 25.0;
const NEUTRAL_LIMIT = 180;
const NEUTRAL_SPAWN_CHANCE = 0.6;

// Vagabonds
const VAGABOND_LIMIT = 10;
const VAGABOND_SPAWN_INTERVAL = 90.0; // un vagabond potentiel toutes les 90s environ

// Shops & Coffres
const SHOP_COST = 500;
const SHOP_SPAWN_INTERVAL = 28.0;
const SHOP_SPAWN_CHANCE = 0.35;
const CHEST_SPAWN_INTERVAL = 26.0;
const CHEST_SPAWN_CHANCE = 0.4;

// Portails dynamiques
const PORTAL_RESPAWN_INTERVAL = 300.0; // toutes les 5 minutes
const PORTAL_MIN_LEVEL_FOR_AUTO = 9;   // à partir du niveau 9, on force un portail si aucun

// Quêtes
const QUEST_REWARD_MIN = 50;
const QUEST_REWARD_MAX = 300;
const QUEST_KILL_RADIUS = 280; // rayon autour de la zone/forêt ciblée

// Villes & alliances
const TOWN_BASE_MAX_HP = 800;
const TOWN_HP_PER_LEVEL = 80;
const TOWN_SOLDIER_COST = 300;
const TOWN_SOLDIER_LIMIT = 4;

const ALLIANCE_NAMES = [
  "Pacte de l’Aube",
  "Confrérie des Cendres",
  "Serment d’Acier",
  "Cercle des Arcanes"
];

// Guerres d'alliances
const ALLIANCE_WAR_MIN_DURATION = 140.0;
const ALLIANCE_WAR_MAX_DURATION = 260.0;
const ALLIANCE_WAR_CHECK_INTERVAL = 45.0;
const ALLIANCE_WAR_BASE_CHANCE = 0.06;

// Diplomatie & guerre
const ALLIANCE_WAR_SUMMIT_INTERVAL = 55.0;       // fréquence des rencontres diplomatiques potentielles
const ALLIANCE_NEUTRAL_SUMMIT_CHANCE = 0.65;     // chance de convoquer un sommet sur terrain neutre
const ALLIANCE_TRUCE_BASE_CHANCE = 0.25;         // chance de signer une trêve lorsqu'une rencontre a lieu
const ALLIANCE_PEACE_RELATION_BOOST = 14;        // gain de relation en cas de diplomatie réussie
const ALLIANCE_DEFENSE_BONUS = 0.25;             // bonus défensif global (fortifications, milices)
const ALLIANCE_ATTACK_PRESSURE_MULT = 0.35;      // influence de la pression militaire sur les sièges

const ALLIANCE_TOWN_SIEGE_DAMAGE = 18;        // dégâts "par soldat/héros" sur les villes ennemies
const ALLIANCE_TOWN_PILLAGE_GOLD_RATIO = 0.35;
const ALLIANCE_TOWN_MIN_GOLD_LOOT = 60;

// Villes démoniaques & Seigneur démon
const DEMON_CITY_COUNT = 4;
const DEMON_CITY_SPAWN_INTERVAL = 7.0; // toutes les 7s une vague autour des villes démoniaques

const DEMON_LORD_CHANCE = 0.004;      // ~0,4% des démons
const DEMON_LORD_HP_MULT = 20;        // PV x20
const DEMON_LORD_ATTACK_MULT = 2;     // ATK x2
const DEMON_LORD_DEFENSE_MULT = 3;    // DEF x3


// IA héros
const HERO_AGGRO_RADIUS = 300;
const HERO_LOOT_RADIUS = 300;
const HERO_POI_LEVEL_MAX_DELTA = 3;

// Knockback
const KNOCKBACK_HERO = 14.0;
const KNOCKBACK_MONSTER = 14.0;
const KNOCKBACK_SELF = 6.0;

// XP partagée
const XP_RADIUS = 70;

// Regen globale
const BASE_HP_REGEN_RATIO = 0.008;  // ~0,8% PV max / sec
const BASE_MP_REGEN_RATIO = 0.03;   // ~3% PM max / sec
const MONSTER_HP_REGEN_RATIO = 0.004;
const VILLAGE_HP_REGEN_RATIO = 0.006;
const NEUTRAL_HP_REGEN_RATIO = 0.01;

// Mana/potions
const POTION_HEAL_RATIO = 0.35;

// Déplacement selon terrain
const ROAD_SAFE_RADIUS = 80.0;
const RIVER_SAFE_RADIUS = 40.0;
const RIVER_COUNT = 2;

// Villes / Forêts / Zones
const TOWN_COUNT = 20;
const FOREST_COUNT = 30;
const ZONE_COUNT = 15;

// Boutique de ville
const TOWN_SHOP_COST = 100;

// Cooldowns magie
const GLOBAL_SPELL_CD_FACTOR = 0.55; // réduit tous les CD

// Ratios de dégâts de sort basés sur l'ATK
// 1.2 = 120% de l'attaque, 0.8 = 80%, etc.
const SPELL_ATTACK_RATIO_BY_TYPE = {
  projectile: 1.2, // 120% de l'ATK
  aoe: 0.8,        // 80% de l'ATK
  slash: 1.0       // 100% de l'ATK
};

// Durée de vie des loot au sol
const GOLD_TTL = 20.0;
const POTION_TTL = 25.0;
const MANA_SHARD_TTL = 35.0;
const MANA_SHARD_DROP_CHANCE = 0.28;
const MANA_SHARD_WORLD_SPAWN_INTERVAL = 32.0;
const MANA_SHARD_WORLD_LIMIT = 40;

const PRE_FRAGMENT_TTL = 20.0;
const PRE_FRAGMENT_DROP_CHANCE = 0.08;   // chance de pré-fragment instable sur la mort d'un monstre
const STABLE_FRAGMENT_DROP_CHANCE = 0.0; // (géré via les bêtes magiques)

// Commerce entre royaumes
const CARAVAN_SPAWN_INTERVAL = 70.0;
const CARAVAN_BASE_VALUE = 40;
const CARAVAN_POTION_VALUE = 22;
const CARAVAN_FRAGMENT_VALUE = 55;
const POTION_SALE_PRICE = 25;

// ===================== TILESET =====================

const TILE = {
  VOID: 0,
  GRASS: 1,
  FOREST: 2,
  MARSH: 3,
  MOUNTAIN: 4,
  PLAINS: 5,
  ROAD: 6,
  WATER: 7,
  TOWN: 8,
  ZONE: 9,
  DEMON_CITY: 10
};

const TILE_MOVE_MULT = {
  [TILE.GRASS]: 1.0,
  [TILE.FOREST]: 0.9,
  [TILE.MARSH]: 0.5,
  [TILE.MOUNTAIN]: 0.8,
  [TILE.PLAINS]: 1.05,
  [TILE.ROAD]: 1.15,
  [TILE.WATER]: 0.7,
  [TILE.TOWN]: 1.0,
  [TILE.ZONE]: 1.0,
  [TILE.DEMON_CITY]: 1.0,
  [TILE.VOID]: 1.0
};

// ===================== NOMS, TITRES, SORTS =====================

const HERO_NAMES = [
  "Raelan","Kiro","Mira","Lunor","Kael","Nira","Taro","Elyon",
  "Railey","Killian","Oscar","Alara","Hindra","Gloria","Jessica",
  "Nakura","Zander","Djegui","Targan","Azar","Lyra","Soren","Maelis",
  "Ilyas","Kassandra","Vorun","Selene","Orion","Thalia","Jaro",
  "Elwyn","Kaera","Justice"
];

const HERO_TITLES = [
  "le Fragmenté","la Fragmentée",
  "le Marcheur des fragments","la Marcheuse des fragments",
  "le Briseur de démons","la Briseuse de démons",
  "le Fils de Kuro","la Fille de Kuro",
  "le Porte-Ongle","la Porte-Ongle",
  "l’Éclat vivant","la Foudre de Starglaglax",
  "le Gardien de Surville","la Gardienne de Kuro","le Maudit"
];

const SPECIAL_DEMON_NAMES = [
  "Azar l’Évolué",
  "Gardien du Nexus",
  "Démon Ancien de Starglaglax",
  "Briseur de Portail",
  "Seigneur des Fragments",
  "Ombre de Hertegost",
  "Hurleur Écarlate",
  "Dévoreur de Kuro"
];

// ======== LISTE DE SORTS ========

const SPELL_DEFS = [
  // --- Projectiles simples / puissants ---
  { name:"Éclat d’Ongle",           type:"projectile", cost:5,  power:4, range:280, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:1.4 },
  { name:"Cendres de Triota",       type:"projectile", cost:6,  power:5, range:260, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:1.6 },
  { name:"Courroux de Surville",    type:"projectile", cost:7,  power:6, range:260, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:2.0 },
  { name:"Flamme Démoniaque",       type:"projectile", cost:6,  power:4, range:260, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:1.5 },
  { name:"Choc du Fragment Vivant", type:"projectile", cost:8,  power:7, range:260, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:2.3 },
  { name:"Lame d’Azar",             type:"projectile", cost:9,  power:8, range:270, radius:0,   slow_factor:0,    heal_ratio:0, cooldown:2.6 },
  { name:"Griffes Spectrales",      type:"projectile", cost:5,  power:4, range:240, radius:0,   slow_factor:0.15, heal_ratio:0, cooldown:1.4 },
  { name:"Trait de Hertegost",      type:"projectile", cost:6,  power:5, range:290, radius:0,   slow_factor:0.1,  heal_ratio:0, cooldown:1.8 },

  // --- Projectiles complexes ---
  { name:"Chaîne de Foudre d’Alara", type:"projectile", cost:9,  power:6, range:260, radius:0, slow_factor:0, heal_ratio:0,
    cooldown:2.7, chainRadius:90, chainFactor:0.5 },
  { name:"Piqûre de Bombes Vivantes", type:"projectile", cost:7, power:5, range:250, radius:70, slow_factor:0, heal_ratio:0,
    cooldown:2.0, spawnAoeRadius:70, aoeBonus:2 },
  { name:"Lancer de Fragment Maudit", type:"projectile", cost:8, power:6, range:240, radius:0, slow_factor:0,
    heal_ratio:0.3, cooldown:2.4, lifeSteal:0.4 },
  { name:"Rayon Perçant du Roi",      type:"projectile", cost:10, power:7, range:320, radius:0, slow_factor:0,
    heal_ratio:0, cooldown:2.5, pierceRadius:80 },

  // --- AOE offensifs ---
  { name:"Bras de Starglaglax",     type:"aoe",        cost:8,  power:4, range:0,   radius:210, slow_factor:0,    heal_ratio:0, cooldown:3.0 },
  { name:"Orage d’Hertegost",      type:"aoe",        cost:9,  power:3, range:0,   radius:260, slow_factor:0,    heal_ratio:0, cooldown:3.5 },
  { name:"Pluie de Fragments",     type:"aoe",        cost:10, power:5, range:0,   radius:230, slow_factor:0,    heal_ratio:0, cooldown:4.0 },
  { name:"Anneau de Vachecapone",  type:"aoe",        cost:9,  power:4, range:0,   radius:220, slow_factor:0.15, heal_ratio:0, cooldown:3.3 },
  { name:"Tempête de Frênesang",   type:"aoe",        cost:9,  power:4, range:0,   radius:230, slow_factor:0.2,  heal_ratio:0, cooldown:3.7 },
  { name:"Rune de Bombes Vivantes", type:"aoe",       cost:10, power:5, range:0,   radius:240, slow_factor:0,    heal_ratio:0, cooldown:4.2 },
  { name:"Crève-Cœur des Démons",  type:"aoe",        cost:11, power:6, range:0,   radius:230, slow_factor:0,    heal_ratio:0, cooldown:4.5 },

  // --- AOE + contrôle ---
  { name:"Cri d’Azar",             type:"slow",       cost:7,  power:0, range:0,   radius:260, slow_factor:0.45, heal_ratio:0, cooldown:3.8 },
  { name:"Brume Maudite",          type:"slow",       cost:6,  power:0, range:0,   radius:240, slow_factor:0.5,  heal_ratio:0, cooldown:3.2 },
  { name:"Gel de Gla-Glace",       type:"slow",       cost:7,  power:0, range:0,   radius:260, slow_factor:0.35, heal_ratio:0, cooldown:3.4 },
  { name:"Entrave de Surville",    type:"slow",       cost:8,  power:0, range:0,   radius:250, slow_factor:0.6,  heal_ratio:0, cooldown:4.0 },
  { name:"Carcan de Triota",       type:"slow",       cost:7,  power:0, range:0,   radius:220, slow_factor:0.4,  heal_ratio:0, cooldown:3.0 },

  // --- Soins / soutien ---
  { name:"Pacte de Kuro",          type:"heal",       cost:7,  power:0, range:0,   radius:0,   slow_factor:0,    heal_ratio:0.55, cooldown:4.5 },
  { name:"Aura de Hertegost",      type:"heal",       cost:9,  power:0, range:0,   radius:0,   slow_factor:0,    heal_ratio:0.75, cooldown:5.5 },
  { name:"Lien des Bêtes",         type:"heal",       cost:8,  power:0, range:0,   radius:0,   slow_factor:0,    heal_ratio:0.6,  cooldown:4.8 },
  { name:"Zèle de Gloria",         type:"heal",       cost:6,  power:0, range:0,   radius:0,   slow_factor:0,    heal_ratio:0.45, cooldown:3.8 },
  { name:"Bénédiction des Fragments", type:"heal",    cost:10, power:0, range:0,   radius:0,   slow_factor:0,    heal_ratio:0.9,  cooldown:6.0 },

  // --- Buff de renvoi (Vachecapone style) ---
  { name:"Magie de Renvoi de Vachecapone", type:"reflect", cost:10, power:0, range:0, radius:0,
    slow_factor:0, heal_ratio:0, cooldown:7.0, buffDuration:3.5 },
  { name:"Bouclier Miroir de Surville",    type:"reflect", cost:9,  power:0, range:0, radius:0,
    slow_factor:0, heal_ratio:0, cooldown:6.5, buffDuration:3.0 },
  { name:"Éclat Réversible",              type:"reflect", cost:8,  power:0, range:0, radius:0,
    slow_factor:0, heal_ratio:0, cooldown:6.0, buffDuration:2.7 },

  // --- Slash façon Railey ---
  { name:"Slash de Railey",        type:"slash",      cost:6,  power:6, range:120, radius:0,
    slow_factor:0, heal_ratio:0, cooldown:2.2, slashAngle:Math.PI/3 },
  { name:"Double Slash Fragmenté", type:"slash",      cost:8,  power:7, range:130, radius:0,
    slow_factor:0, heal_ratio:0.2, cooldown:2.6, slashAngle:Math.PI/2, lifeSteal:0.3 },
  { name:"Tourbillon des Marais",  type:"slash",      cost:9,  power:5, range:140, radius:0,
    slow_factor:0.2, heal_ratio:0, cooldown:3.0, slashAngle:Math.PI*0.75 },
  { name:"Frappe du Méga-Poing",   type:"slash",      cost:10, power:9, range:110, radius:0,
    slow_factor:0.3, heal_ratio:0, cooldown:3.5, slashAngle:Math.PI/2 },

  // --- Slash + élément / contrôle ---
  { name:"Arc de Foudre d’Alara",  type:"slash",      cost:9,  power:7, range:135, radius:0,
    slow_factor:0.4, heal_ratio:0, cooldown:3.2, slashAngle:Math.PI/2 },
  { name:"Tranchant Givré de Hertegost", type:"slash", cost:8, power:6, range:130, radius:0,
    slow_factor:0.45, heal_ratio:0, cooldown:3.0, slashAngle:Math.PI/2 },

  // --- Bonus / utilitaires offensifs ---
  { name:"Volée d’Éclats",         type:"projectile", cost:9,  power:4, range:220, radius:0,
    slow_factor:0, heal_ratio:0, cooldown:2.4, multiProjectiles:3 },
  { name:"Impact du Monstre du Loch", type:"aoe",     cost:11, power:7, range:0,   radius:260,
    slow_factor:0.35, heal_ratio:0, cooldown:4.8 },
  { name:"Souffle du Dragon de Feu", type:"aoe",      cost:12, power:8, range:0,   radius:250,
    slow_factor:0.25, heal_ratio:0, cooldown:5.0 },
  { name:"Corde de Vent de Marc-Jeune", type:"projectile", cost:7, power:4, range:300, radius:0,
    slow_factor:0.3, heal_ratio:0, cooldown:2.0 }
];

const SPELL_COLORS = {};
for(const s of SPELL_DEFS){
  if(s.name.includes("Foudre")) SPELL_COLORS[s.name] = "#64b5f6";
  else if(s.name.includes("Gla-Glace") || s.name.includes("Givré")) SPELL_COLORS[s.name] = "#90caf9";
  else if(s.name.includes("Flamme") || s.name.includes("Feu") || s.name.includes("Cendres")) SPELL_COLORS[s.name] = "#ff8a50";
  else if(s.name.includes("Vachecapone")) SPELL_COLORS[s.name] = "#ffb74d";
  else if(s.name.includes("Starglaglax")) SPELL_COLORS[s.name] = "#d4a5ff";
  else if(s.name.includes("Azar")) SPELL_COLORS[s.name] = "#ffca28";
  else if(s.name.includes("Bombes")) SPELL_COLORS[s.name] = "#ffab91";
  else if(s.name.includes("Hertegost")) SPELL_COLORS[s.name] = "#b2dfdb";
  else if(s.name.includes("Kuro")) SPELL_COLORS[s.name] = "#a5d6a7";
  else if(s.name.includes("Surville")) SPELL_COLORS[s.name] = "#ff5252";
  else if(s.type==="heal") SPELL_COLORS[s.name] = "#c5e1a5";
  else if(s.type==="slow") SPELL_COLORS[s.name] = "#b39ddb";
  else if(s.type==="reflect") SPELL_COLORS[s.name] = "#fff59d";
  else if(s.type==="slash") SPELL_COLORS[s.name] = "#ffe082";
  else SPELL_COLORS[s.name] = "#ffffff";
}

const TOWN_NAMES = [
  "Surville","Kuro","Triota","Eloria","Valpon","Miria","Ormond","Rivendel",
  "Celestia","Silbor","Larion","Brumère","Hertegost","Nerwald","Brisegivre",
  "Fossombre","Rochenoire","Lunebrise","Aubemont","Port-Lumière","Noctefaille",
  "Clairval","Verdelame","Frênesang","Hautecime","Bas-Roc","Coindefer","Gris-Rempart"
];

// ===================== PASSIFS HÉROS =====================

const PASSIVE_DEFS = [
  { id:"blessed", name:"Béni",
    desc:"Regen +, tous les 3 coups soigne une partie des dégâts.",
    regenMult:1.6, hitHealEvery:3, hitHealRatio:0.35 },
  { id:"explosive", name:"Explosif",
    desc:"Tous les 4 coups, explosion AOE qui repousse les démons.",
    explosiveEvery:4, explosiveRadius:130, explosiveKnockback:18 },
  { id:"vampiric", name:"Vampirique",
    desc:"Chaque dégât infligé soigne 15%.",
    lifeSteal:0.15 },
  { id:"tank", name:"Dur à cuire",
    desc:"Beaucoup de PV et d’armure, mais un peu plus lent.",
    hpMult:1.35, defenseBonus:2, speedMult:0.9 },
  { id:"swift", name:"Rapide",
    desc:"Vitesse de déplacement +40%.",
    speedMult:1.4 },
  { id:"fury", name:"Furie",
    desc:"Attaques plus rapides, mais un peu fragile.",
    attackSpeedMult:0.75, hpMult:0.9 },
  { id:"arcane", name:"Canaliseur",
    desc:"Grosse regen de mana, CD des sorts encore réduits.",
    mpRegenMult:1.7, cdMult:0.8 },
  { id:"lucky", name:"Chanceux",
    desc:"+25% d’or trouvé.",
    goldBonus:0.25 },
  { id:"slayer", name:"Tueur de démons",
    desc:"+25% dégâts sur les démons.",
    demonDamageBonus:0.25 },
  { id:"guardian", name:"Gardien",
    desc:"Défense +2, regen PV légèrement augmentée.",
    defenseBonus:2, regenMult:1.2 },
  { id:"fragileSoul", name:"Âme fragile",
    desc:"Beaucoup de dégâts mais peu de PV.",
    attackMult:1.35, hpMult:0.8 },
  { id:"runner", name:"Marcheur des routes",
    desc:"Plus rapide sur routes/plaines.",
    roadSpeedBonus:0.2 },
  { id:"forestChild", name:"Enfant de la forêt",
    desc:"Plus rapide en forêt, légère regen bonus.",
    forestSpeedBonus:0.2, regenMult:1.1 },
  { id:"hunter", name:"Chasseur",
    desc:"+15% dégâts, +10% vitesse.",
    attackMult:1.15, speedMult:1.1 },
  { id:"ironWill", name:"Volonté de fer",
    desc:"PV +20%, regen PV +20%.",
    hpMult:1.2, regenMult:1.2 },
  { id:"manaShield", name:"Bouclier de mana",
    desc:"Un peu de dégâts subis sont payés avec MP (simplifié, pas implémenté complètement).",
    defensiveMp:0.15 },
  { id:"xpBoost", name:"Érudit",
    desc:"+20% d’XP gagnée.",
    xpBonus:0.20 },
  { id:"lootGoblin", name:"Avaricieux",
    desc:"+40% or, -10% PV max.",
    goldBonus:0.4, hpMult:0.9 },
  { id:"regenBeast", name:"Régénérant",
    desc:"Regen PV ++.",
    regenMult:2.0 },
  { id:"mpBattery", name:"Batterie magique",
    desc:"PM max +40%, regen MP +20%.",
    mpMaxMult:1.4, mpRegenMult:1.2 },
  { id:"sturdy", name:"Solide",
    desc:"Défense ++, vitesse --.",
    defenseBonus:3, speedMult:0.85 },
  { id:"berserk", name:"Berserker",
    desc:"PV -, dégâts ++, vitesse ++.",
    hpMult:0.9, attackMult:1.25, speedMult:1.15 },
  { id:"zoneBreaker", name:"Briseur de portails",
    desc:"Dégâts +30% dans les zones/portails.",
    zoneDamageBonus:0.3 },
  { id:"healerTouch", name:"Touché par Kuro",
    desc:"Chaque sort de soin rend un peu plus de PV.",
    healMult:1.3 },
  { id:"critLike", name:"Tranchant caché",
    desc:"Une partie des coups inflige +40% de dégâts (simplifié en +10% dégâts globaux).",
    attackMult:1.1 },
  { id:"featherStep", name:"Pas léger",
    desc:"Vitesse ++ mais défense --.",
    speedMult:1.3, defenseBonus:-1 },
  { id:"stoneHeart", name:"Cœur de pierre",
    desc:"Défense +4 mais dégâts -10%.",
    defenseBonus:4, attackMult:0.9 },
  { id:"blazeSoul", name:"Âme flamboyante",
    desc:"Les AOE infligent +30% de dégâts.",
    aoeDamageBonus:0.3 },
  { id:"spellblade", name:"Lame mystique",
    desc:"Sorts +10% dégâts, slash +10% dégâts.",
    spellDamageBonus:0.1, slashDamageBonus:0.1 },
  { id:"lightEater", name:"Dévoreur de lumière",
    desc:"Chaque monstre tué rend une petite portion de PV.",
    killHealRatio:0.05 }
];

// ===================== UTILITAIRES =====================

function clamp(v, min, max){ return v < min ? min : (v > max ? max : v); }
function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }
function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // --------- PASSIFS COMMUNS (héros + héros de village) ---------

  function applyPassiveOnDamage(ch, dmg, target, game, opts={}){
    if(dmg<=0 || !ch.passive) return;

  // Vol de vie global (passif + sort)
  const spellLifeSteal = opts.spellLifeSteal || 0;
  let totalLifeSteal = (ch.passive.lifeSteal || 0) + spellLifeSteal;
  if(totalLifeSteal>0 && ch.maxHp){
    const heal = Math.max(1, Math.floor(dmg*totalLifeSteal));
    ch.hp = clamp(ch.hp+heal,0,ch.maxHp);
  }

  // Béni : tous les X coups -> soin
  if(ch.passive.hitHealEvery){
    if(ch.passiveHits == null) ch.passiveHits = 0;
    ch.passiveHits++;
    if(ch.passiveHits>=ch.passive.hitHealEvery){
      ch.passiveHits=0;
      const ratio = ch.passive.hitHealRatio || 0.3;
      if(ch.maxHp){
        const heal = Math.max(1, Math.floor(dmg*ratio));
        ch.hp = clamp(ch.hp+heal,0,ch.maxHp);
      }
      }
    }

  // Explosif : tous les X coups -> explosion AOE
  if(ch.passive.explosiveEvery){
    if(ch.passiveSpellHits == null) ch.passiveSpellHits = 0;
    ch.passiveSpellHits++;
    if(ch.passiveSpellHits>=ch.passive.explosiveEvery){
      ch.passiveSpellHits=0;
      const r = ch.passive.explosiveRadius || 120;
      const kb = ch.passive.explosiveKnockback || 16;
      const base = Math.max(1, Math.floor(dmg*0.6));
      for(const m of game.monsters){
        const d2 = dist(ch.x,ch.y,m.x,m.y);
        if(d2<=r){
          m.hp -= base;
          const dx = m.x-ch.x, dy=m.y-ch.y;
          const L=Math.hypot(dx,dy)||1;
          m.x += (dx/L)*kb;
          m.y += (dy/L)*kb;
        }
      }
      game.spawnEffect("aoe",{center:{x:ch.x,y:ch.y},radius:r,color:"#ffcc80"});
    }
  }
}


// --------- DÉGÂTS DE SORTS BASÉS SUR L'ATTAQUE ---------

function getAttackForSpells(caster){
  if(!caster) return 1;
  if(typeof caster.attack === "number") return caster.attack;
  if(typeof caster.baseAttack === "number") return caster.baseAttack;
  return 1;
}

function getDefenseForSpells(target){
  if(!target) return 0;
  if(typeof target.defense === "number") return target.defense;
  if(typeof target.baseDefense === "number") return target.baseDefense;
  return 0;
}

function isDemonTarget(target){
  if(!target) return false;
  if(target.nest) return true;          // démons de nids
  if(target.inDungeon) return true;     // démons de portail
  if(target.biome === "portail") return true;
  return false;
}

/**
 * Dégâts d'un sort :
 * - basé sur l'ATK du lanceur (héros, héros de village, démon)
 * - multiplié par un ratio selon le type de sort
 * - modifié par les passifs
 * - réduit par la DEF de la cible
 */
function computeSpellDamage(caster, target, spell, game, extraMult=1.0){
  if(!caster || !spell) return 0;

  const type = spell.type || "projectile";
  const ratioType = SPELL_ATTACK_RATIO_BY_TYPE[type] || 0;
  const atk = getAttackForSpells(caster);

  // base : ATK * ratio * multiplicateur optionnel (chaîne, multi projectiles, etc.)
  let dmg = atk * ratioType * extraMult;

  const p = caster.passive || null;

  // Passifs qui augmentent les dégâts
  if(p){
    if(p.demonDamageBonus && isDemonTarget(target)){
      dmg *= (1 + p.demonDamageBonus);
    }
    if(p.spellDamageBonus && type === "projectile"){
      dmg *= (1 + p.spellDamageBonus);
    }
    if(p.aoeDamageBonus && type === "aoe"){
      dmg *= (1 + p.aoeDamageBonus);
    }
    if(p.slashDamageBonus && type === "slash"){
      dmg *= (1 + p.slashDamageBonus);
    }
    if(p.zoneDamageBonus && game && game.inZone){
      dmg *= (1 + p.zoneDamageBonus);
    }
  }

  dmg = Math.floor(dmg);

  // Réduction par la DEF de la cible
  const def = getDefenseForSpells(target);
  dmg -= def;

  if(dmg < 1) dmg = 1;
  return dmg;
}

// ===================== HÉROS JOUEUR =====================

class Hero {
  constructor(){
    this.baseName = randChoice(HERO_NAMES);
    this.title = randChoice(HERO_TITLES);
    this.name = this.baseName+" "+this.title;

    this.x = WORLD_WIDTH/2;
    this.y = WORLD_HEIGHT/2;

    this.level = 1;
    this.maxHp = 18;
    this.hp = this.maxHp;

    this.baseAttack = 3;
    this.baseDefense = 1;
    this.baseSpeedStat = 1.0;

    this.inventory = [null,null,null];
    this.backpack = [];
    this.potionsCount = 0;
    this.gold = 0;

    this.maxMp = 20;
    this.mp = this.maxMp;

    this.spell = randChoice(SPELL_DEFS);
    this.spellTimer = 0;
    // Sort spécial de mutation (ultime) lié aux fragments stables
    this.fragmentSpell = null;
    this.fragmentSpellTimer = 0;
    this.fragmentUltimateUnlocked = false;
    this.manaShardsAbsorbed = 0;
    this.fragmentStableCount = 0;
    this.hasMutation = false;
    this.mutationElement = null;


    this.xp = 0;
    this.xpToNext = 12;

    this.attackTimer = 0;

    this.dirX = 1;
    this.dirY = 0;

    this.target = null;

    this.hasVisitedTown = false;
    this.focusZone = null;
    this.reflectTimer = 0;

    this.currentPoi = null;
    this.zoneIdleTime = 0;

    // Regen perso
    this.hpRegenMult = 1.0;
    this.mpRegenMult = 1.0;

    // Passif
    this.passive = randChoice(PASSIVE_DEFS);
    this.passiveHits = 0;
    this.passiveSpellHits = 0;

    // Appliquer les modifs de stats du passif
    if(this.passive.hpMult) this.maxHp = Math.floor(this.maxHp * this.passive.hpMult);
    if(this.passive.attackMult) this.baseAttack = Math.max(1, Math.floor(this.baseAttack * this.passive.attackMult));
    if(this.passive.defenseBonus) this.baseDefense += this.passive.defenseBonus;
    if(this.passive.speedMult) this.baseSpeedStat *= this.passive.speedMult;
    if(this.passive.regenMult) this.hpRegenMult *= this.passive.regenMult;
    if(this.passive.mpMaxMult) this.maxMp = Math.floor(this.maxMp * this.passive.mpMaxMult);
    if(this.passive.mpRegenMult) this.mpRegenMult *= this.passive.mpRegenMult;

    this.hp = this.maxHp;
    this.mp = this.maxMp;
  }

  get equipment(){ return this.inventory.filter(it=>it!==null); }
  get attack(){
    let bonus = this.equipment.reduce((s,it)=>s+(it.attackBonus||0),0);
    return this.baseAttack + bonus;
  }
  get defense(){
    let bonus = this.equipment.reduce((s,it)=>s+Math.min(3,it.defenseBonus||0),0);
    return this.baseDefense + bonus;
  }
  get moveSpeed(){
    let bonus = this.equipment.reduce((s,it)=>s+Math.min(10,it.speedBonus||0),0);
    let base = 120 + this.baseSpeedStat * 3 + bonus;
    if(this.passive && this.passive.roadSpeedBonus) base *= 1.0; // appliqué dans moveMultiplier plutôt
    return base;
  }
  get attackDelay(){
    const base = 0.8 * (this.passive && this.passive.attackSpeedMult ? this.passive.attackSpeedMult : 1.0);
    const refSpeed = 120;
    const s = this.moveSpeed;
    return clamp(base * (refSpeed / s), 0.25, 1.0);
  }

  isAlive(){ return this.hp>0; }

  gainXp(amount){
    if(this.passive && this.passive.xpBonus) amount = Math.floor(amount*(1+this.passive.xpBonus));
    this.xp += amount;
    while(this.xp >= this.xpToNext){
      this.xp -= this.xpToNext;
      this.levelUp();
    }
  }

  levelUp(){
    this.level++;
    this.maxHp += 5;
    this.baseAttack += 1;
    if(this.level % 3 === 0){
      this.baseDefense += 1;
      this.baseSpeedStat += 1; // +1 VIT tous les 3 niveaux
    }
    this.hp = Math.min(this.maxHp, this.hp + Math.floor(this.maxHp*0.4));
    this.xpToNext = Math.floor(this.xpToNext*1.15); // progression XP plus douce
  }

  addToBackpack(item){ this.backpack.push(item); }

  addEquipment(item){
    for(let i=0;i<3;i++){
      if(this.inventory[i] === null){
        this.inventory[i] = item;
        return;
      }
    }
    const score = it => (it.attackBonus||0)+(it.defenseBonus||0)+(it.speedBonus||0);
    let newScore = score(item);
    let worstIdx = null;
    let worstScore = Infinity;
    for(let i=0;i<3;i++){
      let sc = score(this.inventory[i]);
      if(sc < worstScore){
        worstScore = sc;
        worstIdx = i;
      }
    }
    if(worstIdx !== null && newScore > worstScore){
      this.backpack.push(this.inventory[worstIdx]);
      this.inventory[worstIdx] = item;
    } else {
      this.backpack.push(item);
    }
  }

  tryAutoUsePotion(){
    if(this.potionsCount<=0) return;
    if(this.hp >= this.maxHp*0.5) return;
    this.potionsCount--;
    const heal = Math.floor(this.maxHp*POTION_HEAL_RATIO);
    const mana = Math.floor(this.maxMp*POTION_HEAL_RATIO);
    this.hp = clamp(this.hp+heal,0,this.maxHp);
    this.mp = clamp(this.mp+mana,0,this.maxMp);
  }

  // Gestion du passif à chaque dégât infligé
  onDealDamage(dmg, target, game, opts={}){
    applyPassiveOnDamage(this, dmg, target, game, opts);
  }

  
  tryCastSpell(game){
    // Sort ultime des fragments (débloqué après 10 fragments absorbés)
    if(this.fragmentUltimateUnlocked && this.fragmentSpell && this.fragmentSpellTimer<=0){
      const costU = this.fragmentSpell.cost || 14;
      if(this.mp >= costU && game.monsters && game.monsters.length>0){
        const radius = this.fragmentSpell.radius || 260;
        const colorU = this.fragmentSpell.color || SPELL_COLORS[this.fragmentSpell.name] || "#d4a5ff";
        let any=false;
        for(const m of game.monsters){
          if(dist(this.x,this.y,m.x,m.y) <= radius){
            const dmgU = computeSpellDamage(this, m, this.fragmentSpell, game, 1.4);
            m.hp -= dmgU;
            this.onDealDamage(dmgU,m,game,{});
            any=true;
          }
        }
        if(any){
          game.spawnEffect("aoe",{center:{x:this.x,y:this.y},radius,color:colorU});
          this.mp -= costU;
          const cdBaseU = this.fragmentSpell.cooldown || 7.0;
          this.fragmentSpellTimer = cdBaseU * GLOBAL_SPELL_CD_FACTOR;
          return;
        }
      }
    }

    if(!this.spell || this.spellTimer>0) return;
    const cost = this.spell.cost || 5;
    if(this.mp < cost) return;

    const stype = this.spell.type;
    const color = SPELL_COLORS[this.spell.name] || "#ffffff";

    if((stype==="projectile" || stype==="aoe" || stype==="slow" || stype==="slash") && game.monsters.length===0){
      return;
    }

    const cdBase = this.spell.cooldown || 1.5;
    let cd = cdBase * GLOBAL_SPELL_CD_FACTOR;
    if(this.passive && this.passive.cdMult) cd *= this.passive.cdMult;

    // -------- PROJECTILE --------
    if(stype==="projectile"){
      let target = null;
      let bestD = Infinity;
      for(const m of game.monsters){
        const d = dist(this.x,this.y,m.x,m.y);
        if(d < bestD){
          bestD = d;
          target = m;
        }
      }
      if(!target) return;
      const dTo = bestD;
      const range = this.spell.range || 260;
      if(dTo>range) return;

      const m = target;

      // Dégâts principaux : % ATK - DEF du démon
      const dmgMain = computeSpellDamage(this, m, this.spell, game, 1.0);
      m.hp -= dmgMain;
      this.onDealDamage(dmgMain,m,game,{spellLifeSteal:this.spell.lifeSteal||0});

      const dx = m.x - this.x;
      const dy = m.y - this.y;
      const d = Math.hypot(dx,dy) || 1;
      const dirx = dx/d, diry = dy/d;
      m.x += dirx*KNOCKBACK_MONSTER;
      m.y += diry*KNOCKBACK_MONSTER;

      // Chaîne de Foudre, etc.
      if(this.spell.chainRadius && this.spell.chainFactor){
        const cr = this.spell.chainRadius;
        const cf = this.spell.chainFactor;
        let hits = 0;
        for(const other of game.monsters){
          if(other===m) continue;
          if(dist(m.x,m.y,other.x,other.y) <= cr){
            const cdmg = computeSpellDamage(this, other, this.spell, game, cf);
            other.hp -= cdmg;
            this.onDealDamage(cdmg,other,game,{spellLifeSteal:this.spell.lifeSteal||0});
            hits++;
            if(hits>=3) break;
          }
        }
      }

      // Explosion secondaire (Piqûre de Bombes Vivantes, etc.)
      if(this.spell.spawnAoeRadius){
        const r = this.spell.spawnAoeRadius;
        const bonus = this.spell.aoeBonus || 1;
        const mult = 0.5 + 0.1*bonus; // ~50% de l'ATK + un peu selon aoeBonus
        for(const other of game.monsters){
          if(other===m) continue;
          if(dist(m.x,m.y,other.x,other.y) <= r){
            const admg = computeSpellDamage(this, other, this.spell, game, mult);
            other.hp -= admg;
            this.onDealDamage(admg,other,game,{spellLifeSteal:this.spell.lifeSteal||0});
          }
        }
        game.spawnEffect("aoe",{center:{x:m.x,y:m.y},radius:r,color});
      }

      // Volée d’Éclats : projectiles additionnels
      if(this.spell.multiProjectiles){
        for(const other of game.monsters){
          if(other===m) continue;
          if(dist(this.x,this.y,other.x,other.y) <= this.spell.range*0.6){
            const pdmg = computeSpellDamage(this, other, this.spell, game, 0.6);
            other.hp -= pdmg;
            this.onDealDamage(pdmg,other,game,{spellLifeSteal:this.spell.lifeSteal||0});
          }
        }
      }

      game.spawnEffect("projectile",{start:{x:this.x,y:this.y},end:{x:m.x,y:m.y},color});
      this.mp -= cost;
      this.spellTimer = cd;
      return;
    }

    // -------- AOE --------
    if(stype==="aoe"){
      const radius = this.spell.radius || 150;
      let any=false;
      for(const m of game.monsters){
        if(dist(this.x,this.y,m.x,m.y) <= radius){
          const dmg = computeSpellDamage(this, m, this.spell, game, 1.0);
          m.hp -= dmg;
          any=true;
          this.onDealDamage(dmg,m,game,{});
        }
      }
      if(!any) return;
      game.spawnEffect("aoe",{center:{x:this.x,y:this.y},radius,color});
      this.mp -= cost;
      this.spellTimer = cd;
      return;
    }

    // -------- HEAL --------
    if(stype==="heal"){
      if(this.hp >= this.maxHp*0.8) return;
      let ratio = this.spell.heal_ratio || 0.4;
      if(this.passive && this.passive.healMult) ratio *= this.passive.healMult;
      const amount = Math.max(1,Math.floor(this.maxHp*ratio));
      this.hp = clamp(this.hp+amount,0,this.maxHp);
      game.spawnEffect("heal",{center:{x:this.x,y:this.y},color});
      this.mp -= cost;
      this.spellTimer = cd;
      return;
    }

    // -------- SLOW --------
    if(stype==="slow"){
      const radius = this.spell.radius || 200;
      const factor = this.spell.slow_factor || 0.5;
      let affected=false;
      for(const m of game.monsters){
        if(dist(this.x,this.y,m.x,m.y) <= radius){
          m.speed *= factor;
          m.slowed = true;
          affected=true;
        }
      }
      if(!affected) return;
      game.spawnEffect("slow",{center:{x:this.x,y:this.y},radius,color});
      this.mp -= cost;
      this.spellTimer = cd;
      return;
    }

    // -------- REFLECT --------
    if(stype==="reflect"){
      const dur = this.spell.buffDuration || 3.0;
      if(this.reflectTimer > 0.4) return;
      this.reflectTimer = dur;
      game.spawnEffect("reflect",{center:{x:this.x,y:this.y},color});
      this.mp -= cost;
      this.spellTimer = cd;
      return;
    }

    // -------- SLASH --------
    if(stype==="slash"){
      const range = this.spell.range || 120;
      const angle = this.spell.slashAngle || (Math.PI/2);
      const cosMax = Math.cos(angle/2);
      let hitList = [];
      for(const m of game.monsters){
        const dx = m.x - this.x;
        const dy = m.y - this.y;
        const d = Math.hypot(dx,dy);
        if(d > range) continue;
        const ndx = dx/d, ndy = dy/d;
        const dot = ndx*this.dirX + ndy*this.dirY;
        if(dot >= cosMax){
          hitList.push({m, d, ndx, ndy});
        }
      }
      if(hitList.length===0) return;

      for(const h of hitList){
        const dmg = computeSpellDamage(this, h.m, this.spell, game, 1.0);
        h.m.hp -= dmg;
        h.m.x += h.ndx*KNOCKBACK_MONSTER*1.2;
        h.m.y += h.ndy*KNOCKBACK_MONSTER*1.2;
        if(this.spell.slow_factor){
          h.m.speed *= (1-this.spell.slow_factor*0.5);
          h.m.slowed = true;
        }
        this.onDealDamage(dmg,h.m,game,{spellLifeSteal:this.spell.lifeSteal||0});
      }

      game.spawnEffect("slash",{center:{x:this.x,y:this.y},dir:{x:this.dirX,y:this.dirY},range,angle,color});
      this.mp -= cost;
      this.spellTimer = cd;
      return;
    }
  }
  // IA : choisit la cible
  chooseTarget(game){
    const hero = this;

    // Garder une cible monstre existante si encore proche
    if(this.target && this.target.type === "monster"){
      const m = this.target.obj;
      if(game.monsters.includes(m)){
        const d = dist(hero.x,hero.y,m.x,m.y);
        if(d < HERO_AGGRO_RADIUS*1.3){
          return;
        }
      }
    }

    // 1) Démon proche = priorité absolue
    let nearestMonster = null;
    let bestD = Infinity;
    for(const m of game.monsters){
      const d = dist(hero.x,hero.y,m.x,m.y);
      if(d < HERO_AGGRO_RADIUS && d < bestD){
        bestD = d;
        nearestMonster = m;
      }
    }
    if(nearestMonster){
      this.target = {type:"monster",obj:nearestMonster};
      return;
    }

    // 2) Loot proche
    let bestLoot = null;
    let bestLootDist = Infinity;
    for(const g of game.goldItems){
      const d = dist(hero.x,hero.y,g.x,g.y);
      if(d < HERO_LOOT_RADIUS && d < bestLootDist){
        bestLootDist = d;
        bestLoot = {type:"gold",obj:g};
      }
    }
    for(const p of game.potions){
      const d = dist(hero.x,hero.y,p.x,p.y);
      if(d < HERO_LOOT_RADIUS && d < bestLootDist){
        bestLootDist = d;
        bestLoot = {type:"potion",obj:p};
      }
    }
    if(bestLoot){
      this.target = bestLoot;
      return;
    }

    const nearTown = game.currentTown &&
                     dist(hero.x,hero.y,game.currentTown.x,game.currentTown.y) < 80;

    // 3) Pas de quête -> chercher une ville (niveau proche) pour prendre une quête
    if(!game.currentQuest){
      const towns = game.pois.filter(p=>p.type==="town" && !p.isDemonTown);
      if(towns.length>0){
        let bestTown = null;
        let bestScore = Infinity;
        for(const t of towns){
          const lvl = t.level || 1;
          const lvlDelta = Math.abs(lvl - hero.level);
          const d = dist(hero.x,hero.y,t.x,t.y);
          const score = lvlDelta*280 + d;
          if(score < bestScore){
            bestScore = score;
            bestTown = t;
          }
        }
        if(bestTown){
          this.target = {type:"town",obj:bestTown};
          this.currentPoi = bestTown;
          return;
        }
      }
    }

    // 4) Quête active -> préférer zones / forêts de niveau adapté
    if(game.currentQuest){
      const poiTarget = game.currentQuest.area;

      // Si on a une zone liée à la quête -> y aller
      if(poiTarget){
        this.target = {type:poiTarget.type,obj:poiTarget};
        this.currentPoi = poiTarget;
        return;
      }
    }

    // 5) Balade entre POI de niveau proche
    let allPois = game.pois.filter(p=>p.type==="town" || p.type==="forest" || p.type==="zone");

    // Si on est collé à une ville, éviter de la reprendre comme cible
    allPois = allPois.filter(p=>{
      if(p.type!=="town") return true;
      if(nearTown && game.currentTown && p===game.currentTown) return false;
      return true;
    });

    let candidates = allPois.filter(p=>{
      const lvl = p.level || hero.level;
      return lvl >= hero.level && lvl <= hero.level + HERO_POI_LEVEL_MAX_DELTA;
    });
    if(candidates.length===0) candidates = allPois;

    if(candidates.length>0){
      let best=null, bestDist=Infinity;
      for(const p of candidates){
        const d = dist(hero.x,hero.y,p.x,p.y);
        if(d<bestDist){ bestDist=d; best=p; }
      }
      if(best){
        this.target = {type:best.type,obj:best};
        this.currentPoi = best;
        return;
      }
    }

    // Fallback : centre du monde
    this.target = {type:"point",obj:{x:WORLD_WIDTH/2,y:WORLD_HEIGHT/2}};
    this.currentPoi = null;
  }

  // Mouvement avec gestion spéciale pour les portails
  moveTowardsTarget(dt,game){
    if(!this.target) return;
    const obj = this.target.obj;
    const tx=obj.x, ty=obj.y;
    const dx=tx-this.x, dy=ty-this.y;
    const d=Math.hypot(dx,dy);
    if(d<1e-3){ this.dirX=0; this.dirY=0; return;}
    this.dirX=dx/d; this.dirY=dy/d;

    // Ville / forêt : on s’arrête un peu avant
    if((this.target.type==="town" || this.target.type==="forest") && d<40){
      return;
    }

    // Portail : on va quasiment au centre (d<4)
    if(this.target.type==="zone" && d<4){
      return;
    }

    let step=this.moveSpeed*dt;
    const moveMult = game.getMoveMultiplierAt(this.x,this.y,this);
    step *= moveMult;
    if(step>d) step=d;
    this.x += this.dirX*step;
    this.y += this.dirY*step;
    this.x = clamp(this.x,0,WORLD_WIDTH);
    this.y = clamp(this.y,0,WORLD_HEIGHT);
  }

  update(dt,game){
    if(!this.isAlive()) return;

    // Timers
    this.attackTimer = Math.max(0,this.attackTimer-dt);
    this.spellTimer = Math.max(0,this.spellTimer-dt);
    this.reflectTimer = Math.max(0,this.reflectTimer-dt);
    if(this.fragmentSpellTimer != null){
      this.fragmentSpellTimer = Math.max(0,this.fragmentSpellTimer-dt);
    }

    // Regen PV / MP
    this.hp = clamp(this.hp + this.maxHp*BASE_HP_REGEN_RATIO*this.hpRegenMult*dt,0,this.maxHp);
    this.mp = clamp(this.mp + this.maxMp*BASE_MP_REGEN_RATIO*this.mpRegenMult*dt,0,this.maxMp);

    // Potion auto si nécessaire
    this.tryAutoUsePotion();

    // Choix cible + mouvement
    this.chooseTarget(game);
    this.moveTowardsTarget(dt,game);

    // Sort auto
    this.tryCastSpell(game);
  }
}

// ===================== HÉROS DES VILLES =====================


class Vagabond {
  constructor(x,y){
    // Comme le héros principal mais sans quête centrale
    this.name = randChoice(HERO_NAMES)+" le Vagabond";
    this.x = x;
    this.y = y;
    this.level = 1;

    this.maxHp = 20;
    this.hp = this.maxHp;
    this.attack = 4;
    this.defense = 1;
    this.speed = 90;

    this.hpRegenMult = 1.0;

    this.passive = randChoice(PASSIVE_DEFS);
    this.passiveHits = 0;
    this.passiveSpellHits = 0;
    if(this.passive.hpMult) this.maxHp = Math.floor(this.maxHp * this.passive.hpMult);
    if(this.passive.attackMult) this.attack = Math.max(1, Math.floor(this.attack * this.passive.attackMult));
    if(this.passive.defenseBonus) this.defense += this.passive.defenseBonus;
    if(this.passive.speedMult) this.speed *= this.passive.speedMult;
    if(this.passive.regenMult) this.hpRegenMult *= this.passive.regenMult;
    this.hp = this.maxHp;

    this.attackTimer = 0;
    this.attackDelay = clamp(0.9*(120/this.speed),0.3,1.2);

    this.spell = randChoice(SPELL_DEFS);
    this.spellTimer = 0;

    this.state = "wander"; // "wander", "adventurer"
    this.target = null;
    this.patrolTarget = null;

    this.bodyColor = randChoice(["#4cc9f0","#a5d6a7","#ffb74d","#ce93d8"]);
    this.borderColor = "#1d3557";

    this.dead = false;
    this.respawnTimer = 0;

    this.xp = 0;
    this.xpToNext = 12;
  }

  isAlive(){ return !this.dead && this.hp>0; }

  gainXp(amount){
    if(this.dead || amount<=0) return;
    this.xp += amount;
    while(this.xp >= this.xpToNext){
      this.xp -= this.xpToNext;
      this.levelUp();
    }
  }

  levelUp(){
    this.level++;
    this.maxHp += 3;
    this.attack += 1;
    if(this.level % 3 === 0){
      this.defense += 1;
      this.speed += 2;
    }
    this.hp = this.maxHp;
    this.attackDelay = clamp(0.9*(120/this.speed),0.25,1.0);
    this.xpToNext = Math.floor(this.xpToNext*1.15);
  }
}

class VillageHero {
  constructor(town){
    this.town = town;
    this.baseName = randChoice(HERO_NAMES);
    this.title = randChoice(HERO_TITLES);
    this.name = this.baseName+" "+this.title;

    this.x = town.x + (Math.random()*40-20);
    this.y = town.y + (Math.random()*40-20);
    this.level = clamp((town.level||1)+randInt(-1,1),1,99);

    this.maxHp = 14 + this.level*2;
    this.hp = this.maxHp;
    this.attack = 2 + Math.floor(this.level/2);
    this.defense = 1 + Math.floor(this.level/3);
    this.speed = 95 + this.level*3;

    this.hpRegenMult = 1.0;

    // Passif comme le héros
    this.passive = randChoice(PASSIVE_DEFS);
    this.passiveHits = 0;
    this.passiveSpellHits = 0;
    if(this.passive.hpMult) this.maxHp = Math.floor(this.maxHp * this.passive.hpMult);
    if(this.passive.attackMult) this.attack = Math.max(1, Math.floor(this.attack * this.passive.attackMult));
    if(this.passive.defenseBonus) this.defense += this.passive.defenseBonus;
    if(this.passive.speedMult) this.speed *= this.passive.speedMult;
    if(this.passive.regenMult) this.hpRegenMult *= this.passive.regenMult;
    this.hp = this.maxHp;

    this.attackTimer = 0;
    this.attackDelay = clamp(0.9*(120/this.speed),0.3,1.2);

    // Sort : maintenant dans TOUS les sorts possibles
    this.spell = randChoice(SPELL_DEFS);
    this.spellTimer = 0;

    this.state = "patrol";
    this.target = null;
    this.patrolTarget = null;

    this.bodyColor = randChoice(["#4cc9f0","#a5d6a7","#ffb74d","#ce93d8"]);
    this.borderColor = "#1d3557";

    this.dead = false;
    this.respawnTimer = 0;

    this.xp = 0;
    this.xpToNext = 12; // comme le héros
  }

  isAlive(){ return !this.dead; }

  gainXp(amount){
    this.xp += amount;
    while(this.xp >= this.xpToNext){
      this.xp -= this.xpToNext;
      this.levelUp();
    }
  }

  levelUp(){
    this.level++;
    this.maxHp += 5;
    this.hp = this.maxHp;
    this.attack += 1;
    if(this.level % 3 === 0){
      this.defense += 1;
      this.speed += 1; // +1 VIT
    }
    this.attackDelay = clamp(0.9*(120/this.speed),0.25,1.0);
    this.xpToNext = Math.floor(this.xpToNext*1.15);
  }
}

// ===================== SOLDATS D'ALLIANCE =====================

class AllianceSoldier {
  constructor(town){
    this.town = town;
    this.allianceId = town.allianceId;
    this.level = Math.max(1,(town.level||1)-1);

    // Nom aléatoire pour le soldat, lié à sa ville
    this.baseName = randChoice(HERO_NAMES);
    this.name = this.baseName + " de " + town.name;

    // Stats de base
    this.maxHp = 14 + this.level*3;
    this.hp = this.maxHp;
    this.attack = 3 + this.level;
    this.defense = 1 + Math.floor(this.level/3);
    this.speed = 80;

    // Passif comme un héros
    this.hpRegenMult = 1.0;
    this.passive = randChoice(PASSIVE_DEFS);
    this.passiveHits = 0;
    this.passiveSpellHits = 0;
    if(this.passive.hpMult) this.maxHp = Math.floor(this.maxHp * this.passive.hpMult);
    if(this.passive.attackMult) this.attack = Math.max(1, Math.floor(this.attack * this.passive.attackMult));
    if(this.passive.defenseBonus) this.defense += this.passive.defenseBonus;
    if(this.passive.speedMult) this.speed *= this.passive.speedMult;
    if(this.passive.regenMult) this.hpRegenMult *= this.passive.regenMult;
    this.hp = this.maxHp;

    // Attaque de base
    this.attackDelay = clamp(0.9*(120/this.speed),0.35,1.0);
    this.attackTimer = 0;

    // Magie
    this.spell = randChoice(SPELL_DEFS);
    this.spellTimer = 0;

    this.x = town.x + (Math.random()*40-20);
    this.y = town.y + (Math.random()*40-20);

    // Mort définitive : pas de respawn
    this.dead = false;
    this.patrolTarget = null;

    // Expéditions : état et or emporté
    this.state = "defense"; // "defense", "expedition", "return"
    this.expeditionTarget = null;
    this.gold = 0;

    // XP & progression des soldats
    this.xp = 0;
    this.xpToNext = 10 + this.level*2;
  }


  isAlive(){
    return !this.dead && this.hp>0;
  }

  gainXp(amount){
    if(this.dead || amount<=0) return;
    this.xp += amount;
    while(this.xp >= this.xpToNext){
      this.xp -= this.xpToNext;
      this.levelUp();
    }
  }

  levelUp(){
    this.level++;
    // scaling simple mais sensible
    this.maxHp += 4;
    this.attack += 1;
    if(this.level % 3 === 0){
      this.defense += 1;
      this.speed += 2;
    }
    this.hp = this.maxHp;
    this.attackDelay = clamp(0.9*(120/this.speed),0.35,1.0);
    this.xpToNext = Math.floor(this.xpToNext*1.18);
  }
}



// ===================== JEU PRINCIPAL =====================

class Game {
  constructor(canvas){
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");

    this.hero = new Hero();
    this.monsters = [];
    this.goldItems = [];
    this.potions = [];
    this.manaShards = [];
    // Fragments instables & fragments stables pour les mutations
    this.preFragments = [];
    this.stableFragments = [];
    // Commerce
    this.caravans = [];
    this.caravanTimer = 0;
    this.pois = [];
    this.towns = [];
    this.alliances = [];
    this.allianceWars = [];
    this.soldiers = [];

    // Relations entre alliances (valeurs -100..100)
    this.allianceRelations = {};
    this.allianceDiplomacyCooldowns = {};

    // Coalition globale contre les démons (alliances humaines unies)
    this.coalitionActive = false;

    this.roads=[];
    this.rivers=[];
    this.bridges=[];

    this.inZone=false;
    this.currentZone=null;

    this.effects=[];
    this.currentTown=null;

    this.tileCols = Math.ceil(WORLD_WIDTH / TILE_SIZE);
    this.tileRows = Math.ceil(WORLD_HEIGHT / TILE_SIZE);
    this.tileMap = [];

    this.currentQuest = null;
    this.questProgress = 0;

    this.lastTime = performance.now();
    this.lastDeathMsg = "";
    this.lastDeathMsgTimer = 0;

    this.villageHeroes = [];
    this.demonNests = [];

    // Vagabonds : héros errants indépendants
    this.vagabonds = [];

    // Neutres / Shops / Coffres
    this.neutrals = [];
    this.shops = [];
    this.chests = [];
    this.neutralSpawnTimer = 0;
    this.shopSpawnTimer = 0;
    this.chestSpawnTimer = 0;

    // Vagabonds
    this.vagabondSpawnTimer = 0;

    // Event log & ranking
    this.eventLog = [];
    this.maxLogEntries = 10;
    this.heroRanking = [];

    // Timer de portails dynamiques
    this.portalSpawnTimer = 0;
    this.allianceWarTimer = 0;
    this.allianceSummitTimer = 0;

    // Temps du monde (années) : 20s = 1 an
    this.worldTime = 0;      // temps total en secondes
    this.worldYears = 0;     // années écoulées

    this.createPois();
    this.buildTileMap();
    this.spawnVillageHeroes();

    this.logEvent(`Nouveau héros : ${this.hero.name} (Niv ${this.hero.level}).`);
  }

  logEvent(msg){
    this.eventLog.push(msg);
    if(this.eventLog.length>this.maxLogEntries) this.eventLog.shift();
  }

  // ---------- MONDE / POI ----------

  createPois(){
    this.pois=[];
    this.roads=[];
    this.rivers=[];
    this.bridges=[];
    this.demonNests=[];

    const towns=[];
    const minDist=500;
    let tries=0;
    while(towns.length<TOWN_COUNT && tries<500){
      tries++;
      const name=randChoice(TOWN_NAMES);
      const lvl=1+Math.floor(Math.random()*8);
      const x=400+Math.random()*(WORLD_WIDTH-800);
      const y=400+Math.random()*(WORLD_HEIGHT-800);
      let ok=true;
      for(const t of towns){
        if(dist(x,y,t.x,t.y)<minDist){ok=false;break;}
      }
      if(!ok) continue;
      const town={
        type:"town",
        name,
        level:lvl,
        x,y,
        gold:700,
        storedPotions:0,
        maxHp:0,
        hp:0,
        grade:1,
        allianceId:null,
        allianceName:null,
        allianceColor:null,
        isDemonTown:false,
        isDemonCapital:false,
        demonSpawnTimer:0,
        hasDemonOverlord:false,
        soldiers:[],
        tradeFragments:0
      };
      towns.push(town);
      this.pois.push(town);
    }

    // Simple roads entre les villes
    const addRoad = (t1,t2)=>{
      const a=[t1.x,t1.y], b=[t2.x,t2.y];
      for(const rd of this.roads){
        const same1 = rd.ax===a[0] && rd.ay===a[1] && rd.bx===b[0] && rd.by===b[1];
        const same2 = rd.ax===b[0] && rd.ay===b[1] && rd.bx===a[0] && rd.by===a[1];
        if(same1 || same2) return;
      }
      this.roads.push({ax:a[0],ay:a[1],bx:b[0],by:b[1]});
    };

    if(towns.length>=2){
      for(let i=0;i<towns.length;i++){
        let best=null,bestD=Infinity;
        for(let j=0;j<towns.length;j++){
          if(i===j) continue;
          const d=dist(towns[i].x,towns[j].x,towns[i].y,towns[j].y);
        }
      }
      // (bug ci-dessus, on répare:)
      this.roads = [];
      if(towns.length>=2){
        for(let i=0;i<towns.length;i++){
          let best=null,bestD=Infinity;
          for(let j=0;j<towns.length;j++){
            if(i===j) continue;
            const d=dist(towns[i].x,towns[i].y,towns[j].x,towns[j].y);
            if(d<bestD){bestD=d;best=towns[j];}
          }
          if(best) addRoad(towns[i],best);
        }
        const centerTown = towns.reduce((best,t)=>{
          const d=dist(t.x,t.y,WORLD_WIDTH/2,WORLD_HEIGHT/2);
          return (!best || d<best.d)?{t,d}:{t:best.t,d:best.d};
        },null).t;
        for(const t of towns){
          if(t===centerTown) continue;
          addRoad(centerTown,t);
        }
      }
    }

    this.generateRivers();
    this.generateBridges();

    // Forêts
    const forests=[];
    let attempts=0;
    while(forests.length<FOREST_COUNT && attempts<600){
      attempts++;
      const x=200+Math.random()*(WORLD_WIDTH-400);
      const y=200+Math.random()*(WORLD_HEIGHT-400);
      let tooCloseTown=false;
      for(const t of towns){
        if(dist(x,y,t.x,t.y)<250){tooCloseTown=true;break;}
      }
      if(tooCloseTown) continue;
      const forest={type:"forest",x,y};
      forests.push(forest);
      this.pois.push(forest);
      this.demonNests.push({
        x,y,
        level:randInt(1,6),
        portal:false,
        spawnTimer:Math.random()*NEST_SPAWN_INTERVAL
      });
    }

    // Zones / Portails de base
    let zonesCreated=0, triesZ=0;
    while(zonesCreated<ZONE_COUNT && triesZ<400){
      triesZ++;
      if(this.roads.length===0) break;
      const rd = this.roads[Math.floor(Math.random()*this.roads.length)];
      const t=Math.random();
      const rx = rd.ax + (rd.bx-rd.ax)*t;
      const ry = rd.ay + (rd.by-rd.ay)*t;
      const ang = Math.random()*Math.PI*2;
      const dOff = 90+Math.random()*110;
      const zx = rx + Math.cos(ang)*dOff;
      const zy = ry + Math.sin(ang)*dOff;
      let bad=false;
      for(const tw of towns){
        if(dist(zx,zy,tw.x,tw.y)<260){bad=true;break;}
      }
      if(bad) continue;
      for(const rv of this.rivers){
        if(this.distancePointSegment(zx,zy,rv.ax,rv.ay,rv.bx,rv.by)<90){bad=true;break;}
      }
      if(bad) continue;
      const lvl=1+Math.floor(Math.random()*8);
      const zone={type:"zone",level:lvl,x:zx,y:zy,completed:false};
      this.pois.push(zone);
      this.demonNests.push({
        x:zx,y:zy,
        level:lvl,
        portal:true,
        spawnTimer:Math.random()*NEST_SPAWN_INTERVAL
      });
      zonesCreated++;
    }

    // Placement du héros près de la ville la plus centrale (pour le tout premier héros)
    if(towns.length>0){
      const centerTown = towns.reduce((best,t)=>{
        const d=dist(t.x,t.y,WORLD_WIDTH/2,WORLD_HEIGHT/2);
        return (!best || d<best.d)?{t,d}:{t:best.t,d:best.d};
      },null).t;
      this.hero.x = centerTown.x+40;
      this.hero.y = centerTown.y+40;
    }

        // Villes démoniaques initiales : quelques villes sont contrôlées par les démons
    if(towns.length>0){
      const demonCityCount = Math.min(DEMON_CITY_COUNT, towns.length);
      const shuffled = towns.slice().sort(()=>Math.random()-0.5);
      for(let i=0;i<demonCityCount;i++){
        const t = shuffled[i];
        t.isDemonTown = true;
        t.isDemonCapital = true;
        t.demonSpawnTimer = 0;
      }
    }

// Enregistrer la liste des villes et configurer les alliances
    this.towns = towns;
    this.setupAlliances();
  }


  setupAlliances(){
    if(!this.towns || this.towns.length===0){
      this.towns = this.pois.filter(p=>p.type==="town");
    }
    if(!this.towns || this.towns.length===0) return;

    this.alliances = [];
    this.allianceWars = [];

    const usedColors = [];
    const randomAllianceColor = ()=>{
      let c;
      do{
        const r = 100 + Math.floor(Math.random()*155);
        const g = 100 + Math.floor(Math.random()*155);
        const b = 100 + Math.floor(Math.random()*155);
        c = `rgb(${r},${g},${b})`;
      }while(usedColors.includes(c));
      usedColors.push(c);
      return c;
    };

    const allianceCount = Math.min(3,this.towns.length);
    for(let i=0;i<allianceCount;i++){
      const name = ALLIANCE_NAMES[i] || ("Alliance "+(i+1));
      const color = randomAllianceColor();
      const alliance = {
        id:i,
        name,
        color,
        towns:[]
      };
      this.initAlliancePersonality(alliance);
      this.alliances.push(alliance);
    }

    if(this.alliances.length===0) return;

    // Relations initiales entre alliances
    this.initAllianceRelations();

    let idx=0;
    for(const town of this.towns){
      const lvl = town.level || 1;
      if(!town.maxHp || town.maxHp<=0){
        town.maxHp = TOWN_BASE_MAX_HP + lvl*TOWN_HP_PER_LEVEL;
      }
      if(town.hp==null || town.hp<=0){
        town.hp = town.maxHp;
      }
      if(town.gold == null){
        town.gold = 700;
      }
      town.storedPotions = town.storedPotions || 0;
      town.grade = town.grade || 1;
      town.isDemonTown = !!town.isDemonTown;
      town.isDemonCapital = !!town.isDemonCapital;
      if(typeof town.demonSpawnTimer !== "number") town.demonSpawnTimer = 0;
      if(!town.soldiers) town.soldiers = [];

      if(town.isDemonTown){
        // Les villes démoniaques ne font pas partie d'une alliance "humaine"
        town.allianceId = null;
        town.allianceName = null;
        town.allianceColor = null;
        continue;
      }

      const alliance = this.alliances[idx % this.alliances.length];
      town.allianceId = alliance.id;
      town.allianceName = alliance.name;
      town.allianceColor = alliance.color;
      alliance.towns.push(town);
      idx++;
    }
  }



  initAlliancePersonality(alliance){
    if(!alliance || alliance.personality) return;

    // 4 archétypes d'alliance
    const archetype = randInt(1,4);
    let aggression = 50;
    let antiDemon = 50;
    let economy = 50;
    let honor = 50;

    switch(archetype){
      case 1: // Croisade anti-démon
        aggression = randInt(55,85);
        antiDemon = randInt(75,100);
        economy = randInt(35,70);
        honor = randInt(60,95);
        break;
      case 2: // Empire agressif
        aggression = randInt(70,100);
        antiDemon = randInt(45,75);
        economy = randInt(55,90);
        honor = randInt(35,75);
        break;
      case 3: // Ligue marchande
        aggression = randInt(20,55);
        antiDemon = randInt(40,80);
        economy = randInt(70,100);
        honor = randInt(45,85);
        break;
      case 4: // Opportunistes
      default:
        aggression = randInt(45,85);
        antiDemon = randInt(35,75);
        economy = randInt(45,80);
        honor = randInt(20,70);
        break;
    }

    alliance.personality = {
      aggression,
      antiDemon,
      economy,
      honor
    };
  }

  // Initialise les relations entre alliances (valeur neutre +/- petit biais)
  initAllianceRelations(){
    this.allianceRelations = this.allianceRelations || {};
    const alliances = this.alliances || [];
    for(const a of alliances){
      if(!a) continue;
      if(!a.relations) a.relations = {};
      for(const b of alliances){
        if(!b || b.id === a.id) continue;
        if(a.relations[b.id] == null){
          // base neutre, petit biais aléatoire
          a.relations[b.id] = randInt(-20,20);
        }
      }
    }
  }

  getAllianceRelation(aId,bId){
    if(aId==null || bId==null) return 0;
    if(aId===bId) return 50;
    const a = this.getAllianceById(aId);
    if(!a || !a.relations) return 0;
    const v = a.relations[bId];
    if(typeof v !== "number") return 0;
    return v;
  }

  adjustAllianceRelation(aId,bId,delta){
    if(aId==null || bId==null || aId===bId) return;
    const alliances = this.alliances || [];
    const a = this.getAllianceById(aId);
    const b = this.getAllianceById(bId);
    if(!a || !b) return;
    if(!a.relations) a.relations = {};
    if(!b.relations) b.relations = {};
    const clampRel = v => Math.max(-100, Math.min(100, v));

    const oldAB = (typeof a.relations[bId] === "number") ? a.relations[bId] : 0;
    const oldBA = (typeof b.relations[aId] === "number") ? b.relations[aId] : 0;
    a.relations[bId] = clampRel(oldAB + delta);
    b.relations[aId] = clampRel(oldBA + delta);
  }

  getAllianceById(id){
    if(!this.alliances) return null;
    for(const a of this.alliances){
      if(a.id === id) return a;
    }
    return null;
  }

  getEnemyAlliancesFor(allianceId){
    const enemies = [];
    if(allianceId == null) return enemies;

    // En mode coalition, les alliances humaines ne se considèrent plus comme ennemies
    if(this.coalitionActive) return enemies;

    for(const war of this.allianceWars){
      if(!war.active) continue;
      if(war.a === allianceId && !enemies.includes(war.b)) enemies.push(war.b);
      else if(war.b === allianceId && !enemies.includes(war.a)) enemies.push(war.a);
    }
    return enemies;
  }

  areAlliancesAtWar(aId,bId){
    if(aId==null || bId==null) return false;
    if(aId===bId) return false;
    for(const war of this.allianceWars){
      if(!war.active) continue;
      if((war.a===aId && war.b===bId) || (war.a===bId && war.b===aId)) return true;
    }
    return false;
  }

  startAllianceWar(a,b){
    if(!a || !b) return;
    if(a.id === b.id) return;
    if(this.areAlliancesAtWar(a.id,b.id)) return;

    const duration = ALLIANCE_WAR_MIN_DURATION + Math.random()*(ALLIANCE_WAR_MAX_DURATION-ALLIANCE_WAR_MIN_DURATION);
    this.allianceWars.push({
      a:a.id,
      b:b.id,
      remaining:duration,
      active:true,
      frontMomentum:0
    });

    // Une guerre dégrade fortement les relations
    this.adjustAllianceRelation(a.id,b.id,-35);

    this.logEvent(`La guerre éclate entre ${a.name} et ${b.name} !`);
  }

  computeAllianceBattleProfile(allianceId){
    const alliance = this.getAllianceById(allianceId);
    if(!alliance){
      return {attack:1, defense:1, diplomacy:0.5};
    }

    const pers = alliance.personality || {aggression:50,antiDemon:50,economy:50,honor:50};
    const towns = alliance.towns || [];
    const townCount = Math.max(1, towns.length);
    const soldierCount = towns.reduce((sum,t)=>sum + ((t && t.soldiers)?t.soldiers.length:0),0);
    const avgLevel = towns.reduce((sum,t)=>sum + (t && t.level ? t.level : 1),0) / townCount;
    const goldBaseline = 700 * townCount;
    const wealth = typeof alliance.gold === "number" ? alliance.gold : goldBaseline;
    const economyFactor = clamp(wealth / Math.max(1, goldBaseline), 0.65, 1.5);

    const attack = 1 + pers.aggression/120 + soldierCount*0.01 + Math.max(0, avgLevel-1)*0.015;
    const defense = 1 + pers.honor/140 + (townCount-1)*0.05 + avgLevel*0.02 + economyFactor*0.05;
    const diplomacy = clamp((120 - pers.aggression + pers.honor + pers.economy) / 260, 0.25, 1.35);

    return {attack, defense, diplomacy};
  }

  getAlliancePairKey(aId,bId){
    return [Math.min(aId,bId), Math.max(aId,bId)].join("-");
  }

  findNeutralMeetingSpot(){
    const neutralPois = (this.pois||[]).filter(p=>p && p.type!=="town" && !p.isDemonTown);
    if(neutralPois.length===0) return "un carrefour isolé";
    const spot = randChoice(neutralPois);
    if(spot.name) return spot.name;
    switch(spot.type){
      case "forest": return "une clairière";
      case "zone": return "un ancien champ de bataille";
      case "marsh": return "un marais brumeux";
      default: return "un lieu neutre";
    }
  }

  endAllianceWar(aId,bId, reason="La guerre prend fin par une entente fragile."){
    let ended=false;
    for(const war of this.allianceWars){
      if(!war.active) continue;
      if((war.a===aId && war.b===bId) || (war.a===bId && war.b===aId)){
        war.active=false;
        ended=true;
      }
    }
    if(ended){
      this.logEvent(reason);
    }
  }

  refreshWarFront(war, dt){
    if(!war || !war.active) return;
    const profileA = this.computeAllianceBattleProfile(war.a);
    const profileB = this.computeAllianceBattleProfile(war.b);
    const pressureA = profileA.attack / Math.max(0.6, profileB.defense);
    const pressureB = profileB.attack / Math.max(0.6, profileA.defense);
    const delta = (pressureA - pressureB) * dt * 0.05;
    war.frontMomentum = clamp((war.frontMomentum || 0) + delta, -1.5, 1.5);

    // l'usure de la guerre dégrade doucement les relations
    const tension = (pressureA + pressureB) * 0.01 * dt;
    this.adjustAllianceRelation(war.a, war.b, -tension);
  }

  getWarPressure(attackerAllianceId, defenderAllianceId){
    const war = this.allianceWars.find(w=>w.active && ((w.a===attackerAllianceId && w.b===defenderAllianceId) || (w.a===defenderAllianceId && w.b===attackerAllianceId)));
    if(!war) return 1.0;
    const dir = war.a === attackerAllianceId ? 1 : -1;
    const momentum = war.frontMomentum || 0;
    return clamp(1 + dir * momentum * ALLIANCE_ATTACK_PRESSURE_MULT, 0.55, 1.75);
  }

  launchAllianceSummit(a,b){
    if(!a || !b) return;
    const key = this.getAlliancePairKey(a.id,b.id);
    this.allianceDiplomacyCooldowns[key] = this.worldTime + ALLIANCE_WAR_SUMMIT_INTERVAL*0.8;

    const spot = this.findNeutralMeetingSpot();
    this.logEvent(`Les chefs de ${a.name} et ${b.name} se rencontrent en terrain neutre (${spot}) pour négocier.`);

    const profileA = this.computeAllianceBattleProfile(a.id);
    const profileB = this.computeAllianceBattleProfile(b.id);
    const diplomacyScore = (profileA.diplomacy + profileB.diplomacy)/2;
    const relation = this.getAllianceRelation(a.id,b.id);

    const boost = Math.max(6, Math.floor(ALLIANCE_PEACE_RELATION_BOOST * diplomacyScore));
    this.adjustAllianceRelation(a.id,b.id, boost);

    if(this.areAlliancesAtWar(a.id,b.id)){
      const truceChance = ALLIANCE_TRUCE_BASE_CHANCE * diplomacyScore * (relation < 0 ? 1.3 : 1.0);
      if(Math.random() < truceChance){
        this.endAllianceWar(a.id,b.id, `${a.name} et ${b.name} signent une trêve après des pourparlers en terrain neutre.`);
        return;
      }
      this.logEvent("Les discussions échouent, mais une accalmie règne temporairement.");
    } else if(relation < -5 && Math.random() < diplomacyScore){
      this.logEvent(`Un pacte de non-agression est conclu entre ${a.name} et ${b.name}.`);
      this.adjustAllianceRelation(a.id,b.id, randInt(4,9));
    }
  }

  updateCoalitionState(){
    // Compte les villes démoniaques encore actives
    const demonTowns = (this.towns && this.towns.length>0 ? this.towns : this.pois.filter(p=>p.type==="town")).filter(t=>t.isDemonTown);
    const wasActive = this.coalitionActive;
    this.coalitionActive = demonTowns.length >= 1;

    if(this.coalitionActive && !wasActive){
      // Activation : les alliances se tournent vers la menace démoniaque
      this.logEvent("Les alliances humaines forgent une coalition contre les villes démoniaques !");
      // On arrête les guerres en cours entre humains
      for(const war of this.allianceWars){
        war.active = false;
      }
      this.allianceWars = [];

      // La menace démoniaque rapproche un peu les alliances entre elles
      const alliances = this.alliances || [];
      for(let i=0;i<alliances.length;i++){
        const a = alliances[i];
        for(let j=i+1;j<alliances.length;j++){
          const b = alliances[j];
          this.adjustAllianceRelation(a.id,b.id, randInt(5,15));
        }
      }
    } else if(!this.coalitionActive && wasActive){
      this.logEvent("La coalition contre les démons se disperse peu à peu.");
    }
  }


  heroDamageDemonTown(dt){
    const hero = this.hero;
    if(!hero || !this.currentQuest) return;

    const q = this.currentQuest;
    if(q.type !== "rescueTown") return;

    const town = q.area;
    if(!town || !town.isDemonTown) return;

    // Le héros doit être proche de la ville démoniaque
    const d = dist(hero.x, hero.y, town.x, town.y);
    if(d > 65) return;

    // Dégâts de siège basés sur le niveau du héros
    const baseDps = 6 + hero.level*1.2;
    const dmg = baseDps * dt;

    const before = town.hp;
    town.hp = clamp(town.hp - dmg, 0, town.maxHp);

    // Si la ville tombe à 0 PV -> libération + fin de quête
    if(before > 0 && town.hp <= 0){
      const reward = q.reward || 0;
      hero.gold += reward;

      town.isDemonTown = false;
      town.isDemonCapital = false;
      town.hp = town.maxHp || town.hp;

      this.logEvent(
        `Quête accomplie : ${town.name} est libérée par les attaques du héros ! (+${reward} or).`
      );

      this.currentQuest = null;
      this.questProgress = 0;

      // Rebuild du sol / routes si nécessaire
      if(this.buildTileMap) this.buildTileMap();
      // Reconnexion aux alliances si besoin
      if(!town.allianceId && this.alliances && this.alliances.length>0){
        const best = this.alliances[0];
        town.allianceId = best.id;
        town.allianceName = best.name;
        town.allianceColor = best.color;
        best.towns.push(town);
      }
    }
  }


  updateAllianceEconomy(){
    const alliances = this.alliances || [];
    for(const a of alliances){
      if(!a) continue;
      let total = 0;
      if(a.towns){
        for(const t of a.towns){
          if(!t || t.isDemonTown) continue;
          total += (t.gold || 0);
        }
      }
      a.gold = total;
    }
  }

  handleAllianceDiplomacy(dt){
    this.allianceSummitTimer = (this.allianceSummitTimer || 0) + dt;
    if(this.allianceSummitTimer < ALLIANCE_WAR_SUMMIT_INTERVAL) return;
    this.allianceSummitTimer = 0;

    const alliances = (this.alliances || []).filter(a=>a && a.towns && a.towns.length>0);
    if(alliances.length < 2) return;

    let targetA = null;
    let targetB = null;
    let worstRel = 15;
    for(let i=0;i<alliances.length;i++){
      const a = alliances[i];
      for(let j=i+1;j<alliances.length;j++){
        const b = alliances[j];
        const rel = this.getAllianceRelation(a.id,b.id);
        const atWar = this.areAlliancesAtWar(a.id,b.id);
        const priorityScore = atWar ? -150 : rel;
        if(priorityScore < worstRel){
          worstRel = priorityScore;
          targetA = a;
          targetB = b;
        }
      }
    }

    if(!targetA || !targetB) return;

    const key = this.getAlliancePairKey(targetA.id, targetB.id);
    if(this.allianceDiplomacyCooldowns[key] && this.allianceDiplomacyCooldowns[key] > this.worldTime){
      return; // encore sous cooldown diplomatique
    }

    if(Math.random() < ALLIANCE_NEUTRAL_SUMMIT_CHANCE){
      this.launchAllianceSummit(targetA, targetB);
    }
  }

  updateAllianceWars(dt){
      // Met à jour l'état de coalition contre les démons
      this.updateCoalitionState();

    // décrémente les guerres existantes
    for(const war of this.allianceWars){
      if(!war.active) continue;
      this.refreshWarFront(war, dt);
      war.remaining -= dt;
      if(war.remaining <= 0){
        war.active = false;
        const a = this.getAllianceById(war.a);
        const b = this.getAllianceById(war.b);
        if(a && b){
          this.logEvent(`La guerre entre ${a.name} et ${b.name} se termine.`);
          // Fin de guerre : les relations peuvent se réchauffer légèrement
          this.adjustAllianceRelation(a.id,b.id, randInt(5,12));
        }
      }
    }
    this.handleAllianceDiplomacy(dt);
    this.allianceWars = this.allianceWars.filter(w=>w.active);

    // de temps en temps, nouvelle guerre (sauf si coalition active contre les démons)
    this.allianceWarTimer = (this.allianceWarTimer || 0) + dt;
    if(this.allianceWarTimer >= ALLIANCE_WAR_CHECK_INTERVAL){
      this.allianceWarTimer = 0;

      // Met à jour l'économie globale des alliances
      this.updateAllianceEconomy();

      // En mode coalition, on ne déclare plus de nouvelles guerres humaines
      if(this.coalitionActive) return;

      const alliances = this.alliances || [];
      const candidates = alliances.filter(a=>a.towns && a.towns.some(t=>!t.isDemonTown));
      if(candidates.length >= 2){
        // Cherche le couple avec les plus mauvaises relations
        let bestA=null, bestB=null;
        let worstRel = 10; // en dessous de -10, ça commence à sentir la guerre
        for(let i=0;i<candidates.length;i++){
          const a = candidates[i];
          for(let j=i+1;j<candidates.length;j++){
            const b = candidates[j];
            const rel = this.getAllianceRelation(a.id,b.id);
            if(rel < worstRel && !this.areAlliancesAtWar(a.id,b.id)){
              worstRel = rel;
              bestA = a;
              bestB = b;
            }
          }
        }

        if(bestA && bestB){
          const pa = bestA.personality || {aggression:50,antiDemon:50,economy:50,honor:50};
          const pb = bestB.personality || {aggression:50,antiDemon:50,economy:50,honor:50};

          // Score d'envie de guerre basé sur agressivité et mauvaise relation
          const avgAggro = (pa.aggression + pb.aggression) / 2;
          const relFactor = clamp((-worstRel)/60, 0, 2); // plus c'est bas (<0), plus relFactor monte
          let warChance = ALLIANCE_WAR_BASE_CHANCE * (0.5 + avgAggro/100) * (0.5 + relFactor);

          // Alliances très "honorables" déclenchent moins facilement des guerres offensives
          const avgHonor = (pa.honor + pb.honor) / 2;
          warChance *= (1.2 - avgHonor/200); // entre ~0.2 et ~1.2

          // Alliances très tournées vers l'économie préfèrent éviter les guerres coûteuses
          const avgEco = (pa.economy + pb.economy) / 2;
          warChance *= (1.2 - avgEco/250); // réduit un peu la proba pour les ligues marchandes

          if(Math.random() < warChance){
            this.startAllianceWar(bestA,bestB);
          }
        }
      }
    }
  }

  applySiegeDamageOnTown(town, attackerAllianceId, dt, factor=1.0){
    if(!town) return;
    if(town.isDemonTown) return;
    if(attackerAllianceId == null) return;
    if(!this.areAlliancesAtWar(attackerAllianceId, town.allianceId)) return;

    const attackProfile = this.computeAllianceBattleProfile(attackerAllianceId);
    const defenseProfile = this.computeAllianceBattleProfile(town.allianceId);
    const warPressure = this.getWarPressure(attackerAllianceId, town.allianceId);
    const defenseBoost = 1 + ALLIANCE_DEFENSE_BONUS * Math.max(0, defenseProfile.defense);
    const offenseBoost = 1 + ALLIANCE_ATTACK_PRESSURE_MULT * Math.max(0, attackProfile.attack-1);

    const dps = (ALLIANCE_TOWN_SIEGE_DAMAGE * factor * offenseBoost * warPressure) / defenseBoost;
    const dmg = dps * dt;
    town.hp = clamp(town.hp - dmg, 0, town.maxHp);

    if(town.hp <= 0){
      this.captureTownForAlliance(town, attackerAllianceId);
    }
  }

  captureTownForAlliance(town, newAllianceId){
    if(!town || newAllianceId==null) return;
    if(town.isDemonTown) return;

    const oldAlliance = this.getAllianceById(town.allianceId);
    const newAlliance = this.getAllianceById(newAllianceId);

    if(oldAlliance && oldAlliance.towns){
      oldAlliance.towns = oldAlliance.towns.filter(t=>t!==town);
    }
    if(newAlliance){
      if(!newAlliance.towns) newAlliance.towns = [];
      newAlliance.towns.push(town);
      town.allianceId = newAlliance.id;
      town.allianceName = newAlliance.name;
      town.allianceColor = newAlliance.color;
    }

    const currentGold = town.gold || 0;
    const loot = Math.max(ALLIANCE_TOWN_MIN_GOLD_LOOT,
                          Math.floor(currentGold * ALLIANCE_TOWN_PILLAGE_GOLD_RATIO));
    town.gold = Math.max(0, currentGold - loot);
    town.hp = Math.floor(town.maxHp*0.7);

    // Conquête : relations entre l'ancienne et la nouvelle alliance se dégradent fortement
    if(oldAlliance && newAlliance){
      this.adjustAllianceRelation(oldAlliance.id,newAlliance.id,-25);
    }

    const newName = newAlliance ? newAlliance.name : "une alliance inconnue";
    this.logEvent(`${town.name} est conquise par ${newName} ! Or pillé : ${loot}.`);
  }

  generateRivers(){
    this.rivers=[];
    for(let k=0;k<RIVER_COUNT;k++){
      const orientation = Math.random()<0.5?"vertical":"horizontal";
      let points=[];
      if(orientation==="vertical"){
        const x=600+Math.random()*(WORLD_WIDTH-1200);
        const yStart=-200, yEnd=WORLD_HEIGHT+200;
        const segs=3+Math.floor(Math.random()*3);
        for(let i=0;i<=segs;i++){
          const t=i/segs;
          const yy=yStart+(yEnd-yStart)*t;
          const jitter=-150+Math.random()*300;
          const xx=clamp(x+jitter,100,WORLD_WIDTH-100);
          points.push({x:xx,y:yy});
        }
      } else {
        const y=600+Math.random()*(WORLD_HEIGHT-1200);
        const xStart=-200, xEnd=WORLD_WIDTH+200;
        const segs=3+Math.floor(Math.random()*3);
        for(let i=0;i<=segs;i++){
          const t=i/segs;
          const xx=xStart+(xEnd-xStart)*t;
          const jitter=-150+Math.random()*300;
          const yy=clamp(y+jitter,100,WORLD_HEIGHT-100);
          points.push({x:xx,y:yy});
        }
      }
      for(let i=0;i<points.length-1;i++){
        const a=points[i], b=points[i+1];
        this.rivers.push({ax:a.x,ay:a.y,bx:b.x,by:b.y});
      }
    }
  }

  segmentIntersection(ax,ay,bx,by,cx,cy,dx,dy){
    const cross=(vx,vy,wx,wy)=>vx*wy-vy*wx;
    const rx=bx-ax, ry=by-ay;
    const sx=dx-cx, sy=dy-cy;
    const denom = cross(rx,ry,sx,sy);
    if(Math.abs(denom)<1e-6) return null;
    const t = cross(cx-ax,cy-ay,sx,sy)/denom;
    const u = cross(cx-ax,cy-ay,rx,ry)/denom;
    if(t>=0 && t<=1 && u>=0 && u<=1){
      return {x:ax+t*rx,y:ay+t*ry};
    }
    return null;
  }

  generateBridges(){
    this.bridges=[];
    for(const rd of this.roads){
      for(const rv of this.rivers){
        const ip = this.segmentIntersection(rd.ax,rd.ay,rd.bx,rd.by,rv.ax,rv.ay,rv.bx,rv.by);
        if(!ip) continue;
        let tooClose=false;
        for(const br of this.bridges){
          if(dist(ip.x,ip.y,br.x,br.y)<40){tooClose=true;break;}
        }
        if(tooClose) continue;
        this.bridges.push({x:ip.x,y:ip.y});
      }
    }
  }

  distancePointSegment(px,py,ax,ay,bx,by){
    const abx=bx-ax, aby=by-ay;
    const ab2=abx*abx+aby*aby;
    if(ab2===0) return Math.hypot(px-ax,py-ay);
    let t=((px-ax)*abx+(py-ay)*aby)/ab2;
    t=clamp(t,0,1);
    const projx=ax+t*abx, projy=ay+t*aby;
    return Math.hypot(px-projx,py-projy);
  }

  getBiome(x,y){
    for(const rv of this.rivers){
      if(this.distancePointSegment(x,y,rv.ax,rv.ay,rv.bx,rv.by)<80) return "marais";
    }
    for(const p of this.pois){
      if(p.type==="forest" && dist(x,y,p.x,p.y)<280) return "forêt";
    }
    if(y < WORLD_HEIGHT*0.25) return "montagnes";
    if(y > WORLD_HEIGHT*0.75) return "plaines";
    return "collines";
  }

  // ---------- TILEMAP ----------

  buildTileMap(){
    this.tileMap = [];
    for(let gy=0;gy<this.tileRows;gy++){
      const row=[];
      for(let gx=0;gx<this.tileCols;gx++){
        const wx=gx*TILE_SIZE + TILE_SIZE/2;
        const wy=gy*TILE_SIZE + TILE_SIZE/2;

        let tile = TILE.GRASS;
        const biome = this.getBiome(wx,wy);
        if(biome==="forêt") tile = TILE.FOREST;
        else if(biome==="marais") tile = TILE.MARSH;
        else if(biome==="montagnes") tile = TILE.MOUNTAIN;
        else if(biome==="plaines") tile = TILE.PLAINS;
        else tile = TILE.GRASS;

        for(const rv of this.rivers){
          const d=this.distancePointSegment(wx,wy,rv.ax,rv.ay,rv.bx,rv.by);
          if(d<26) tile = TILE.WATER;
          else if(d<70 && tile!==TILE.WATER) tile = TILE.MARSH;
        }

        for(const rd of this.roads){
          const d=this.distancePointSegment(wx,wy,rd.ax,rd.ay,rd.bx,rd.by);
          if(d<22) tile = TILE.ROAD;
        }

        for(const poi of this.pois){
          const d = dist(wx,wy,poi.x,poi.y);
          if(poi.type==="town" && d<40){
            tile = poi.isDemonTown ? TILE.DEMON_CITY : TILE.TOWN;
          }
          if(poi.type==="zone" && d<34) tile = TILE.ZONE;
        }

        row.push(tile);
      }
      this.tileMap.push(row);
    }
  }

  getTileAt(x,y){
    const gx = Math.floor(x / TILE_SIZE);
    const gy = Math.floor(y / TILE_SIZE);
    if(gx<0 || gy<0 || gx>=this.tileCols || gy>=this.tileRows) return TILE.VOID;
    return this.tileMap[gy][gx];
  }

  getMoveMultiplierAt(x,y,hero=null){
    const tile = this.getTileAt(x,y);
    let mult = TILE_MOVE_MULT[tile] || 1.0;
    if(hero && hero.passive){
      if(tile===TILE.ROAD || tile===TILE.PLAINS){
        if(hero.passive.roadSpeedBonus) mult *= (1+hero.passive.roadSpeedBonus);
      }
      if(tile===TILE.FOREST){
        if(hero.passive.forestSpeedBonus) mult *= (1+hero.passive.forestSpeedBonus);
      }
    }
    return mult;
  }

  // ---------- HÉROS DE VILLE ----------

  spawnVillageHeroes(){
    this.villageHeroes = [];
    for(const poi of this.pois){
      if(poi.type!=="town") continue;

      // Si la ville est démoniaque, pas de héros humain : on met un démon surpuissant à la place
      if(poi.isDemonTown){
        if(!poi.hasDemonOverlord){
          this.spawnDemonOverlord(poi);
          poi.hasDemonOverlord = true;
        }
        continue;
      }

      const count = 1 + (Math.random()<0.4 ? 1 : 0);
      for(let i=0;i<count;i++){
        this.villageHeroes.push(new VillageHero(poi));
      }
    }
  }

  spawnTownSoldier(town){
    const soldier = new AllianceSoldier(town);
    this.soldiers.push(soldier);
    if(!town.soldiers) town.soldiers = [];
    town.soldiers.push(soldier);
    return soldier;
  }


  // ---------- NEUTRES ----------

  
  spawnVagabond(){
    // Ne jamais dépasser la limite globale
    if(this.vagabonds && this.vagabonds.length >= VAGABOND_LIMIT) return;

    // Spawn près d'une ville
    const towns = this.pois.filter(p=>p.type==="town");
    if(towns.length===0) return;
    const town = randChoice(towns);

    // une seule règle : pas directement dans une ville humaine ni dans l'eau
    const ang = Math.random()*Math.PI*2;
    const r = 80+Math.random()*140;
    const x = clamp(town.x + Math.cos(ang)*r,0,WORLD_WIDTH);
    const y = clamp(town.y + Math.sin(ang)*r,0,WORLD_HEIGHT);
    const tile = this.getTileAt(x,y);
    if(tile===TILE.WATER || tile===TILE.TOWN || tile===TILE.DEMON_CITY) return;

    const v = new Vagabond(x,y);
    v.state = "vagabond"; // indépendant au départ
    v.allianceId = null;
    v.questsByAlliance = {};
    v.hallAdded = false;
    this.vagabonds.push(v);

    this.logEvent(`Un vagabond apparaît près de ${town.name}.`);
  }

spawnNeutral(){
    let attempts=0;
    while(attempts<40){
      attempts++;
      const x = 200+Math.random()*(WORLD_WIDTH-400);
      const y = 200+Math.random()*(WORLD_HEIGHT-400);
      const tile = this.getTileAt(x,y);
      if(tile===TILE.WATER || tile===TILE.TOWN) continue;
      const type = Math.random()<0.5 ? "vache" : "poule";
      const lvl = randInt(1,4);
      const maxHp = type==="vache" ? 10+lvl*2 : 6+lvl;
      const neutral = {
        x,y,
        type,
        level:lvl,
        maxHp,
        hp:maxHp,
        speed: type==="vache" ? 40 : 60,
        xpValue: type==="vache" ? 3 : 2
      };
      this.neutrals.push(neutral);
      return;
    }
  }

  updateNeutrals(dt){
    for(const n of this.neutrals){
      // regen simple
      n.hp = clamp(n.hp + n.maxHp*NEUTRAL_HP_REGEN_RATIO*dt,0,n.maxHp);

      // IA : fuyant les démons proches
      let closestDemon=null, bestD=Infinity;
      for(const m of this.monsters){
        const d=dist(n.x,n.y,m.x,m.y);
        if(d<bestD){bestD=d;closestDemon=m;}
      }
      let dirx=0, diry=0;
      if(closestDemon && bestD<120){
        // fuit
        dirx = n.x - closestDemon.x;
        diry = n.y - closestDemon.y;
      }else if(Math.random()<0.02){
        // vagabonde aléatoirement
        const ang=Math.random()*Math.PI*2;
        dirx = Math.cos(ang);
        diry = Math.sin(ang);
      }
      const L=Math.hypot(dirx,diry);
      if(L>0){
        dirx/=L; diry/=L;
        let step = n.speed*dt;
        step *= this.getMoveMultiplierAt(n.x,n.y);
        n.x = clamp(n.x+dirx*step,0,WORLD_WIDTH);
        n.y = clamp(n.y+diry*step,0,WORLD_HEIGHT);
      }
    }
  }

  spawnCaravan(){
    const towns = (this.towns && this.towns.length>0 ? this.towns : this.pois.filter(p=>p.type==="town"))
      .filter(t=>!t.isDemonTown);
    if(!towns || towns.length<2) return;

    const sources = towns.filter(t=>{
      const stock = (t.storedPotions||0) + (t.tradeFragments||0);
      return stock>0 || (t.gold||0) > 400;
    });
    if(sources.length===0) return;

    const from = randChoice(sources);
    const possibleTargets = towns.filter(t=>t!==from && !this.areAlliancesAtWar(from.allianceId, t.allianceId));
    if(possibleTargets.length===0) return;
    const to = randChoice(possibleTargets);

    // Marchandises : un mix de potions, fragments et or
    const potions = Math.min(from.storedPotions||0, randInt(0,3));
    from.storedPotions = Math.max(0, (from.storedPotions||0) - potions);

    const fragments = Math.min(from.tradeFragments||0, randInt(0,2));
    from.tradeFragments = Math.max(0, (from.tradeFragments||0) - fragments);

    let tradeGold = Math.min(160, Math.floor((from.gold||0)*0.04));
    from.gold = Math.max(0, (from.gold||0) - tradeGold);

    const value = CARAVAN_BASE_VALUE + tradeGold + potions*CARAVAN_POTION_VALUE + fragments*CARAVAN_FRAGMENT_VALUE;
    if(value<=0 && potions===0 && fragments===0) return;

    const offset = () => Math.random()*18-9;
    this.caravans.push({
      from,
      to,
      x: from.x + offset(),
      y: from.y + offset(),
      speed: 60 + Math.random()*25,
      goods: {potions, fragments, value},
      progress: 0
    });
    this.logEvent(`Une caravane marchande quitte ${from.name} en direction de ${to.name}.`);
  }

  updateCaravans(dt){
    this.caravanTimer += dt;
    if(this.caravanTimer >= CARAVAN_SPAWN_INTERVAL){
      this.caravanTimer = 0;
      this.spawnCaravan();
    }

    const remaining = [];
    for(const c of this.caravans){
      const dx = c.to.x - c.x;
      const dy = c.to.y - c.y;
      const d = Math.hypot(dx,dy);
      if(d<8){
        const g = c.goods||{};
        if(g.value) c.to.gold = (c.to.gold||0) + g.value;
        if(g.potions) c.to.storedPotions = (c.to.storedPotions||0) + g.potions;
        if(g.fragments) c.to.tradeFragments = (c.to.tradeFragments||0) + g.fragments;

        if(c.from && c.to && c.from.allianceId!=null && c.to.allianceId!=null && !this.areAlliancesAtWar(c.from.allianceId,c.to.allianceId)){
          this.adjustAllianceRelation(c.from.allianceId,c.to.allianceId,2);
        }

        const potLabel = g.potions||0;
        const fragLabel = g.fragments||0;
        const valLabel = g.value||0;
        this.logEvent(`Caravane arrivée à ${c.to.name} : ${valLabel} or, ${potLabel} potion(s), ${fragLabel} fragment(s).`);
        continue;
      }

      const step = c.speed*dt;
      const dirx = dx/d, diry = dy/d;
      c.x += dirx*step;
      c.y += diry*step;
      remaining.push(c);
    }
    this.caravans = remaining;
  }

  updateTowns(dt){
    if(!this.towns || this.towns.length===0){
      this.towns = this.pois.filter(p=>p.type==="town");
    }
    if(!this.towns) return;

    for(const town of this.towns){
      const lvl = town.level || 1;
      if(!town.maxHp || town.maxHp<=0){
        town.maxHp = TOWN_BASE_MAX_HP + lvl*TOWN_HP_PER_LEVEL;
      }
      if(town.hp==null || town.hp<=0){
        town.hp = town.maxHp;
      }
      if(town.gold == null){
        town.gold = 700;
      }
      town.storedPotions = town.storedPotions || 0;
      town.tradeFragments = town.tradeFragments || 0;
      town.grade = town.grade || 1;
      town.isDemonTown = !!town.isDemonTown;
      if(!town.soldiers) town.soldiers = [];

      // regen PV de la ville
      const regenFactor = town.isDemonTown ? 0.03 : 0.06;
      town.hp = clamp(town.hp + town.maxHp*regenFactor*dt,0,town.maxHp);

      // dégâts de siège : démons proches attaquent la ville
      let siegeDamage = 0;
      for(const m of this.monsters){
        const d = dist(m.x,m.y,town.x,town.y);
        if(d<120){
          const atk = m.attack || 3;
          siegeDamage += atk*0.35*dt;
        }
      }
      if(siegeDamage>0){
        const before = town.hp;
        town.hp = clamp(town.hp - siegeDamage,0,town.maxHp);
        if(before>0 && town.hp<=0){
          this.onTownDestroyedByDemons(town);
        }
      }

      // Recrutement auto de soldats
      const aliveSoldiers = town.soldiers.filter(s=>s && !s.dead);
      // Limite de base augmentée par le grade de la ville
      const baseLimit = TOWN_SOLDIER_LIMIT + Math.max(0,(town.grade||1)-1);
      // En guerre ou en coalition contre les démons, on peut encore mobiliser davantage
      const enemies = this.getEnemyAlliancesFor(town.allianceId);
      const atWar = enemies.length>0;
      let soldierLimit = baseLimit;
      if(atWar || this.coalitionActive){
        soldierLimit += 2;
      }

      if(!town.isDemonTown &&
         town.gold >= TOWN_SOLDIER_COST &&
         aliveSoldiers.length < soldierLimit){
        town.gold -= TOWN_SOLDIER_COST;
        this.spawnTownSoldier(town);
        this.logEvent(`${town.name} recrute un soldat pour défendre la ville (-${TOWN_SOLDIER_COST} or, limite: ${soldierLimit}).`);
      }

      // Amélioration de grade (respect) si beaucoup d'or
      const GRADE_COST = 500;
      const maxGrade = 5;
      if(!town.isDemonTown && town.gold >= GRADE_COST && (town.grade||1) < maxGrade){
        town.gold -= GRADE_COST;
        town.grade = (town.grade||1) + 1;
        this.logEvent(`${town.name} monte au grade ${town.grade}.`);
      }
    }
  }


  // ---------- LOOT TTL ----------

  updateLoot(dt){
    this.goldItems = this.goldItems.filter(g=>{
      g.ttl -= dt;
      return g.ttl>0;
    });
    this.potions = this.potions.filter(p=>{
      p.ttl -= dt;
      return p.ttl>0;
    });
    if(this.manaShards){
      this.manaShards = this.manaShards.filter(s=>{
        s.ttl -= dt;
        return s.ttl>0;
      });
    }
    if(this.preFragments){
      const remaining = [];
      for(const f of this.preFragments){
        f.ttl -= dt;
        if(f.ttl>0){
          remaining.push(f);
        } else {
          // Mutation : le pré-fragment instable devient une bête magique
          this.spawnFragmentBeast(f.x, f.y, f.element || null);
        }
      }
      this.preFragments = remaining;
    }
  }



  // ---------- LOOP ----------

  step(){
    const now = performance.now();
    let dt = (now - this.lastTime)/1000;
    if(dt>0.1) dt=0.1;
    this.lastTime = now;
    this.update(dt);
    this.draw();
  }

  update(dt){
    const hero=this.hero;
    if(!hero.isAlive()){
      this.handleHeroDeath();
      return;
    }

    // Avancée du temps du monde
    this.worldTime += dt;
    this.worldYears = Math.floor(this.worldTime / YEAR_DURATION);

    // Spawn démons par nid (forêt/zone)
    for(const nest of this.demonNests){
      nest.spawnTimer += dt;
      if(nest.spawnTimer>=NEST_SPAWN_INTERVAL){
        nest.spawnTimer=0;
        const countHere = this.monsters.filter(m=>m.nest===nest && !m.inDungeon).length;

        // Limite différente pour les nids de forêt (plus de démons possibles par forêt)
        let nestLimit = NEST_MONSTER_LIMIT;
        const isForestNest = this.pois.some(p=>p.type==="forest" && dist(p.x,p.y,nest.x,nest.y)<20);
        if(isForestNest){
          nestLimit = FOREST_NEST_MONSTER_LIMIT;
        }

        if(countHere < nestLimit && this.monsters.length < MONSTER_LIMIT){
          this.spawnMonsterAtNest(nest);
        }
      }
    }


    // Spawn démons depuis toutes les villes démoniaques
    if(this.towns && this.towns.length){
      for(const town of this.towns){
        if(!town.isDemonTown) continue;

        // Timer propre à chaque cité démoniaque
        town.demonSpawnTimer = (typeof town.demonSpawnTimer === "number" ? town.demonSpawnTimer : 0) + dt;
        if(town.demonSpawnTimer >= DEMON_CITY_SPAWN_INTERVAL){
          town.demonSpawnTimer = 0;

          // Combien de démons de cette ville sont déjà autour ?
          const around = this.monsters.filter(m=>m.fromDemonCity && !m.dead && dist(m.x,m.y,town.x,town.y) < 260).length;

          // Limite locale élevée : on veut sentir le danger autour de la base
          const baseLimit = 6 + Math.floor((town.level||1)*1.5);
          const localLimit = Math.min(baseLimit, 40);

          if(around < localLimit && this.monsters.length < MONSTER_LIMIT){
            // Petite vague : 1 à 3 démons par tick, sans dépasser la limite locale
            const toSpawn = Math.min(3, localLimit - around);
            for(let i=0;i<toSpawn;i++){
              this.spawnDemonFromDemonCity(town);
            }
          }
        }
      }
    }

    // Spawn neutres
    this.neutralSpawnTimer += dt;
    if(this.neutralSpawnTimer>=NEUTRAL_SPAWN_INTERVAL){
      this.neutralSpawnTimer=0;
      if(this.neutrals.length<NEUTRAL_LIMIT && Math.random()<NEUTRAL_SPAWN_CHANCE){
        this.spawnNeutral();
      }
    }

    // Spawn de vagabonds (très rares)
    this.vagabondSpawnTimer += dt;
    if(this.vagabondSpawnTimer>=VAGABOND_SPAWN_INTERVAL){
      this.vagabondSpawnTimer = 0;
      if(this.vagabonds.length < VAGABOND_LIMIT && Math.random()<0.35){
        this.spawnVagabond();
      }
    }

    // Spawn shops
    this.shopSpawnTimer += dt;
    if(this.shopSpawnTimer>=SHOP_SPAWN_INTERVAL){
      this.shopSpawnTimer=0;
      if(Math.random()<SHOP_SPAWN_CHANCE){
        this.spawnShop();
      }
    }

    // Spawn fragments magiques globaux
    this.manaShardSpawnTimer = (this.manaShardSpawnTimer || 0) + dt;
    if(this.manaShardSpawnTimer >= MANA_SHARD_WORLD_SPAWN_INTERVAL){
      this.manaShardSpawnTimer = 0;
      if(!this.manaShards) this.manaShards = [];
      if(this.manaShards.length < MANA_SHARD_WORLD_LIMIT){
        // spawn près d'une ville humaine aléatoire ou près du héros
        let sx = hero.x, sy = hero.y;
        const humanTowns = (this.towns||[]).filter(t=>!t.isDemonTown);
        if(humanTowns.length>0 && Math.random()<0.7){
          const town = humanTowns[Math.floor(Math.random()*humanTowns.length)];
          const ang = Math.random()*Math.PI*2;
          const d = 40 + Math.random()*80;
          sx = town.x + Math.cos(ang)*d;
          sy = town.y + Math.sin(ang)*d;
        } else {
          const ang = Math.random()*Math.PI*2;
          const d = 60 + Math.random()*120;
          sx = hero.x + Math.cos(ang)*d;
          sy = hero.y + Math.sin(ang)*d;
        }
        // éviter l'eau
        const tile = this.getTileAt(sx,sy);
        if(tile !== TILE.WATER){
          this.manaShards.push({x:sx,y:sy,ttl:MANA_SHARD_TTL});
        }
      }
    }

    // Spawn coffres
    this.chestSpawnTimer += dt;
    if(this.chestSpawnTimer>=CHEST_SPAWN_INTERVAL){
      this.chestSpawnTimer=0;
      if(Math.random()<CHEST_SPAWN_CHANCE){
        this.spawnChest();
      }
    }

    // Portails dynamiques (toutes les 5 min)
    this.portalSpawnTimer += dt;
    if(this.portalSpawnTimer >= PORTAL_RESPAWN_INTERVAL){
      this.portalSpawnTimer = 0;
      this.maybeSpawnRandomPortal();
    }


    // Guerres d'alliances
    this.updateAllianceWars(dt);

    hero.update(dt,this);
    // Le héros peut attaquer directement une ville démoniaque pour une quête de sauvetage
    this.heroDamageDemonTown(dt);
    this.updateVillageHeroes(dt);
    this.updateVagabonds(dt);
    this.updateSoldiers(dt);
    this.updateMonsters(dt);
    this.updateNeutrals(dt);
    this.updateLoot(dt);
    this.updateTowns(dt);
    this.updateCaravans(dt);

    this.checkLootCollisions();
    this.checkTownInteractions();
    this.checkZoneInteractions();
    if(this.inZone) this.updateZoneState();
    this.updateEffects(dt);
    this.checkSpecialInteractions(); // shops + coffres

    // Gestion idle en zone : si dans une zone sans démon ~10s -> change de zone
    if(hero.currentPoi && hero.currentPoi.type==="zone" && !this.inZone){
      const nearMonster = this.monsters.some(m=>dist(hero.x,hero.y,m.x,m.y)<HERO_AGGRO_RADIUS*1.5);
      if(!nearMonster) hero.zoneIdleTime += dt;
      else hero.zoneIdleTime = 0;
      if(hero.zoneIdleTime>10){
        hero.zoneIdleTime = 0;
        hero.currentPoi = null;
        hero.target = null;
      }
    } else {
      hero.zoneIdleTime = 0;
    }

    if(this.lastDeathMsgTimer>0) this.lastDeathMsgTimer-=dt;
  }

  handleHeroDeath(){
    const deadName = this.hero.name;
    const deadLvl = this.hero.level;

    // Ranking
    this.heroRanking.push({name:deadName, level:deadLvl});
    this.heroRanking.sort((a,b)=>b.level-a.level);
    if(this.heroRanking.length>5) this.heroRanking.length=5;

    this.logEvent(`${deadName} est tombé (Niv ${deadLvl}).`);

    this.monsters=[];
    this.goldItems=[];
    this.potions=[];
    this.effects=[];
    this.inZone=false;
    this.currentZone=null;
    this.currentTown=null;
    this.currentQuest=null;
    this.questProgress=0;
    this.neutrals=[];
    this.shops=[];
    this.chests=[];

    this.hero = new Hero();

    // Respawn aléatoire sur la carte (pas forcément proche d'une ville)
    for(let i=0;i<60;i++){
      const rx = randInt(80, WORLD_WIDTH-80);
      const ry = randInt(80, WORLD_HEIGHT-80);
      const tile = this.getTileAt(rx,ry);
      if(tile!==TILE.WATER){
        this.hero.x = rx;
        this.hero.y = ry;
        break;
      }
    }

    this.portalSpawnTimer = 0;

    this.logEvent(`Nouveau héros : ${this.hero.name} (Niv ${this.hero.level}).`);
    this.lastDeathMsg = `${deadName} est tombé (niv ${deadLvl})… Un nouveau héros apparaît !`;
    this.lastDeathMsgTimer = 4;
  }

  onTownDestroyedByDemons(town){
    if(town.isDemonTown) return;

    town.isDemonTown = true;
    town.isDemonCapital = town.isDemonCapital || false;
    if(!town.maxHp || town.maxHp<=0){
      town.maxHp = TOWN_BASE_MAX_HP + (town.level||1)*TOWN_HP_PER_LEVEL;
    }
    town.hp = Math.floor(town.maxHp*0.6);

    this.logEvent(`Les démons ont conquis ${town.name} ! La ville devient une ville démoniaque.`);

    // Supprimer les héros et soldats humains liés à cette ville
    if(this.villageHeroes && this.villageHeroes.length){
      this.villageHeroes = this.villageHeroes.filter(vh => vh.town !== town);
    }
    if(this.soldiers && this.soldiers.length){
      this.soldiers = this.soldiers.filter(s => s.town !== town);
    }
    if(town.soldiers) town.soldiers = [];

    // On rajoute quelques nids de démons autour pour rendre la zone dangereuse
    for(let i=0;i<2;i++){
      const ang = Math.random()*Math.PI*2;
      const d = 60+Math.random()*100;
      const x = clamp(town.x + Math.cos(ang)*d,0,WORLD_WIDTH);
      const y = clamp(town.y + Math.sin(ang)*d,0,WORLD_HEIGHT);
      this.demonNests.push({
        x,y,
        level:(town.level||1)+1,
        portal:false,
        spawnTimer:Math.random()*NEST_SPAWN_INTERVAL
      });
    }

    // Démon surpuissant gardien de la ville
    if(!town.hasDemonOverlord){
      this.spawnDemonOverlord(town);
      town.hasDemonOverlord = true;
    }

    // Met à jour la carte pour afficher la ville démoniaque au sol
    if(this.buildTileMap){
      this.buildTileMap();
    }

    // Quête spéciale immédiate si aucune quête active, réservée aux héros de haut niveau
    if(!this.currentQuest && this.hero && this.hero.level>=20){
      const base = 6 + Math.floor((town.level||1)*1.5);
      const targetCount = base;
      const reward = randInt(QUEST_REWARD_MIN,QUEST_REWARD_MAX) + this.hero.level*15;
      this.currentQuest = {
        type:"rescueTown",
        targetCount,
        reward,
        area:town
      };
      this.questProgress = 0;
      this.logEvent(`Quête : détruire la ville démoniaque ${town.name} pour la libérer.`);
    }
  }


  // ---------- SPAWN DES DÉMONS ----------

  spawnMonsterAtNest(nest){
    let attempts=0, spawnX=null, spawnY=null;
    const towns = this.pois.filter(p=>p.type==="town");

    // On détecte si ce nid est au centre d'une forêt
    const isForestNest = this.pois.some(p=>p.type==="forest" && dist(p.x,p.y,nest.x,nest.y)<20);

    while(attempts<20){
      attempts++;
      const ang=Math.random()*Math.PI*2;
      // En forêt : les démons spawnent au cœur de la zone de forêt
      // En zone/portail : rayon plus large comme avant
      const d = isForestNest ? (5+Math.random()*35) : (80+Math.random()*220);
      const mx = clamp(nest.x + Math.cos(ang)*d,0,WORLD_WIDTH);
      const my = clamp(nest.y + Math.sin(ang)*d,0,WORLD_HEIGHT);
      let tooCloseTown=false;
      for(const t of towns){
        // On évite de spawn trop près des villes humaines, mais pas des cités démoniaques
        if(!t.isDemonTown && dist(mx,my,t.x,t.y)<220){tooCloseTown=true;break;}
      }
      if(tooCloseTown) continue;
      const tile=this.getTileAt(mx,my);
      // On évite l'eau et les villes humaines, mais on autorise les cités démoniaques
      if(tile===TILE.WATER || tile===TILE.TOWN) continue;
      // Pour les nids en forêt : forcer un spawn sur une case de forêt
      if(isForestNest && tile!==TILE.FOREST) continue;
      spawnX=mx; spawnY=my; break;
    }
    if(spawnX===null) return;

    const lvl = clamp(nest.level + randInt(-1,2),1,99);

    let hpBoost=0, atkBoost=0, speedMult=1;
    const localBiome = this.getBiome(spawnX,spawnY);
    if(localBiome==="montagnes"){ hpBoost=3; atkBoost=1; speedMult=0.95; }
    else if(localBiome==="marais"){ hpBoost=2; atkBoost=0; speedMult=0.9; }
    else if(localBiome==="forêt"){ hpBoost=1; atkBoost=0; speedMult=1.05; }

    const roll=Math.random();
    let rarity="common";

    const m={
      x:spawnX,y:spawnY,
      biome:localBiome,
      hp:0,maxHp:0,
      attack:0,defense:0,
      speed:0,
      attackTimer:0,
      level:lvl,
      elite:false,
      champion:false,
      slowed:false,
      spell:null,
      spellTimer:0,
      wanderTarget:null,
      name:"Démon mineur",
      special:false,
      nest:nest,
      inDungeon:false,
      portalZone:null,
      xp:0,
      xpToNext:null
    };

    if(roll<0.04){
      const maxHp=14+lvl+6+hpBoost;
      m.maxHp=maxHp;m.hp=maxHp;
      m.attack=4+Math.floor(lvl/2)+atkBoost;
      m.defense=2+Math.floor(lvl/3);
      m.speed=(65+Math.random()*30)*speedMult;
      m.elite=true;m.champion=true;
      m.name=randChoice(["Démon majeur","Démon du Fragment","Démon exalté"]);
      rarity="champion";
    }else if(roll<0.09){
      const maxHp=10+lvl+Math.floor(Math.random()*4)+hpBoost;
      m.maxHp=maxHp;m.hp=maxHp;
      m.attack=3+Math.floor(lvl/2)+atkBoost;
      m.defense=1+Math.floor(lvl/3);
      m.speed=(70+Math.random()*30)*speedMult;
      m.elite=true;m.champion=false;
      m.name=randChoice(["Démon élite","Démon des ruines","Démon sanguinaire"]);
      rarity="elite";
    }else{
      const maxHp=6+lvl+Math.floor(Math.random()*3)+hpBoost;
      m.maxHp=maxHp;m.hp=maxHp;
      m.attack=2+Math.floor(lvl/2)+atkBoost;
      m.defense=0+Math.floor(lvl/4);
      m.speed=(60+Math.random()*40)*speedMult;
      m.elite=false;m.champion=false;
      m.name=randChoice(["Démon mineur","Démon rôdeur","Démon errant"]);
      rarity="common";
    }

    if(lvl>=10){
      const demonSpells = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
      m.spell = randChoice(demonSpells);
      m.spellTimer = 0;
    }

    // Spécial depuis portail (uniquement pour les nids de zone)
    if(nest.portal && Math.random() < 0.08){
      m.special = true;
      m.elite = true;
      m.champion = true;
      m.name = randChoice(SPECIAL_DEMON_NAMES);
      m.maxHp = Math.floor(m.maxHp * 2.4);
      m.hp = m.maxHp;
      m.attack += 3;
      m.defense += 5;
      m.speed *= 1.08;
      const offensiveSpells = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
      m.spell = randChoice(offensiveSpells);
      m.spellTimer = 0;
      rarity = "special";
    }


    // Seigneur démon ultra rare
    if(!m.special && Math.random() < DEMON_LORD_CHANCE && lvl >= 8){
      m.isDemonLord = true;
      m.special = true;
      m.elite = true;
      m.champion = true;
      m.name = "Seigneur Démon";
      m.maxHp = Math.floor(m.maxHp * DEMON_LORD_HP_MULT);
      m.hp = m.maxHp;
      m.attack = Math.floor(m.attack * DEMON_LORD_ATTACK_MULT);
      m.defense = Math.floor(m.defense * DEMON_LORD_DEFENSE_MULT);
      rarity = "special";
    }

    m.rarity = rarity;
    this.monsters.push(m);
  }


  spawnDemonFromDemonCity(town){
    let attempts=0, spawnX=null, spawnY=null;
    const towns = this.towns && this.towns.length ? this.towns : this.pois.filter(p=>p.type==="town");

    while(attempts<25){
      attempts++;
      const ang = Math.random()*Math.PI*2;
      // 0 à 200 pour pouvoir spawn dans et autour de la ville démoniaque
      const d = Math.random()*200;
      const mx = clamp(town.x + Math.cos(ang)*d,0,WORLD_WIDTH);
      const my = clamp(town.y + Math.sin(ang)*d,0,WORLD_HEIGHT);

      // éviter les autres villes trop proches (mais pas la sienne)
      let tooCloseOtherTown=false;
      for(const t of towns){
        if(t===town) continue;
        if(dist(mx,my,t.x,t.y)<200){ tooCloseOtherTown=true; break; }
      }
      if(tooCloseOtherTown) continue;

      const tile = this.getTileAt(mx,my);
      // On évite toujours l'eau
      if(tile===TILE.WATER) continue;
      // On évite les villes humaines, mais on autorise la ville démoniaque elle-même
      if(tile===TILE.TOWN && !town.isDemonTown) continue;

      spawnX = mx;
      spawnY = my;
      break;
    }
    if(spawnX===null) return;

    const baseLvl = town.level || 1;
    const lvl = clamp(baseLvl + randInt(0,2),1,99);

    let hpBoost=0, atkBoost=0, speedMult=1;
    const localBiome = this.getBiome(spawnX,spawnY);
    if(localBiome==="montagnes"){ hpBoost=3; atkBoost=1; speedMult=0.95; }
    else if(localBiome==="marais"){ hpBoost=2; atkBoost=0; speedMult=0.9; }
    else if(localBiome==="forêt"){ hpBoost=1; atkBoost=0; speedMult=1.05; }

    const roll=Math.random();
    let rarity="common";

    const m={
      x:spawnX,y:spawnY,
      biome:localBiome,
      hp:0,maxHp:0,
      attack:0,defense:0,
      speed:0,
      attackTimer:0,
      level:lvl,
      elite:false,
      champion:false,
      slowed:false,
      spell:null,
      spellTimer:0,
      wanderTarget:null,
      name:"Démon de cité",
      special:false,
      nest:null,
      inDungeon:false,
      portalZone:null,
      xp:0,
      xpToNext:null,
      fromDemonCity:true
    };

    if(roll<0.04){
      const maxHp=14+lvl+6+hpBoost;
      m.maxHp=maxHp;m.hp=maxHp;
      m.attack=4+Math.floor(lvl/2)+atkBoost;
      m.defense=2+Math.floor(lvl/3);
      m.speed=(65+Math.random()*30)*speedMult;
      m.elite=true;m.champion=true;
      m.name=randChoice(["Garde infernal","Champion démoniaque","Exécuteur du feu"]);
      rarity="champion";
    }else if(roll<0.10){
      const maxHp=10+lvl+Math.floor(Math.random()*4)+hpBoost;
      m.maxHp=maxHp;m.hp=maxHp;
      m.attack=3+Math.floor(lvl/2)+atkBoost;
      m.defense=1+Math.floor(lvl/3);
      m.speed=(70+Math.random()*30)*speedMult;
      m.elite=true;m.champion=false;
      m.name=randChoice(["Légionnaire démon","Chevalier maudit","Guerrier abyssal"]);
      rarity="elite";
    }else{
      const maxHp=6+lvl+Math.floor(Math.random()*3)+hpBoost;
      m.maxHp=maxHp;m.hp=maxHp;
      m.attack=2+Math.floor(lvl/2)+atkBoost;
      m.defense=0+Math.floor(lvl/4);
      m.speed=(60+Math.random()*40)*speedMult;
      m.elite=false;m.champion=false;
      m.name=randChoice(["Démon de garnison","Démon patrouilleur","Démon sentinelle"]);
      rarity="common";
    }

    if(lvl>=10){
      const demonSpells = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
      m.spell = randChoice(demonSpells);
      m.spellTimer = 0;
    }

    // Chance accrue de Seigneur démon autour des cités démoniaques
    if(!m.special && Math.random() < DEMON_LORD_CHANCE*2 && lvl>=10){
      m.isDemonLord = true;
      m.special = true;
      m.elite = true;
      m.champion = true;
      m.name = "Seigneur Démon";
      m.maxHp = Math.floor(m.maxHp * DEMON_LORD_HP_MULT);
      m.hp = m.maxHp;
      m.attack = Math.floor(m.attack * DEMON_LORD_ATTACK_MULT);
      m.defense = Math.floor(m.defense * DEMON_LORD_DEFENSE_MULT);
      rarity = "special";
    }

    m.rarity = rarity;
    this.monsters.push(m);
  }



  spawnFragmentBeast(x,y,element){
    // Bête magique née d'un fragment instable : mini-boss agressif
    const hero = this.hero;
    const baseLevel = hero ? Math.max(5, hero.level) : 5;
    const lvl = clamp(baseLevel + randInt(-1,2), 3, 99);
    const biome = this.getBiome(x,y);
    const m = {
      x:x,
      y:y,
      biome,
      hp:0,maxHp:0,
      attack:0,defense:0,
      speed:0,
      attackTimer:0,
      level:lvl,
      elite:true,
      champion:true,
      slowed:false,
      spell:null,
      spellTimer:0,
      wanderTarget:null,
      name:"Bête magique",
      special:true,
      nest:null,
      inDungeon:false,
      portalZone:null,
      xp:0,
      xpToNext:null,
      fromFragment:true,
      fragmentElement: element || null,
      isFragmentBeast:true
    };

    // Stats : un peu au-dessus d'un démon élite normal
    const maxHp = 18 + lvl*2;
    m.maxHp = maxHp;
    m.hp = maxHp;
    m.attack = 4 + Math.floor(lvl*0.8);
    m.defense = 2 + Math.floor(lvl/3);
    m.speed = 65 + lvl*1.5;

    // Donne toujours un sort offensif
    const offensive = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
    if(offensive.length>0){
      m.spell = randChoice(offensive);
      m.spellTimer = 0;
    }

    this.monsters.push(m);
    this.logEvent("Un pré-fragment instable mute en bête magique !");
  }

  spawnDemonOverlord(town){
    const lvl = Math.max((town.level||1)+3, 5);
    const biome = this.getBiome(town.x,town.y);
    const m = {
      x:town.x,
      y:town.y,
      biome,
      hp:0,maxHp:0,
      attack:0,defense:0,
      speed:70,
      attackTimer:0,
      level:lvl,
      elite:true,
      champion:true,
      slowed:false,
      spell:null,
      spellTimer:0,
      wanderTarget:null,
      name:"Seigneur Démon",
      special:true,
      nest:null,
      inDungeon:false,
      portalZone:null,
      xp:0,
      xpToNext:null,
      isDemonLord:true,
      fromDemonCity:true,
      guardianTown:town
    };

    const baseHp = 10 + lvl*2;
    const baseAtk = 3 + Math.floor(lvl*0.75);
    const baseDef = 1 + Math.floor(lvl/3);

    m.maxHp = Math.floor(baseHp * DEMON_LORD_HP_MULT);
    m.hp = m.maxHp;
    m.attack = Math.floor(baseAtk * DEMON_LORD_ATTACK_MULT);
    m.defense = Math.floor(baseDef * DEMON_LORD_DEFENSE_MULT);

    const demonSpells = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
    if(demonSpells.length>0){
      m.spell = randChoice(demonSpells);
      m.spellTimer = 0;
    }

    m.rarity = "special";
    this.monsters.push(m);
  }

  getMonsterRarity(m){
    if(m.isDemonLord) return "special";
    if(m.special) return "special";
    if(m.champion) return "champion";
    if(m.elite) return "elite";
    return "common";
  }

  // --------- PORTAILS DYNAMIQUES ---------

  getActivePortals(){
    return this.pois.filter(p=>p.type==="zone" && !p.completed);
  }

  spawnRandomPortal(desiredLevel=null){
    let attempts=0;
    const baseLevel = desiredLevel || randInt(1,8);
    while(attempts<300){
      attempts++;
      const x = randInt(200,WORLD_WIDTH-200);
      const y = randInt(200,WORLD_HEIGHT-200);
      const tile = this.getTileAt(x,y);
      if(tile===TILE.WATER || tile===TILE.TOWN || tile===TILE.DEMON_CITY) continue;

      // éviter les villes
      let tooCloseTown=false;
      for(const t of this.pois){
        if(t.type==="town" && dist(x,y,t.x,t.y)<220){tooCloseTown=true;break;}
      }
      if(tooCloseTown) continue;

      // éviter les autres portails trop proches
      let tooCloseZone=false;
      for(const z of this.pois){
        if(z.type==="zone" && !z.completed && dist(x,y,z.x,z.y)<260){tooCloseZone=true;break;}
      }
      if(tooCloseZone) continue;

      const lvl = clamp(baseLevel + randInt(-1,1),1,99);
      const zone={type:"zone",level:lvl,x,y,completed:false,isDynamic:true};
      this.pois.push(zone);
      this.demonNests.push({
        x,y,
        level:lvl,
        portal:true,
        spawnTimer:Math.random()*NEST_SPAWN_INTERVAL
      });
      this.buildTileMap();
      this.logEvent(`Un nouveau portail démoniaque Lv ${lvl} apparaît quelque part dans le monde.`);
      return zone;
    }
    return null;
  }

  maybeSpawnRandomPortal(){
    const hero=this.hero;
    const activePortals = this.getActivePortals();

    // Si le héros est haut niveau et qu'il n'y a aucun portail -> en créer un pour lui
    if(hero.level >= PORTAL_MIN_LEVEL_FOR_AUTO && activePortals.length===0){
      const targetLvl = Math.max(1, hero.level - randInt(0,2)); // Niv héros, ou -1/-2
      this.spawnRandomPortal(targetLvl);
      return;
    }

    // Sinon, petite chance de spawn (mais pas trop de portails simultanés)
    if(activePortals.length >= 4) return;
    if(Math.random()<0.5){
      const baseLvl = clamp(hero.level + randInt(-3,2),1,99);
      this.spawnRandomPortal(baseLvl);
    }
  }

  // ---------- IA HÉROS DE VILLAGE ----------

  
  
  updateVagabonds(dt){
    if(!this.vagabonds || this.vagabonds.length===0) return;
    const remaining=[];
    for(const v of this.vagabonds){
      if(!v || v.dead || v.hp<=0){
        if(v) v.dead = true;
        continue;
      }

      remaining.push(v);

      // Timers d'attaque / sort
      v.attackTimer = Math.max(0, v.attackTimer-dt);
      v.spellTimer = Math.max(0, v.spellTimer-dt);

      // Régénération lente (comme un héros de village)
      const regenMult = v.hpRegenMult || 1.0;
      v.hp = clamp(v.hp + v.maxHp*VILLAGE_HP_REGEN_RATIO*regenMult*dt,0,v.maxHp);

      const allianceId = (v.allianceId!=null ? v.allianceId : null);
      const enemyAlliances = allianceId!=null ? this.getEnemyAlliancesFor(allianceId) : [];

      // 1) Priorité : démons proches
      let bestMonster=null;
      for(const m of this.monsters){
        const d = dist(v.x,v.y,m.x,m.y);
        if(d>260) continue;
        if(!bestMonster || d<bestMonster.d) bestMonster={m,d};
      }

      // 2) Ensuite, unités ennemies si guerre active et le vagabond a une alliance
      let bestEnemyUnit=null;
      if(!bestMonster && allianceId!=null && enemyAlliances.length>0){
        for(const s of this.soldiers){
          if(!s.isAlive || !s.isAlive()) continue;
          if(!enemyAlliances.includes(s.allianceId)) continue;
          const d = dist(v.x,v.y,s.x,s.y);
          if(d>260) continue;
          if(!bestEnemyUnit || d<bestEnemyUnit.d) bestEnemyUnit={u:s,d};
        }
        for(const vh of this.villageHeroes){
          if(!vh || vh.dead) continue;
          if(!vh.town || vh.town.isDemonTown) continue;
          if(!enemyAlliances.includes(vh.town.allianceId)) continue;
          const d = dist(v.x,v.y,vh.x,vh.y);
          if(d>260) continue;
          if(!bestEnemyUnit || d<bestEnemyUnit.d) bestEnemyUnit={u:vh,d};
        }
      }

      // 3) Enfin, ville ennemie proche -> siège (si alliance)
      let siegeTown=null;
      if(!bestMonster && !bestEnemyUnit && allianceId!=null && enemyAlliances.length>0){
        for(const t of this.towns){
          if(t.isDemonTown) continue;
          if(!enemyAlliances.includes(t.allianceId)) continue;
          const d = dist(v.x,v.y,t.x,t.y);
          if(d>260) continue;
          if(!siegeTown || d<siegeTown.d) siegeTown={town:t,d};
        }
      }

      if(bestMonster){
        const target = bestMonster.m;
        const dx = target.x - v.x;
        const dy = target.y - v.y;
        const d = Math.hypot(dx,dy)||1;
        const dirx = dx/d, diry = dy/d;

        // Déplacement vers le démon
        if(d>32){
          let step = v.speed*dt;
          step *= this.getMoveMultiplierAt(v.x,v.y);
          if(step>d) step=d;
          v.x += dirx*step;
          v.y += diry*step;
        }

        // Sort (projectile)
        if(v.spell && v.spellTimer<=0 && d<(v.spell.range||220) && v.spell.type==="projectile"){
          const color = SPELL_COLORS[v.spell.name] || "#ffffff";
          const dmg = computeSpellDamage(v, target, v.spell, this, 1.0);
          target.hp -= dmg;
          target.x += dirx*KNOCKBACK_MONSTER;
          target.y += diry*KNOCKBACK_MONSTER;
          this.spawnEffect("projectile",{start:{x:v.x,y:v.y},end:{x:target.x,y:target.y},color});
          v.spellTimer = (v.spell.cooldown || 2.0)*GLOBAL_SPELL_CD_FACTOR;
          applyPassiveOnDamage(v, dmg, target, this, {spellLifeSteal: v.spell.lifeSteal || 0});
        }

        // Attaque de mêlée
        if(d<34 && v.attackTimer<=0){
          const dmg = Math.max(1, v.attack - (target.defense||0));
          target.hp -= dmg;
          v.attackTimer = v.attackDelay;

          target.x += dirx*KNOCKBACK_MONSTER;
          target.y += diry*KNOCKBACK_MONSTER;
          v.x -= dirx*KNOCKBACK_SELF;
          v.y -= diry*KNOCKBACK_SELF;

          applyPassiveOnDamage(v, dmg, target, this, {});
        }

      } else if(bestEnemyUnit){
        const target = bestEnemyUnit.u;
        const dx = target.x - v.x;
        const dy = target.y - v.y;
        const d = Math.hypot(dx,dy)||1;
        const dirx = dx/d, diry = dy/d;

        if(d>32){
          let step = v.speed*dt;
          step *= this.getMoveMultiplierAt(v.x,v.y);
          if(step>d) step=d;
          v.x += dirx*step;
          v.y += diry*step;
        }

        if(v.spell && v.spellTimer<=0 && d<(v.spell.range||220) && v.spell.type==="projectile"){
          const color = SPELL_COLORS[v.spell.name] || "#ffffff";
          const dmg = computeSpellDamage(v, target, v.spell, this, 1.0);
          target.hp -= dmg;
          this.spawnEffect("projectile",{start:{x:v.x,y:v.y},end:{x:target.x,y:target.y},color});
          v.spellTimer = (v.spell.cooldown || 2.0)*GLOBAL_SPELL_CD_FACTOR;
          applyPassiveOnDamage(v, dmg, target, this, {spellLifeSteal: v.spell.lifeSteal || 0});
        }

        if(d<34 && v.attackTimer<=0){
          const raw = v.attack - (target.defense||0);
          const dmg = Math.max(1, raw);
          target.hp -= dmg;
          v.attackTimer = v.attackDelay;

          target.x += dirx*KNOCKBACK_MONSTER;
          target.y += diry*KNOCKBACK_MONSTER;
          v.x -= dirx*KNOCKBACK_SELF;
          v.y -= diry*KNOCKBACK_SELF;

          applyPassiveOnDamage(v, dmg, target, this, {});
        }

      } else if(siegeTown){
        const t = siegeTown.town;
        const dx = t.x - v.x;
        const dy = t.y - v.y;
        const d = Math.hypot(dx,dy)||1;
        const dirx = dx/d, diry = dy/d;

        if(d>40){
          let step = v.speed*dt*0.8;
          step *= this.getMoveMultiplierAt(v.x,v.y);
          if(step>d) step=d;
          v.x += dirx*step;
          v.y += diry*step;
        } else {
          if(allianceId!=null){
            this.applySiegeDamageOnTown(t, allianceId, dt, 1.0);
          }
        }

      } else {
        // Pas de combat prioritaire -> comportement d'exploration / missions pour alliances

        // Choix d'une cible (ville ou forêt) si pas déjà de destination
        if(!v.target || Math.random()<0.002){
          const choices = this.pois.filter(p=>p.type==="town" || p.type==="forest");
          if(choices.length>0){
            v.target = randChoice(choices);
          } else {
            v.target = null;
          }
        }

        if(v.target){
          const tx = v.target.x;
          const ty = v.target.y;
          const dx = tx - v.x;
          const dy = ty - v.y;
          const d = Math.hypot(dx,dy)||1;
          const dirx = dx/d, diry = dy/d;

          if(d>18){
            let step = v.speed*dt;
            step *= this.getMoveMultiplierAt(v.x,v.y);
            if(step>d) step=d;
            v.x += dirx*step;
            v.y += diry*step;
          } else {
            // Arrivé près d'une ville : possibilité de "faire une quête" pour son alliance
            if(v.target.type==="town" && v.target.allianceId!=null){
              const aid = v.target.allianceId;
              if(!v.questsByAlliance) v.questsByAlliance={};
              if(Math.random()<0.25){
                v.questsByAlliance[aid] = (v.questsByAlliance[aid]||0) + 1;
                const qCount = v.questsByAlliance[aid];
                this.logEvent(`${v.name} accomplit une mission pour l'alliance de ${v.target.name} (total ${qCount}).`);
                // S'il dépasse 3 quêtes pour cette alliance, il la rejoint
                if(qCount>=3 && !v.allianceId){
                  v.allianceId = aid;
                  v.state = "adventurer"; // aventurier lié à une alliance
                  this.logEvent(`${v.name} rejoint l'alliance de ${v.target.name} après de nombreuses quêtes.`);
                }
              }
            }
            v.target = null;
          }
        }
      }

      // Ajout au Hall des héros si niveau 10+ et pas encore dans le Hall
      if(v.level>=10 && !v.hallAdded){
        this.heroRanking.push({name:v.name, level:v.level});
        this.heroRanking.sort((a,b)=>b.level-a.level);
        if(this.heroRanking.length>5) this.heroRanking.length=5;
        v.hallAdded = true;
        this.logEvent(`${v.name} entre au Hall des héros en tant qu'aventurier de Niv ${v.level}.`);
      }
    }

    this.vagabonds = remaining;
  }

updateVillageHeroes(dt){
    const hero = this.hero;

    for(const vh of this.villageHeroes){
      if(vh.dead){
        vh.respawnTimer -= dt;
        if(vh.respawnTimer<=0){
          vh.dead=false;
          vh.hp = vh.maxHp;
          vh.x = vh.town.x + (Math.random()*40-20);
          vh.y = vh.town.y + (Math.random()*40-20);
        }
        continue;
      }

      // Villes démoniaques : les héros humains ne devraient plus exister, sécurité
      if(vh.town && vh.town.isDemonTown){
        vh.dead = true;
        vh.respawnTimer = 9999;
        continue;
      }

      vh.attackTimer = Math.max(0,vh.attackTimer-dt);
      vh.spellTimer = Math.max(0,vh.spellTimer-dt);

      // Regen PV légère (avec multiplicateur de passif)
      vh.hp = clamp(vh.hp + vh.maxHp*VILLAGE_HP_REGEN_RATIO*vh.hpRegenMult*dt,0,vh.maxHp);

      const town = vh.town;
      const allianceId = town ? town.allianceId : null;
      const enemyAlliances = this.getEnemyAlliancesFor(allianceId);

      // 1) Priorité : démons proches
      let bestMonster=null;
      for(const m of this.monsters){
        const d = dist(vh.x,vh.y,m.x,m.y);
        if(d>260) continue;
        if(!bestMonster || d<bestMonster.d) bestMonster={m,d};
      }

      // 2) Ensuite, unités ennemies (soldats + héros de village) si guerre active
      let bestEnemyUnit=null;
      if(!bestMonster && enemyAlliances.length>0){
        for(const s of this.soldiers){
          if(!s.isAlive || !s.isAlive()) continue;
          if(!enemyAlliances.includes(s.allianceId)) continue;
          const d = dist(vh.x,vh.y,s.x,s.y);
          if(d>260) continue;
          if(!bestEnemyUnit || d<bestEnemyUnit.d) bestEnemyUnit={u:s,d};
        }
        for(const other of this.villageHeroes){
          if(other===vh) continue;
          if(other.dead) continue;
          if(!other.town || other.town.isDemonTown) continue;
          if(!enemyAlliances.includes(other.town.allianceId)) continue;
          const d = dist(vh.x,vh.y,other.x,other.y);
          if(d>260) continue;
          if(!bestEnemyUnit || d<bestEnemyUnit.d) bestEnemyUnit={u:other,d};
        }
      }

      // 3) Enfin, ville ennemie à proximité -> siège
      let siegeTown=null;
      if(!bestMonster && !bestEnemyUnit && enemyAlliances.length>0){
        for(const t of this.towns){
          if(t.isDemonTown) continue;
          if(!enemyAlliances.includes(t.allianceId)) continue;
          const d = dist(vh.x,vh.y,t.x,t.y);
          if(d>260) continue;
          if(!siegeTown || d<siegeTown.d) siegeTown={town:t,d};
        }
      }

      if(bestMonster){
        const target = bestMonster.m;
        const dx=target.x-vh.x, dy=target.y-vh.y;
        const d = Math.hypot(dx,dy)||1;
        const dirx=dx/d, diry=dy/d;

        if(d>32){
          let step=vh.speed*dt;
          step *= this.getMoveMultiplierAt(vh.x,vh.y);
          if(step>d) step=d;
          vh.x+=dirx*step; vh.y+=diry*step;
        }

        if(vh.spell && vh.spellTimer<=0 && d<(vh.spell.range||220) && vh.spell.type==="projectile"){
          const color = SPELL_COLORS[vh.spell.name] || "#ffffff";
          const dmg = computeSpellDamage(vh, target, vh.spell, this, 1.0);
          target.hp -= dmg;
          target.x += dirx*KNOCKBACK_MONSTER;
          target.y += diry*KNOCKBACK_MONSTER;
          this.spawnEffect("projectile",{start:{x:vh.x,y:vh.y},end:{x:target.x,y:target.y},color});
          vh.spellTimer = (vh.spell.cooldown || 2.0)*GLOBAL_SPELL_CD_FACTOR;

          applyPassiveOnDamage(vh, dmg, target, this, {spellLifeSteal: vh.spell.lifeSteal || 0});
        }

        if(d<34 && vh.attackTimer<=0){
          const dmg = Math.max(1,vh.attack-(target.defense||0));
          target.hp -= dmg;
          vh.attackTimer = vh.attackDelay;
          target.x += dirx*KNOCKBACK_MONSTER;
          target.y += diry*KNOCKBACK_MONSTER;
          vh.x -= dirx*KNOCKBACK_SELF;
          vh.y -= diry*KNOCKBACK_SELF;

          applyPassiveOnDamage(vh, dmg, target, this, {});
        }

      } else if(bestEnemyUnit){
        const target = bestEnemyUnit.u;
        const dx=target.x-vh.x, dy=target.y-vh.y;
        const d = Math.hypot(dx,dy)||1;
        const dirx=dx/d, diry=dy/d;

        if(d>32){
          let step=vh.speed*dt;
          step *= this.getMoveMultiplierAt(vh.x,vh.y);
          if(step>d) step=d;
          vh.x+=dirx*step; vh.y+=diry*step;
        }

        if(vh.spell && vh.spellTimer<=0 && d<(vh.spell.range||220) && vh.spell.type==="projectile"){
          const color = SPELL_COLORS[vh.spell.name] || "#ffffff";
          const dmg = computeSpellDamage(vh, target, vh.spell, this, 1.0);
          target.hp -= dmg;
          this.spawnEffect("projectile",{start:{x:vh.x,y:vh.y},end:{x:target.x,y:target.y},color});
          vh.spellTimer = (vh.spell.cooldown || 2.0)*GLOBAL_SPELL_CD_FACTOR;
          applyPassiveOnDamage(vh, dmg, target, this, {spellLifeSteal: vh.spell.lifeSteal || 0});
        }

        if(d<34 && vh.attackTimer<=0){
          const raw = vh.attack - (target.defense||0);
          const dmg = Math.max(1,raw);
          target.hp -= dmg;
          vh.attackTimer = vh.attackDelay;

          target.x += dirx*KNOCKBACK_MONSTER;
          target.y += diry*KNOCKBACK_MONSTER;
          vh.x -= dirx*KNOCKBACK_SELF;
          vh.y -= diry*KNOCKBACK_SELF;

          applyPassiveOnDamage(vh, dmg, target, this, {});
        }

      } else if(siegeTown){
        const t = siegeTown.town;
        const dx=t.x-vh.x, dy=t.y-vh.y;
        const d = Math.hypot(dx,dy)||1;
        const dirx=dx/d, diry=dy/d;

        if(d>40){
          let step=vh.speed*dt*0.8;
          step *= this.getMoveMultiplierAt(vh.x,vh.y);
          if(step>d) step=d;
          vh.x+=dirx*step; vh.y+=diry*step;
        } else {
          // Dégâts de siège sur la ville ennemie
          this.applySiegeDamageOnTown(t, allianceId, dt, 1.0);
        }

      } else {
        // Patrouille autour de la ville d'origine
        if(!vh.patrolTarget || dist(vh.x,vh.y,vh.patrolTarget.x,vh.patrolTarget.y)<10){
          const ang=Math.random()*Math.PI*2;
          const rad=60+Math.random()*160;
          vh.patrolTarget={
            x: vh.town.x + Math.cos(ang)*rad,
            y: vh.town.y + Math.sin(ang)*rad
          };
        }
        const tx=vh.patrolTarget.x, ty=vh.patrolTarget.y;
        const dx=tx-vh.x, dy=ty-vh.y;
        const d=Math.hypot(dx,dy)||1;
        const dirx=dx/d, diry=dy/d;
        let step=vh.speed*dt*0.7;
        step *= this.getMoveMultiplierAt(vh.x,vh.y);
        if(step>d) step=d;
        vh.x+=dirx*step; vh.y+=diry*step;
      }

      if(vh.hp<=0){
        vh.dead=true;
        vh.respawnTimer=12;
      }
    }
  }


  
  updateSoldiers(dt){
    const remaining = [];
    for(const s of this.soldiers){
      // soldats morts : mort définitive, on les enlève des listes
      if(s.dead || s.hp<=0){
        s.dead = true;
        if(s.town && s.town.soldiers){
          s.town.soldiers = s.town.soldiers.filter(x=>x!==s);
        }
        continue;
      }

      if(!s.town || s.town.isDemonTown){
        // sécurité : les soldats humains ne défendent pas les villes démoniaques
        s.dead = true;
        if(s.town && s.town.soldiers){
          s.town.soldiers = s.town.soldiers.filter(x=>x!==s);
        }
        continue;
      }

      remaining.push(s);

      s.attackTimer = Math.max(0,s.attackTimer-dt);
      if(s.spell) s.spellTimer = Math.max(0,s.spellTimer-dt);

      // regen légère
      const regenMult = s.hpRegenMult || 1.0;
      s.hp = clamp(s.hp + s.maxHp*VILLAGE_HP_REGEN_RATIO*0.8*regenMult*dt,0,s.maxHp);

      const allianceId = s.allianceId;
      const enemyAlliances = this.getEnemyAlliancesFor(allianceId);

      // Si coalition active : les soldats priorisent les démons et les villes démoniaques
      let bestMonster=null, bestD=Infinity;

      // 1) Priorité absolue : démons proches (toujours vraie)
      for(const m of this.monsters){
        const d = dist(s.x,s.y,m.x,m.y);
        if(d<260 && d<bestD){
          bestD = d;
          bestMonster = m;
        }
      }

      // 2) En temps de guerre entre alliances humaines (hors coalition) : unités & villes ennemies
      let bestEnemyUnit=null, bestEnemyDist=Infinity;
      let siegeTown=null, siegeD=Infinity;

      if(!this.coalitionActive && enemyAlliances.length>0){
        // soldats ennemis
        for(const o of this.soldiers){
          if(o===s) continue;
          if(o.dead || o.hp<=0) continue;
          if(!enemyAlliances.includes(o.allianceId)) continue;
          const d = dist(s.x,s.y,o.x,o.y);
          if(d<260 && d<bestEnemyDist){
            bestEnemyDist = d;
            bestEnemyUnit = o;
          }
        }
        // héros de village ennemis
        for(const vh of this.villageHeroes){
          if(vh.dead || !vh.isAlive()) continue;
          if(!vh.town || vh.town.isDemonTown) continue;
          if(!enemyAlliances.includes(vh.town.allianceId)) continue;
          const d = dist(s.x,s.y,vh.x,vh.y);
          if(d<260 && d<bestEnemyDist){
            bestEnemyDist = d;
            bestEnemyUnit = vh;
          }
        }

        // villes ennemies pour le siège
        if(!bestMonster && !bestEnemyUnit){
          for(const t of this.towns){
            if(t.isDemonTown) continue;
            if(!enemyAlliances.includes(t.allianceId)) continue;
            const d = dist(s.x,s.y,t.x,t.y);
            if(d<260 && d<siegeD){
              siegeD = d;
              siegeTown = t;
            }
          }
        }
      }

      // 3) Si coalition active : cibler les villes démoniaques comme objectif de siège
      if(this.coalitionActive && !bestMonster){
        for(const t of this.towns){
          if(!t.isDemonTown) continue;
          const d = dist(s.x,s.y,t.x,t.y);
          if(d<260 && d<siegeD){
            siegeD = d;
            siegeTown = t;
          }
        }
      }

      if(bestMonster){
        const target = bestMonster;
        const dx = target.x - s.x;
        const dy = target.y - s.y;
        const d = Math.hypot(dx,dy)||1;
        const dirx = dx/d, diry = dy/d;

        if(d>30){
          let step = s.speed*dt;
          step *= this.getMoveMultiplierAt(s.x,s.y);
          if(step>d) step=d;
          s.x += dirx*step;
          s.y += diry*step;
        }

        // Sort du soldat contre les démons (projectile / AOE)
        if(s.spell && s.spellTimer<=0 && d<(s.spell.range||220) && d>40 &&
           (s.spell.type==="projectile" || s.spell.type==="aoe")){
          const color = SPELL_COLORS[s.spell.name] || "#ffffff";
          const dmg = computeSpellDamage(s, target, s.spell, this, 1.0);
          target.hp -= dmg;
          applyPassiveOnDamage(s, dmg, target, this, {spellLifeSteal:s.spell.lifeSteal||0});
          target.x += dirx*KNOCKBACK_MONSTER*0.8;
          target.y += diry*KNOCKBACK_MONSTER*0.8;
          this.spawnEffect("projectile",{start:{x:s.x,y:s.y},end:{x:target.x,y:target.y},color});
          s.spellTimer = (s.spell.cooldown || 2.5)*GLOBAL_SPELL_CD_FACTOR;
        }

        // Attaque de mêlée
        if(d<34 && s.attackTimer<=0){
          const raw = s.attack - (target.defense||0);
          const dmg = Math.max(1,raw);
          target.hp -= dmg;
          s.attackTimer = s.attackDelay;

          target.x += dirx*KNOCKBACK_MONSTER;
          target.y += diry*KNOCKBACK_MONSTER;
          s.x -= dirx*KNOCKBACK_SELF;
          s.y -= diry*KNOCKBACK_SELF;
          applyPassiveOnDamage(s, dmg, target, this, {});
        }

      } else if(bestEnemyUnit){
        const target = bestEnemyUnit;
        const dx = target.x - s.x;
        const dy = target.y - s.y;
        const d = Math.hypot(dx,dy)||1;
        const dirx = dx/d, diry = dy/d;

        if(d>30){
          let step = s.speed*dt;
          step *= this.getMoveMultiplierAt(s.x,s.y);
          if(step>d) step=d;
          s.x += dirx*step;
          s.y += diry*step;
        }

        // Sort du soldat contre les unités ennemies
        if(s.spell && s.spellTimer<=0 && d<(s.spell.range||200) && d>40 &&
           (s.spell.type==="projectile" || s.spell.type==="aoe")){
          const color = SPELL_COLORS[s.spell.name] || "#ffffff";
          const dmg = computeSpellDamage(s, target, s.spell, this, 1.0);
          target.hp -= dmg;
          applyPassiveOnDamage(s, dmg, target, this, {spellLifeSteal:s.spell.lifeSteal||0});
          target.x += dirx*KNOCKBACK_MONSTER*0.7;
          target.y += diry*KNOCKBACK_MONSTER*0.7;
          this.spawnEffect("projectile",{start:{x:s.x,y:s.y},end:{x:target.x,y:target.y},color});
          s.spellTimer = (s.spell.cooldown || 2.5)*GLOBAL_SPELL_CD_FACTOR;
        }

        if(d<34 && s.attackTimer<=0){
          const raw = s.attack - (target.defense||0);
          const dmg = Math.max(1,raw);
          target.hp -= dmg;
          s.attackTimer = s.attackDelay;

          target.x += dirx*KNOCKBACK_MONSTER;
          target.y += diry*KNOCKBACK_MONSTER;
          s.x -= dirx*KNOCKBACK_SELF;
          s.y -= diry*KNOCKBACK_SELF;
          applyPassiveOnDamage(s, dmg, target, this, {});
        }

      } else {
        if(siegeTown){
          const t = siegeTown;
          const dx = t.x - s.x;
          const dy = t.y - s.y;
          const d = Math.hypot(dx,dy)||1;
          const dirx = dx/d, diry = dy/d;

          if(d>40){
            let step = s.speed*dt*0.8;
            step *= this.getMoveMultiplierAt(s.x,s.y);
            if(step>d) step=d;
            s.x += dirx*step;
            s.y += diry*step;
          } else {
            if(t.isDemonTown){
              // Siège d'une ville démoniaque : on l'affaiblit
              this.applySiegeDamageOnTown(t, allianceId, dt, 0.6);
            }else{
              // Siège classique entre alliances
              this.applySiegeDamageOnTown(t, allianceId, dt, 1.0);
            }
          }

        } else {
          // Patrouille / expédition
          // Les soldats peuvent parfois partir en expédition pour rapporter de l'or à leur ville
          if(s.state === "defense" && !this.coalitionActive && !siegeTown && !bestMonster && !bestEnemyUnit){
            if(!s.expeditionTarget && Math.random()<0.002){
              const areas = this.pois.filter(p=>p.type==="forest" || p.type==="zone");
              if(areas.length>0){
                s.expeditionTarget = randChoice(areas);
                s.state = "expedition";
                this.logEvent(`${s.town.name} envoie un soldat en expédition vers une ${s.expeditionTarget.type==="forest"?"forêt":"zone"}.`);
              }
            }
          }

          if(s.state === "expedition" && s.expeditionTarget){
            const tx = s.expeditionTarget.x;
            const ty = s.expeditionTarget.y;
            const dx = tx - s.x;
            const dy = ty - s.y;
            const d = Math.hypot(dx,dy)||1;
            const dirx = dx/d, diry = dy/d;

            if(d>24){
              let step = s.speed*dt*0.8;
              step *= this.getMoveMultiplierAt(s.x,s.y);
              if(step>d) step=d;
              s.x += dirx*step;
              s.y += diry*step;
            }else{
              // Sur place : le soldat "farme" de l'or
              if(s.gold == null) s.gold = 0;
              s.gold += 10*dt; // ~5s pour atteindre 50 or
              if(s.gold >= 50){
                s.state = "return";
                this.logEvent(`Un soldat de ${s.town.name} termine son expédition et rentre avec ${Math.floor(s.gold)} or.`);
              }
            }

          } else if(s.state === "return"){
            const tx = s.town.x;
            const ty = s.town.y;
            const dx = tx - s.x;
            const dy = ty - s.y;
            const d = Math.hypot(dx,dy)||1;
            const dirx = dx/d, diry = dy/d;

            if(d>28){
              let step = s.speed*dt*0.9;
              step *= this.getMoveMultiplierAt(s.x,s.y);
              if(step>d) step=d;
              s.x += dirx*step;
              s.y += diry*step;
            }else{
              // Dépôt de l'or à la ville
              const gain = Math.floor(s.gold||0);
              if(gain>0){
                s.town.gold = (s.town.gold||0) + gain;
                this.logEvent(`Un soldat rapporte ${gain} or à ${s.town.name} après son expédition.`);
              }
              s.gold = 0;
              s.state = "defense";
              s.expeditionTarget = null;
            }

          } else {
            // Patrouille autour de la ville
            if(!s.patrolTarget || dist(s.x,s.y,s.patrolTarget.x,s.patrolTarget.y)<10){
              const ang = Math.random()*Math.PI*2;
              const rad = 40+Math.random()*120;
              s.patrolTarget = {
                x: s.town.x + Math.cos(ang)*rad,
                y: s.town.y + Math.sin(ang)*rad
              };
            }

            const tx = s.patrolTarget.x;
            const ty = s.patrolTarget.y;
            const dx = tx - s.x;
            const dy = ty - s.y;
            const d = Math.hypot(dx,dy)||1;
            const dirx = dx/d, diry = dy/d;

            let step = s.speed*dt*0.7;
            step *= this.getMoveMultiplierAt(s.x,s.y);
            if(step>d) step=d;
            s.x += dirx*step;
            s.y += diry*step;
          }
        }
      }
    }

    // remplace la liste par seulement les soldats encore vivants
    this.soldiers = remaining;
  }




// ---------- XP PARTAGÉE ----------

  distributeExperience(monster,xpGain){
    const hero = this.hero;
    const r = XP_RADIUS;

    if(hero.isAlive() && dist(hero.x,hero.y,monster.x,monster.y) <= r){
      hero.gainXp(xpGain);
    }

    for(const vh of this.villageHeroes){
      if(!vh.isAlive()) continue;
      if(dist(vh.x,vh.y,monster.x,monster.y) <= r){
        vh.gainXp(xpGain);
      }
    }

    // Les soldats d'alliance proches gagnent aussi de l'expérience
    for(const s of this.soldiers){
      if(!s.isAlive || !s.isAlive()) continue;
      if(dist(s.x,s.y,monster.x,monster.y) <= r){
        // XP légèrement réduite pour éviter qu'ils ne dépassent trop vite le héros
        s.gainXp(Math.max(1, Math.floor(xpGain*0.6)));
      }
    }

    // Les vagabonds proches gagnent également de l'expérience
    if(this.vagabonds){
      for(const v of this.vagabonds){
        if(!v.isAlive || !v.isAlive()) continue;
        if(dist(v.x,v.y,monster.x,monster.y) <= r){
          v.gainXp(Math.max(1, Math.floor(xpGain*0.7)));
        }
      }
    }
  }

  // ---------- XP & LEVEL UP DES DÉMONS ----------

  monsterGainXp(monster, amount){
    if(!monster) return;
    if(monster.xp == null) monster.xp = 0;
    if(monster.xpToNext == null){
      const lvl = monster.level || 1;
      monster.xpToNext = 10 + 2*lvl;
    }
    monster.xp += amount;
    while(monster.xp >= monster.xpToNext){
      monster.xp -= monster.xpToNext;
      this.monsterLevelUp(monster);
    }
  }

  monsterLevelUp(monster){
    monster.level = (monster.level || 1) + 1;
    monster.maxHp = (monster.maxHp || 10) + 6;
    monster.hp = monster.maxHp;
    monster.attack = (monster.attack || 2) + 1;
    if(monster.level % 3 === 0){
      monster.defense = (monster.defense || 0) + 1;
      monster.speed = (monster.speed || 60) + 1; // +1 VIT
    }
    if(monster.xpToNext == null) monster.xpToNext = 10 + 2*(monster.level||1);
    monster.xpToNext = Math.floor(monster.xpToNext * 1.15);

    // Donne un sort offensif s'il n'en a pas encore
    if(!monster.spell){
      const offensiveSpells = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
      if(offensiveSpells.length>0){
        monster.spell = randChoice(offensiveSpells);
        monster.spellTimer = 0;
      }
    }
  }

  // ---------- MONSTRE QUI TUE UN HÉROS = GAIN D'XP ----------

  onHeroKilledByMonster(victim,monster){
    const vLevel = victim.level || 1;
    const gain = 8 + vLevel*2; // XP gagnée par le démon
    this.monsterGainXp(monster, gain);
  }

  // ---------- IA DES DÉMONS (avec mode gardien de portail) ----------

  updateMonsters(dt){
    const hero=this.hero;
    const toRemove=[];
    for(const m of this.monsters){
      // regen légère
      m.hp = clamp(m.hp + m.maxHp*MONSTER_HP_REGEN_RATIO*dt,0,m.maxHp);

      // trouver cible : héros, héros de ville, neutres
      let bestTarget = {obj:hero,dist:dist(m.x,m.y,hero.x,hero.y),type:"hero"};
      for(const vh of this.villageHeroes){
        if(!vh.isAlive()) continue;
        const d=dist(m.x,m.y,vh.x,vh.y);
        if(d<bestTarget.dist){
          bestTarget={obj:vh,dist:d,type:"villageHero"};
        }
      }
      if(this.vagabonds){
        for(const v of this.vagabonds){
          if(!v || !v.isAlive || !v.isAlive()) continue;
          const d=dist(m.x,m.y,v.x,v.y);
          if(d<bestTarget.dist){
            bestTarget={obj:v,dist:d,type:"vagabond"};
          }
        }
      }
      for(const n of this.neutrals){
        const d=dist(m.x,m.y,n.x,n.y);
        if(d<bestTarget.dist){
          bestTarget={obj:n,dist:d,type:"neutral"};
        }
      }
      // cibler aussi les soldats (défense des villes / guerres)
      for(const s of this.soldiers){
        if(!s || s.dead || s.hp<=0) continue;
        const d=dist(m.x,m.y,s.x,s.y);
        if(d<bestTarget.dist){
          bestTarget={obj:s,dist:d,type:"soldier"};
        }
      }

      // ---------- MODE "GARDIEN DE PORTAIL" ----------
      if(m.portalZone && this.currentZone && this.currentZone===m.portalZone){
        const cz = m.portalZone.poi;
        const distHeroCenter = dist(hero.x,hero.y,cz.x,cz.y);
        const distMonsterCenter = dist(m.x,m.y,cz.x,cz.y);
        const defendRadius = 260;
        const leashRadius  = 330;

        if(distHeroCenter > defendRadius){
          bestTarget = {obj:{x:cz.x,y:cz.y}, dist: distMonsterCenter, type:"portalCenter"};
        } else {
          if(distMonsterCenter > leashRadius){
            bestTarget = {obj:{x:cz.x,y:cz.y}, dist: distMonsterCenter, type:"portalCenter"};
          } else {
            const distTargetCenter = dist(bestTarget.obj.x,bestTarget.obj.y,cz.x,cz.y);
            if(bestTarget.type!=="hero" && distTargetCenter>leashRadius){
              bestTarget = {obj:{x:cz.x,y:cz.y}, dist: distMonsterCenter, type:"portalCenter"};
            }
          }
        }
      }

      const target = bestTarget.obj;
      const d = bestTarget.dist;
      const dx=target.x-m.x, dy=target.y-m.y;
      const norm = Math.hypot(dx,dy)||1;
      const dirx=dx/norm, diry=dy/norm;

      const detectRange = 260;

      // Mouvement
      if(bestTarget.type==="portalCenter"){
        // gardien de portail : revenir vers le centre
        if(d>8){
          let step=m.speed*dt;
          step *= this.getMoveMultiplierAt(m.x,m.y);
          if(step>d) step=d;
          m.x+=dirx*step; m.y+=diry*step;
        }
      } else {
        if(d < detectRange){
          if(d>26){
            let step=m.speed*dt;
            step *= this.getMoveMultiplierAt(m.x,m.y);
            if(step>d) step=d;
            m.x+=dirx*step; m.y+=diry*step;
          }
        } else {
          if(!m.wanderTarget || dist(m.x,m.y,m.wanderTarget.x,m.wanderTarget.y)<6 || Math.random()<0.01){
            const ang=Math.random()*Math.PI*2;
            const rad=80+Math.random()*150;
            m.wanderTarget={x: clamp(m.x+Math.cos(ang)*rad,0,WORLD_WIDTH),
                            y: clamp(m.y+Math.sin(ang)*rad,0,WORLD_HEIGHT)};
          }
          const tx=m.wanderTarget.x, ty=m.wanderTarget.y;
          const ddx=tx-m.x, ddy=ty-m.y;
          const dd=Math.hypot(ddx,ddy)||1;
          const dir2x=ddx/dd, dir2y=ddy/dd;
          let step=m.speed*dt*0.6;
          step *= this.getMoveMultiplierAt(m.x,m.y);
          if(step>dd) step=dd;
          m.x+=dir2x*step; m.y+=dir2y*step;
        }
      }

      m.attackTimer = Math.max(0,m.attackTimer-dt);
      if(m.spell) m.spellTimer = Math.max(0,m.spellTimer-dt);

      // Sorts des démons (avec gestion du renvoi du héros)
        if(bestTarget.type!=="portalCenter" &&
           m.spell && m.spellTimer<=0 && d<(m.spell.range||240) && d>40 &&
           (m.spell.type==="projectile" || m.spell.type==="aoe")){
          const color = SPELL_COLORS[m.spell.name] || "#ff8888";

        if(bestTarget.type==="hero" && hero.reflectTimer>0){
          // Le sort est renvoyé : le démon prend son propre sort,
          // basé sur son ATK et réduit par SA DEF
          const dmg = computeSpellDamage(m, m, m.spell, this, 1.0);
          m.hp -= dmg;
          m.x -= dirx*KNOCKBACK_MONSTER;
          m.y -= diry*KNOCKBACK_MONSTER;
          hero.x -= dirx*KNOCKBACK_SELF*0.4;
          hero.y -= diry*KNOCKBACK_SELF*0.4;
          this.spawnEffect("reflectHit",{start:{x:hero.x,y:hero.y},end:{x:m.x,y:m.y},color});
        } else {
          const defTarget = (bestTarget.type==="hero" || bestTarget.type==="villageHero" || bestTarget.type==="neutral" || bestTarget.type==="soldier" || bestTarget.type==="vagabond")
            ? bestTarget.obj
            : hero;
          const dmg = computeSpellDamage(m, defTarget, m.spell, this, 1.0);
          const beforeHp = defTarget.hp;
          defTarget.hp -= dmg;
          defTarget.x += dirx*KNOCKBACK_HERO*0.7;
          defTarget.y += diry*KNOCKBACK_HERO*0.7;
          m.x -= dirx*KNOCKBACK_SELF*0.6;
          m.y -= diry*KNOCKBACK_SELF*0.6;
          this.spawnEffect("projectile",{start:{x:m.x,y:m.y},end:{x:defTarget.x,y:defTarget.y},color});
          if(beforeHp>0 && defTarget.hp<=0){
            if(bestTarget.type==="hero" || bestTarget.type==="villageHero"){
              this.onHeroKilledByMonster(defTarget,m);
            }
          }
        }

        m.spellTimer = (m.spell.cooldown || 2.5)*GLOBAL_SPELL_CD_FACTOR;
      }
      // Combat de mêlée
      if(bestTarget.type!=="portalCenter" && d<34){
        // héros frappe
        if(bestTarget.type==="hero" && hero.isAlive() && hero.attackTimer<=0){
          let dmg=Math.max(1,hero.attack-(m.defense||0));
          if(hero.passive && hero.passive.demonDamageBonus) dmg = Math.floor(dmg*(1+hero.passive.demonDamageBonus));
          if(hero.passive && hero.passive.zoneDamageBonus && this.inZone) dmg = Math.floor(dmg*(1+hero.passive.zoneDamageBonus));
          m.hp -= dmg;
          hero.attackTimer = hero.attackDelay;
          m.x -= dirx*KNOCKBACK_MONSTER;
          m.y -= diry*KNOCKBACK_MONSTER;
          hero.x += dirx*KNOCKBACK_SELF;
          hero.y += diry*KNOCKBACK_SELF;
          hero.onDealDamage(dmg,m,this,{});
        }
        // héros de ville frappe
        if(bestTarget.type==="villageHero" && typeof bestTarget.obj.isAlive==="function" && bestTarget.obj.isAlive() && bestTarget.obj.attackTimer<=0){
          const vh=bestTarget.obj;
          const dmg = Math.max(1,vh.attack-(m.defense||0));
          m.hp -= dmg;
          vh.attackTimer = vh.attackDelay;
          m.x -= dirx*KNOCKBACK_MONSTER;
          m.y -= diry*KNOCKBACK_MONSTER;
          vh.x += dirx*KNOCKBACK_SELF;
          vh.y += diry*KNOCKBACK_SELF;
          applyPassiveOnDamage(vh, dmg, m, this, {});
        }
        if(bestTarget.type==="vagabond" && typeof bestTarget.obj.isAlive==="function" && bestTarget.obj.isAlive() && bestTarget.obj.attackTimer<=0){
          const vb=bestTarget.obj;
          const dmg = Math.max(1,vb.attack-(m.defense||0));
          m.hp -= dmg;
          vb.attackTimer = vb.attackDelay;
          m.x -= dirx*KNOCKBACK_MONSTER;
          m.y -= diry*KNOCKBACK_MONSTER;
          vb.x += dirx*KNOCKBACK_SELF;
          vb.y += diry*KNOCKBACK_SELF;
          applyPassiveOnDamage(vb, dmg, m, this, {});
        }

        // démon frappe sa cible
        if(m.attackTimer<=0){
          if(bestTarget.type==="neutral"){
            const targetN = bestTarget.obj;
            const beforeHp = targetN.hp;
            const dmgH=Math.max(1,m.attack);
            targetN.hp -= dmgH;
            m.attackTimer = 0.9;
            targetN.x += dirx*KNOCKBACK_HERO*0.7;
            targetN.y += diry*KNOCKBACK_HERO*0.7;
            m.x -= dirx*(KNOCKBACK_MONSTER*0.4);
            m.y -= diry*(KNOCKBACK_MONSTER*0.4);
          } else {
            const defTarget = (bestTarget.type==="hero")
              ? hero
              : ((bestTarget.type==="villageHero" || bestTarget.type==="soldier" || bestTarget.type==="vagabond") ? bestTarget.obj : null);
            if(defTarget){
              const dmgH=Math.max(1,m.attack - (defTarget.defense||0));
              const beforeHp = defTarget.hp;
              defTarget.hp -= dmgH;
              m.attackTimer = 0.9;
              defTarget.x += dirx*KNOCKBACK_HERO;
              defTarget.y += diry*KNOCKBACK_HERO;
              m.x -= dirx*(KNOCKBACK_MONSTER*0.4);
              m.y -= diry*(KNOCKBACK_MONSTER*0.4);

              if(beforeHp>0 && defTarget.hp<=0){
                if(bestTarget.type==="hero" || bestTarget.type==="villageHero"){
                  this.onHeroKilledByMonster(defTarget,m);
                } else if(bestTarget.type==="vagabond"){
                  defTarget.dead = true;
                  this.logEvent(`${defTarget.name} est tombé face aux démons.`);
                }
              }
            }
          }
        }

        hero.x=clamp(hero.x,0,WORLD_WIDTH);
        hero.y=clamp(hero.y,0,WORLD_HEIGHT);
      }

      if(m.hp<=0){
        toRemove.push(m);
        const lvl=m.level||1;
        let baseXp=1+lvl;
        let baseGold=Math.max(1,Math.floor(lvl/2));
        let mult=1;
        const rarity=this.getMonsterRarity(m);
        if(rarity==="elite") mult+=0.4;
        if(rarity==="champion") mult+=0.8;
        if(rarity==="special") mult+=1.2;
        const xpGain=Math.max(1,Math.floor(baseXp*mult));
        const goldGain=Math.max(1,Math.floor((baseGold+1)*mult));

        this.distributeExperience(m,xpGain);

        let finalGold = goldGain;
        if(this.hero.passive && this.hero.passive.goldBonus) finalGold = Math.floor(finalGold*(1+this.hero.passive.goldBonus));

        this.goldItems.push({x:m.x,y:m.y,amount:finalGold,ttl:GOLD_TTL});
        if(Math.random()<0.25){
          this.potions.push({x:m.x,y:m.y,ttl:POTION_TTL});
        }
        // Fragment magique de mana : petite chance de tomber sur la mort d'un monstre
        if(Math.random() < MANA_SHARD_DROP_CHANCE){
          if(!this.manaShards) this.manaShards = [];
          this.manaShards.push({x:m.x,y:m.y,ttl:MANA_SHARD_TTL});
        }
        // Pré-fragment instable : parfois, un fragment dangereux apparaît
        if(Math.random() < PRE_FRAGMENT_DROP_CHANCE){
          if(!this.preFragments) this.preFragments = [];
          const elements = ["fire","ice","lightning","shadow"];
          const element = elements[Math.floor(Math.random()*elements.length)];
          this.preFragments.push({x:m.x,y:m.y,ttl:PRE_FRAGMENT_TTL,element});
          this.logEvent("Un pré-fragment instable est apparu sur un démon vaincu !");
        }
        this.handleMonsterKillForQuest(m);

        // Passif : heal sur kill
        if(this.hero.passive && this.hero.passive.killHealRatio){
          const heal = Math.max(1,Math.floor(this.hero.maxHp*this.hero.passive.killHealRatio));
          this.hero.hp = clamp(this.hero.hp+heal,0,this.hero.maxHp);
        }
      }
    }
    
    // Bêtes magiques : à leur mort, elles laissent un fragment stable garanti
    if(this.stableFragments == null) this.stableFragments = [];
    for(const m of toRemove){
      if(m && (m.isFragmentBeast || m.fromFragment)){
        const elem = m.fragmentElement || null;
        this.stableFragments.push({x:m.x,y:m.y,element:elem});
        this.logEvent("La bête magique vaincue se recristallise en fragment stable.");
      }
    }
    // retirer monstres morts
    this.monsters = this.monsters.filter(m=>!toRemove.includes(m));

    // retirer neutres morts
    this.neutrals = this.neutrals.filter(n=>n.hp>0);
  }

  // ---------- QUÊTES ----------

  handleMonsterKillForQuest(monster){
    if(!this.currentQuest) return;
    const q = this.currentQuest;
    const area = q.area;
    if(!area) return;

    // Quêtes "tuer X démons" ou "sauver une ville"
    if(q.type==="kill" || q.type==="rescueTown"){
      const d = dist(monster.x,monster.y,area.x,area.y);
      if(d > QUEST_KILL_RADIUS) return;

      this.questProgress++;
      if(this.questProgress >= q.targetCount){
        const reward = q.reward || 0;
        this.hero.gold += reward;

        if(q.type==="kill"){
          this.logEvent(`Quête accomplie : démons éliminés (+${reward} or).`);
        } else if(q.type==="rescueTown"){
          area.isDemonTown = false;
          area.hp = area.maxHp || area.hp;
          this.logEvent(`Quête accomplie : ${area.name} n’est plus une ville démoniaque ! (+${reward} or).`);
          // Met à jour la carte et redonne un aspect normal à la ville
          if(this.buildTileMap) this.buildTileMap();
          if(this.spawnVillageHeroes) this.spawnVillageHeroes();
        }

        this.currentQuest = null;
        this.questProgress = 0;
      }
      return;
    }

    // Les autres types de quête sont gérés ailleurs (destroyZone, supplyTown)
  }

  // Génère une quête pour une ville : soit kill, soit "détruire un portail"
  maybeGiveQuest(town){
    if(this.currentQuest) return;
    const hero=this.hero;

    // Quête spéciale : sauver une ville tombée aux démons
    const demonTowns = (this.towns && this.towns.length>0 ? this.towns : this.pois.filter(p=>p.type==="town")).filter(t=>t.isDemonTown);
    if(demonTowns.length>0 && hero.level>=20){
      const targetTown = randChoice(demonTowns);
      const base = 6 + Math.floor((targetTown.level||1)*1.2);
      const targetCount = base;
      const reward = randInt(QUEST_REWARD_MIN,QUEST_REWARD_MAX) + hero.level*15;
      this.currentQuest = {
        type:"rescueTown",
        targetCount,
        reward,
        area:targetTown
      };
      this.questProgress = 0;
      this.logEvent(`Quête : détruire la ville démoniaque ${targetTown.name} pour la libérer.`);
      return;
    }

    // Quête d'alliance : livrer des provisions à une ville alliée
    if(this.alliances && town.allianceId!=null && hero.level>=3 && hero.level<20){
      const alliance = this.alliances.find(a=>a.id===town.allianceId);
      if(alliance && alliance.towns && alliance.towns.length>1){
        const otherTowns = alliance.towns.filter(t=>t!==town);

        // Plus fréquent aux bas niveaux, plus rare ensuite
        let supplyChance = 0.25;
        if(hero.level<=6) supplyChance = 0.6;
        else if(hero.level<=12) supplyChance = 0.35;
        else if(hero.level<=18) supplyChance = 0.2;
        else supplyChance = 0.05;

        if(otherTowns.length>0 && Math.random()<supplyChance){
          const target = randChoice(otherTowns);
          const reward = randInt(QUEST_REWARD_MIN,QUEST_REWARD_MAX) + hero.level*8;
          this.currentQuest = {
            type:"supplyTown",
            reward,
            from:town,
            area:target,
            delivered:false
          };
          this.questProgress = 0;
          this.logEvent(`Quête d’alliance : livrer des provisions de ${town.name} à ${target.name}.`);
          return;
        }
      }
    }

    // Chance de quête rare : détruire un portail de niveau proche
    let destroyCandidates = this.pois.filter(p=>p.type==="zone" && !p.completed);
    destroyCandidates = destroyCandidates.filter(z=>{
      const lvl = z.level || hero.level;
      return lvl>=hero.level-1 && lvl<=hero.level+2;
    });

    // Si le héros est assez haut niveau et qu'on n'a aucun portail proche -> on en crée un exprès pour la quête
    if(destroyCandidates.length===0 && hero.level>=PORTAL_MIN_LEVEL_FOR_AUTO){
      const newPortal = this.spawnRandomPortal(Math.max(1, hero.level - randInt(0,2)));
      if(newPortal) destroyCandidates.push(newPortal);
    }

    let doDestroyZoneQuest = false;
    if(destroyCandidates.length>0){
      if(hero.level>=20){
        // À partir du niveau 20 : quêtes de portails fréquentes
        doDestroyZoneQuest = true;
      } else if(hero.level>=10){
        // Entre le niveau 10 et 19 : quêtes de portails très rares
        if(Math.random()<0.12) doDestroyZoneQuest = true;
      }
    }

    if(doDestroyZoneQuest){
      const zone = randChoice(destroyCandidates);
      const reward = randInt(QUEST_REWARD_MIN,QUEST_REWARD_MAX) + hero.level*18;
      this.currentQuest = {
        type:"destroyZone",
        targetCount:0,
        reward,
        area:zone
      };
      this.questProgress = 0;
      this.logEvent(`Quête rare : détruire le portail Lv ${zone.level||1}.`);
      return;
    }

    // Sinon : quête classique "tuer X démons près d'une zone/forêt"
    // À partir du niveau 20 : plus de quête de farm classique, seulement des portails
    if(hero.level>=20){
      return;
    }

    let base = randInt(3,5);
    let extra = Math.floor(hero.level/4);
    let targetCount = base + extra;
    if(targetCount > 12) targetCount = 12;

    const rewardBase = randInt(QUEST_REWARD_MIN,QUEST_REWARD_MAX);
    const reward = rewardBase + hero.level*10;

    // choisir une zone ou forêt proche du niveau du héros
    let areas;
    if(hero.level>=8){
      // À partir du niveau 8 : quêtes de kill surtout dans les zones (portails)
      areas = this.pois.filter(p=>p.type==="zone");
    } else if(hero.level<=4){
      // Très bas niveau : uniquement les forêts
      areas = this.pois.filter(p=>p.type==="forest");
    } else {
      // Niveau moyen : mélange zones / forêts
      areas = this.pois.filter(p=>p.type==="zone" || p.type==="forest");
    }

    let candidates = areas.filter(a=>{
      const lvl = a.level || hero.level;
      return lvl>=hero.level && lvl<=hero.level+3;
    });
    if(candidates.length===0) candidates = areas;
    if(candidates.length===0) return;

    let best=null,bestScore=Infinity;
    for(const a of candidates){
      const d=dist(town.x,town.y,a.x,a.y);
      const lvl = a.level || hero.level;
      const lvlDelta = Math.abs(lvl-hero.level);
      const score = lvlDelta*300 + d;
      if(score<bestScore){bestScore=score;best=a;}
    }
    if(!best) return;

    this.currentQuest = {
      type:"kill",
      targetCount,
      reward,
      area:best
    };
    this.questProgress = 0;

    const areaName = best.type==="zone" ? "un portail" : "une forêt";
    this.logEvent(`Quête : tuer ${targetCount} démons près de ${areaName}.`);
  }

  tryCompleteQuest(town){
    const q = this.currentQuest;
    if(!q) return;

    // Quête de livraison de provisions entre villes alliées
    if(q.type==="supplyTown" && !q.delivered){
      if(q.area === town){
        q.delivered = true;
        const reward = q.reward || 0;
        this.hero.gold += reward;

        // Donne aussi de l’XP au héros
        const xpGain = 8 + this.hero.level*3;
        this.hero.gainXp(xpGain);

        this.logEvent(`Quête accomplie : provisions livrées à ${town.name} (+${reward} or, +${xpGain} XP).`);
        this.currentQuest = null;
        this.questProgress = 0;
      }
    }
    // Les autres types de quêtes se terminent via d'autres méthodes
  }

  // ---------- LOOT, VILLES, SHOPS, COFFRES ----------

  checkLootCollisions(){
    const hero=this.hero;

    // OR
    const remainingGold=[];
    for(const g of this.goldItems){
      let taken=false;

      // Héros joueur
      if(dist(hero.x,hero.y,g.x,g.y) < 15){
        hero.gold += g.amount;
        taken=true;
      } else {
        // Héros de village : rapportent l'or à leur ville
        for(const vh of this.villageHeroes){
          if(vh.dead || !vh.town) continue;
          if(dist(vh.x,vh.y,g.x,g.y) < 18){
            vh.town.gold = (vh.town.gold||0) + g.amount;
            this.logEvent(`${vh.name} rapporte ${g.amount} or à ${vh.town.name}.`);
            taken=true;
            break;
          }
        }
      }

      if(!taken) remainingGold.push(g);
    }
    this.goldItems = remainingGold;

    // POTIONS
    const remainingPotions=[];
    for(const p of this.potions){
      let taken=false;

      if(dist(hero.x,hero.y,p.x,p.y) < 15){
        hero.potionsCount++;
        taken=true;
      } else {
        for(const vh of this.villageHeroes){
          if(vh.dead || !vh.town) continue;
          if(dist(vh.x,vh.y,p.x,p.y) < 18){
            vh.town.storedPotions = (vh.town.storedPotions||0) + 1;
            this.logEvent(`${vh.name} stocke une potion dans ${vh.town.name}.`);
            taken=true;
            break;
          }
        }
      }

      if(!taken) remainingPotions.push(p);
    }

    // FRAGMENTS MAGIQUES
    if(this.manaShards){
      const remainingShards = [];
      for(const shard of this.manaShards){
        let taken = false;

        // Héros joueur : gagne du mana max (petits fragments de mana)
        if(dist(hero.x,hero.y,shard.x,shard.y) < 15){
          if(typeof hero.maxMp === "number"){
            hero.maxMp += 1;
            hero.mp = Math.min(hero.maxMp, hero.mp+1);
            this.logEvent("Le héros absorbe un fragment magique de mana (+1 mana max).");
          }
          hero.manaShardsAbsorbed = (hero.manaShardsAbsorbed||0) + 1;
          this.logEvent(`Fragments de mana absorbés : ${hero.manaShardsAbsorbed}.`);
          taken = true;
        } else {
          // Héros de village : transforment en or pour leur ville
          for(const vh of this.villageHeroes){
            if(vh.dead || !vh.town) continue;
            if(dist(vh.x,vh.y,shard.x,shard.y) < 18){
              vh.town.gold = (vh.town.gold||0) + 30;
              this.logEvent(`${vh.name} apporte un fragment magique à ${vh.town.name} (+30 or).`);
              taken = true;
              break;
            }
          }

          // Vagabonds : trèèès attirés par la magie
          if(!taken && this.vagabonds){
            for(const v of this.vagabonds){
              if(!v || v.dead) continue;
              if(dist(v.x,v.y,shard.x,shard.y) < 16){
                // Petit bonus : un peu de regen et d'XP
                v.hp = Math.min(v.maxHp, v.hp + 2);
                if(typeof v.gainXp === "function") v.gainXp(1);
                taken = true;
                break;
              }
            }
          }

          // Soldats : rapportent à leur ville
          if(!taken){
            for(const s of this.soldiers){
              if(!s || s.dead || !s.town) continue;
              if(dist(s.x,s.y,shard.x,shard.y) < 16){
                s.town.gold = (s.town.gold||0) + 30;
                this.logEvent(`Un soldat de ${s.town.name} récupère un fragment magique (+30 or).`);
                taken = true;
                break;
              }
            }
          }

          // Monstres : peuvent aussi les absorber (petit buff de PV)
          if(!taken){
            for(const mon of this.monsters){
              if(!mon || mon.dead) continue;
              if(dist(mon.x,mon.y,shard.x,shard.y) < 14){
                if(typeof mon.maxHp === "number"){
                  mon.maxHp += 2;
                  mon.hp = Math.min(mon.maxHp, (mon.hp||mon.maxHp)+2);
                }
                taken = true;
                break;
              }
            }
          }
        }

        if(!taken) remainingShards.push(shard);
      }
      this.manaShards = remainingShards;
    }

    // PRÉ-FRAGMENTS INSTABLES (mutables en bêtes magiques)
    if(this.preFragments){
      const remainingPre = [];
      for(const f of this.preFragments){
        let taken = false;

        // Héros joueur : capture le pré-fragment avant la mutation -> fragment stable
        if(dist(hero.x,hero.y,f.x,f.y) < 16){
          hero.fragmentStableCount = (hero.fragmentStableCount||0) + 1;
          this.stableFragments = this.stableFragments || [];
          this.stableFragments.push({x:f.x,y:f.y,element:f.element||null});
          this.logEvent("Le héros sécurise un fragment instable (fragment stable +1).");
          taken = true;
        }

        if(!taken) remainingPre.push(f);
      }
      this.preFragments = remainingPre;
    }

    // FRAGMENTS STABLES (ressource de mutation)
    if(this.stableFragments){
      const remainingStable = [];
      for(const sf of this.stableFragments){
        let taken = false;
        if(dist(hero.x,hero.y,sf.x,sf.y) < 16){
          hero.fragmentStableCount = (hero.fragmentStableCount||0) + 1;
          this.logEvent(`Fragment stable ramassé. Total : ${hero.fragmentStableCount}.`);
          taken = true;
        }

        if(!taken) remainingStable.push(sf);
      }
      this.stableFragments = remainingStable;
    }

    // Déblocage de la mutation / ulti spécial : nécessite niveau 25+ et 10 fragments stables
    if(!hero.fragmentUltimateUnlocked && hero.fragmentStableCount>=10 && hero.level>=25){
      hero.fragmentUltimateUnlocked = true;
      hero.hasMutation = true;
      // Pour l'instant, on choisit un élément au hasard parmi quelques types
      const elements = ["fire","ice","lightning","shadow"];
      const elem = elements[Math.floor(Math.random()*elements.length)];
      hero.mutationElement = elem;
      // Sort de mutation en fonction de l'élément
      if(elem === "fire"){
        hero.fragmentSpell = {
          name:"Flamboiement Fragmentaire",
          type:"aoe",
          cost:20,
          power:10,
          radius:260,
          cooldown:25.0,
          color:"#ff8a50"
        };
      } else if(elem === "ice"){
        hero.fragmentSpell = {
          name:"Cœur de Givre Absolu",
          type:"aoe",
          cost:18,
          power:7,
          radius:260,
          cooldown:22.0,
          color:"#90caf9"
        };
      } else if(elem === "lightning"){
        hero.fragmentSpell = {
          name:"Jugement d’Alara",
          type:"projectile",
          cost:20,
          power:12,
          range:320,
          radius:0,
          cooldown:28.0,
          color:"#64b5f6"
        };
      } else {
        hero.fragmentSpell = {
          name:"Étreinte des Ombres",
          type:"aoe",
          cost:18,
          power:8,
          radius:240,
          cooldown:24.0,
          color:"#b39ddb"
        };
      }
      this.logEvent("RITUEL DES FRAGMENTS : le héros subit une mutation et obtient un sort ultime !");
    }
    this.potions = remainingPotions;
  }

  checkTownInteractions(){
    const hero=this.hero;
    if(this.currentTown && dist(hero.x,hero.y,this.currentTown.x,this.currentTown.y)>60){
      this.currentTown=null;
    }
    for(const p of this.pois){
      if(p.type!=="town") continue;
      if(dist(hero.x,hero.y,p.x,p.y)<50){
        if(!this.currentTown || this.currentTown!==p){
          this.currentTown=p;
          this.handleTownVisit(p);
        }
        break;
      }
    }
  }

  handleTownVisit(town){
    const hero=this.hero;

    // Vente du sac
    if(hero.backpack.length>0){
      let sellGold=0;
      for(const it of hero.backpack){
        const val=(it.attackBonus||0)+(it.defenseBonus||0)+(it.speedBonus||0);
        sellGold += Math.max(1,val);
      }
      if(sellGold>0){
        hero.gold += sellGold;
        const tax = Math.floor(sellGold*0.25);
        town.gold = (town.gold||0) + tax;
        this.logEvent(`Objets vendus à ${town.name} : +${sellGold} or pour le héros, +${tax} or pour la ville.`);
      }
      hero.backpack=[];
    }

    // Vente de potions excédentaires à la ville
    const sellablePotions = Math.max(0, hero.potionsCount-2);
    if(sellablePotions>0 && (town.gold||0) > POTION_SALE_PRICE){
      const maxAffordable = Math.floor((town.gold||0)/POTION_SALE_PRICE);
      const sold = Math.min(sellablePotions, maxAffordable);
      if(sold>0){
        const gain = sold * POTION_SALE_PRICE;
        hero.potionsCount -= sold;
        hero.gold += gain;
        town.gold -= gain;
        town.storedPotions = (town.storedPotions||0) + sold;
        this.logEvent(`${hero.name} vend ${sold} potion(s) à ${town.name} (+${gain} or).`);
      }
    }

    // Remise de fragments stables au royaume pour le commerce
    const spareFragments = Math.max(0, (hero.fragmentStableCount||0) - 10);
    if(spareFragments>0){
      const donated = Math.min(spareFragments, 8);
      hero.fragmentStableCount -= donated;
      town.tradeFragments = (town.tradeFragments||0) + donated;
      const townBonus = donated * Math.floor(CARAVAN_FRAGMENT_VALUE * 0.6);
      const heroBonus = donated * Math.floor(CARAVAN_FRAGMENT_VALUE * 0.4);
      town.gold = (town.gold||0) + townBonus;
      hero.gold += heroBonus;
      this.logEvent(`${hero.name} confie ${donated} fragment(s) à ${town.name} pour alimenter le commerce (+${heroBonus} or héros, +${townBonus} or ville).`);
    }

    // Soins & achats en ville
    if(hero.level < 7){
      // Comportement simple avant le niveau 7
      if(hero.hp<hero.maxHp*0.5 && hero.gold>=TOWN_SHOP_COST){
        hero.gold -= TOWN_SHOP_COST;
        // La ville gagne la moitié du prix comme taxe
        town.gold = (town.gold||0) + Math.floor(TOWN_SHOP_COST/2);
        hero.hp = hero.maxHp;
        this.logEvent(`Soin acheté à ${town.name} (-${TOWN_SHOP_COST} or, +${Math.floor(TOWN_SHOP_COST/2)} or pour la ville).`);
      }
    } else {
      // A partir du niveau 7 : il dépense pour soin OU équipement
      if(hero.hp < hero.maxHp*0.85 && hero.gold>=TOWN_SHOP_COST){
        hero.gold -= TOWN_SHOP_COST;
        town.gold = (town.gold||0) + Math.floor(TOWN_SHOP_COST/2);
        hero.hp = hero.maxHp;
        this.logEvent(`(Lv7+) Soin complet acheté à ${town.name} (-${TOWN_SHOP_COST} or, +${Math.floor(TOWN_SHOP_COST/2)} or pour la ville).`);
      } else if(hero.gold >= SHOP_COST){
        hero.gold -= SHOP_COST;
        town.gold = (town.gold||0) + Math.floor(SHOP_COST/2);
        const slotTypes=["armure","épée","relique","objet"];
        const slotType=randChoice(slotTypes);
        const defenseBonus=Math.floor(Math.random()*4)+1;
        const attackBonus=Math.floor(Math.random()*9)+1;
        const speedBonus=Math.floor(Math.random()*9);
        const names={
          armure:"Armure ancienne",
          "épée":"Épée runique",
          relique:"Relique mystique",
          objet:"Talisman étrange"
        };
        const item={
          name:names[slotType],
          slotType,
          attackBonus,
          defenseBonus,
          speedBonus
        };
        hero.addEquipment(item);
        this.logEvent(`(Lv7+) Achat d'équipement à ${town.name} : ${item.name}.`);
      }
    }

    // Petit bonus MP
    if(Math.random()<0.08){
      hero.maxMp += 4;
      hero.mp = hero.maxMp;
    }

    this.tryCompleteQuest(town);
    // Pas de nouvelles quêtes dans une ville démoniaque
    if(!town.isDemonTown && !this.currentQuest){
      this.maybeGiveQuest(town);
    }
  }

  // Shops près des villes
  spawnShop(){
    const towns = this.pois.filter(p=>p.type==="town");
    if(towns.length===0) return;
    const town = randChoice(towns);

    // une seule boutique par ville à la fois
    if(this.shops.some(s=>s.town===town)) return;

    const ang = Math.random()*Math.PI*2;
    const r = 70+Math.random()*40;
    const x = clamp(town.x + Math.cos(ang)*r,0,WORLD_WIDTH);
    const y = clamp(town.y + Math.sin(ang)*r,0,WORLD_HEIGHT);
    this.shops.push({
      x,y,town
    });
    this.logEvent(`Une boutique itinérante apparaît près de ${town.name}.`);
  }

  spawnChest(){
    const areas = this.pois.filter(p=>p.type==="zone" || p.type==="forest");
    if(areas.length===0) return;
    const area = randChoice(areas);
    const ang = Math.random()*Math.PI*2;
    const r = 60+Math.random()*80;
    const x = clamp(area.x + Math.cos(ang)*r,0,WORLD_WIDTH);
    const y = clamp(area.y + Math.sin(ang)*r,0,WORLD_HEIGHT);
    const tile = this.getTileAt(x,y);
    if(tile===TILE.WATER || tile===TILE.TOWN || tile===TILE.DEMON_CITY) return;
    this.chests.push({x,y,area});
    this.logEvent(`Un coffre apparaît près d'une ${area.type==="zone"?"zone démoniaque":"forêt"}.`);
  }

  checkSpecialInteractions(){
    const hero=this.hero;

    // Shops (détruits après usage)
    let remainingShops = [];
    for(const shop of this.shops){
      let usedNow = false;
      if(dist(hero.x,hero.y,shop.x,shop.y)<28){
        if(hero.gold>=SHOP_COST){
          hero.gold -= SHOP_COST;
          // La ville associée à la boutique gagne la moitié du prix
          if(shop.town){
            shop.town.gold = (shop.town.gold||0) + Math.floor(SHOP_COST/2);
          }
          const slotTypes=["armure","épée","relique","objet"];
          const slotType=randChoice(slotTypes);
          const defenseBonus=Math.floor(Math.random()*4)+1;
          const attackBonus=Math.floor(Math.random()*9)+1;
          const speedBonus=Math.floor(Math.random()*9);
          const names={
            armure:"Armure ancienne",
            "épée":"Épée runique",
            relique:"Relique mystique",
            objet:"Talisman étrange"
          };
          const item={
            name:names[slotType],
            slotType,
            attackBonus,
            defenseBonus,
            speedBonus
          };
          hero.addEquipment(item);
          this.logEvent(`Achat d'équipement à la boutique près de ${shop.town.name} : ${item.name}.`);
          usedNow = true;
        }
      }
      if(!usedNow){
        remainingShops.push(shop);
      }
    }
    this.shops = remainingShops;

    // Coffres (détruits après ouverture)
    this.chests = this.chests.filter(ch=>{
      if(dist(hero.x,hero.y,ch.x,ch.y)<20){
        if(Math.random()<0.5){
          const goldGain = randInt(25,80);
          hero.gold += goldGain;
          this.logEvent(`Coffre ouvert : +${goldGain} or.`);
        } else {
          const xpGain = randInt(5,18);
          hero.gainXp(xpGain);
          this.logEvent(`Coffre ouvert : +${xpGain} XP.`);
        }
        return false;
      }
      return true;
    });
  }

  // ---------- PORTAILS (zones) EN VAGUES ----------

  checkZoneInteractions(){
    if(this.inZone) return;
    const hero=this.hero;
    for(const poi of this.pois){
      if(poi.type!=="zone") continue;
      if(poi.completed) continue;
      if(dist(hero.x,hero.y,poi.x,poi.y)<50){
        this.enterZone(poi);
        break;
      }
    }
  }

  // Activation d'un portail : on lance des vagues autour
  enterZone(zone){
    if(this.inZone) return;

    this.inZone = true;

    const waveCount = 3 + Math.floor(Math.random()*3); // 3 à 5 vagues

    this.currentZone = {
      poi: zone,
      level: zone.level || 1,
      roomIndex: 0,     // utilisé comme index de vague
      roomCount: waveCount
    };

    this.logEvent(`Portail démoniaque Lv ${this.currentZone.level} activé (${waveCount} vagues).`);

    // On ne téléporte pas le héros, on spawn autour
    this.spawnZoneRoom();
  }

  // Spawn d'une vague autour du portail (zone resserrée)
  spawnZoneRoom(){
    if(!this.inZone || !this.currentZone) return;

    const cd = this.currentZone;
    const lvl = cd.level;
    const waveIndex = cd.roomIndex;
    const waveCount = cd.roomCount;

    const cx = cd.poi.x;
    const cy = cd.poi.y;

    const isLastWave = (waveIndex === waveCount - 1);

    const baseCount = 3 + Math.floor(lvl / 2);
    const count = isLastWave ? baseCount + 2 : baseCount;

    if(isLastWave){
      this.logEvent(`Vague finale du portail Lv ${lvl} !`);
    } else {
      this.logEvent(`Vague ${waveIndex+1}/${waveCount} du portail Lv ${lvl}.`);
    }

    for(let i=0;i<count;i++){
      const ang = Math.random()*Math.PI*2;
      // spawn plus proche du portail qu'avant
      const d = 70 + Math.random()*80;
      const mx = clamp(cx + Math.cos(ang)*d, 0, WORLD_WIDTH);
      const my = clamp(cy + Math.sin(ang)*d, 0, WORLD_HEIGHT);

      let maxHp = 6 + lvl + Math.floor(Math.random()*4);
      let atk   = 2 + Math.floor(lvl/2);
      let def   = 0 + Math.floor(lvl/4);
      let spd   = 60 + Math.random()*40;
      let special = false;
      let name = "Démon du portail";
      let spell = null;

      // Elite / spécial
      if(Math.random() < 0.10){
        special = true;
        name = randChoice(SPECIAL_DEMON_NAMES);
        maxHp = Math.floor(maxHp * 3);
        atk  += 3;
        def  += 2;
        spd  *= 1.1;

        const offensiveSpells = SPELL_DEFS.filter(s=>s.type==="projectile" || s.type==="aoe");
        spell = randChoice(offensiveSpells);
      }


      // Seigneur démon ultra rare dans les portails (un peu plus probable sur la dernière vague)
      const lordChance = DEMON_LORD_CHANCE * (isLastWave ? 3 : 1);
      if(!special && Math.random() < lordChance && lvl>=10){
        special = true;
        name = "Seigneur Démon";
        maxHp = Math.floor(maxHp * DEMON_LORD_HP_MULT);
        atk   = Math.floor(atk * DEMON_LORD_ATTACK_MULT);
        def   = Math.floor(def * DEMON_LORD_DEFENSE_MULT);
      }

      const monster = {
        x: mx, y: my,
        hp: maxHp, maxHp,
        attack: atk,
        defense: def,
        speed: spd,
        attackTimer: 0,
        elite: special,
        champion: special,
        special,
        level: lvl,
        biome: "portail",
        slowed: false,
        spell,
        spellTimer: 0,
        wanderTarget: null,
        name,
        inDungeon: true,   // marqueur "démon de portail"
        nest: null,
        portalZone: cd,
        xp: 0,
        xpToNext: null,
        isDemonLord: (name === "Seigneur Démon")
      };

      this.monsters.push(monster);
    }
  }

  updateZoneState(){
    if(!this.inZone || !this.currentZone) return;

    const cd = this.currentZone;

    const hasPortalMonsters = this.monsters.some(m => m.portalZone === cd);
    if(hasPortalMonsters) return; // vague encore en cours

    // Plus aucun démon du portail sur la carte
    if(cd.roomIndex < cd.roomCount - 1){
      cd.roomIndex++;
      this.spawnZoneRoom();
    } else {
      this.rewardZoneClear();
      this.exitZone();
    }
  }

  rewardZoneClear(){
    const hero=this.hero;
    const lvl=this.currentZone ? this.currentZone.level : 1;
    const bonusGold=8+lvl*4;
    hero.gold += bonusGold;
    this.logEvent(`Portail Lv ${lvl} nettoyé : +${bonusGold} or.`);

    // Reward d'équipement possible
    if(Math.random()<0.5){
      const slotTypes=["armure","épée","relique","objet"];
      const slotType=randChoice(slotTypes);
      const defenseBonus=Math.floor(Math.random()*4);
      const attackBonus=Math.floor(Math.random()*11);
      const speedBonus=Math.floor(Math.random()*11);
      const names={
        armure:"Armure ancienne",
        "épée":"Épée runique",
        relique:"Relique mystique",
        objet:"Talisman étrange"
      };
      const item={
        name:names[slotType],
        slotType,
        attackBonus,
        defenseBonus,
        speedBonus
      };
      hero.addEquipment(item);
      this.logEvent(`Loot de portail : ${item.name}.`);
    }

    // Quête "détruire un portail" ?
    if(this.currentQuest &&
       this.currentQuest.type==="destroyZone" &&
       this.currentZone &&
       this.currentQuest.area === this.currentZone.poi){
      const reward = this.currentQuest.reward;
      hero.gold += reward;
      this.logEvent(`Quête accomplie : portail détruit (+${reward} or).`);
      this.currentQuest = null;
      this.questProgress = 0;
    }
  }

  exitZone(){
    if(!this.inZone || !this.currentZone) return;

    const poi = this.currentZone.poi;
    poi.completed = true;

    // On supprime ce portail de la liste des POI
    this.pois = this.pois.filter(p => p !== poi);

    // Nettoyage des monstres liés au portail
    this.monsters = this.monsters.filter(m => m.portalZone !== this.currentZone);

    this.logEvent(`Le portail démoniaque a été détruit.`);

    // Le héros reste là où il est
    this.inZone = false;
    this.currentZone = null;
  }

  // ---------- EFFETS ----------

  spawnEffect(type,params){
    const eff={
      type,
      age:0,
      duration:params.duration || (
        type==="projectile" || type==="reflectHit" ? 0.3 :
        type==="heal" || type==="reflect" || type==="slash" ? 0.5 :
        0.4
      ),
      color:params.color || "#ffffff",
      start:params.start||null,
      end:params.end||null,
      center:params.center||null,
      radius:params.radius||null,
      dir:params.dir||null,
      angle:params.angle||null
    };
    this.effects.push(eff);
  }

  updateEffects(dt){
    this.effects = this.effects.filter(e=>{
      e.age += dt;
      return e.age < e.duration;
    });
  }

  // ---------- DRAW ----------

  worldToScreen(x,y,camX,camY){
    return {x:x-camX,y:y-camY};
  }

  draw(){
    const ctx=this.ctx;
    ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
    const hero=this.hero;
    const camX = clamp(hero.x - WINDOW_WIDTH/2,0,WORLD_WIDTH-WINDOW_WIDTH);
    const camY = clamp(hero.y - WINDOW_HEIGHT/2,0,WORLD_HEIGHT-WINDOW_HEIGHT);
    this.drawBackground(camX,camY);
    this.drawBridges(camX,camY);
    for(const p of this.pois) this.drawPoi(p,camX,camY);
    for(const g of this.goldItems) this.drawGold(g,camX,camY);
    for(const p of this.potions) this.drawPotion(p,camX,camY);
    if(this.manaShards){
      for(const s of this.manaShards) this.drawManaShard(s,camX,camY);
    }
    // pré-fragments instables (avant mutation)
    if(this.preFragments){
      for(const f of this.preFragments) this.drawPreFragment(f,camX,camY);
    }
    // fragments stables (ressource de mutation)
    if(this.stableFragments){
      for(const sf of this.stableFragments) this.drawStableFragment(sf,camX,camY);
    }
    for(const c of this.chests) this.drawChest(c,camX,camY);
    for(const s of this.shops) this.drawShop(s,camX,camY);
    for(const cv of this.caravans) this.drawCaravan(cv,camX,camY);
    for(const n of this.neutrals) this.drawNeutral(n,camX,camY);
    for(const m of this.monsters) this.drawMonster(m,camX,camY);
    for(const vh of this.villageHeroes) this.drawVillageHero(vh,camX,camY);
    if(this.vagabonds){
      for(const v of this.vagabonds) this.drawVagabond(v,camX,camY);
    }
    for(const s of this.soldiers) this.drawSoldier(s,camX,camY);
    this.drawHero(hero,camX,camY);
    this.drawEffects(camX,camY);
    this.drawUI();
  }

  
  
  drawVagabond(vag,camX,camY){
    if(!vag || vag.dead) return;
    const ctx=this.ctx;
    const s=this.worldToScreen(vag.x,vag.y,camX,camY);
    const r=13;
    ctx.save();

    // corps proche des héros de ville
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle=vag.bodyColor || "#8bc34a";
    ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle=vag.borderColor || "#1d3557";
    ctx.stroke();

    // visage
    ctx.fillStyle="#f1e0c5";
    ctx.fillRect(s.x-6,s.y-6,12,6);
    ctx.fillStyle="#000";
    ctx.fillRect(s.x-3,s.y-5,2,2);
    ctx.fillRect(s.x+1,s.y-5,2,2);
    ctx.fillStyle="rgba(0,0,0,0.4)";
    ctx.fillRect(s.x-7,s.y-8,14,3);

    // orbes vertes caractéristiques
    ctx.fillStyle = vag.state==="vagabond" ? "#66bb6a" : "#9ccc65";
    ctx.beginPath();
    ctx.arc(s.x-10, s.y-4, 4, 0, Math.PI*2);
    ctx.arc(s.x+10, s.y-4, 4, 0, Math.PI*2);
    ctx.arc(s.x, s.y+12, 4, 0, Math.PI*2);
    ctx.fill();

    // barre de vie
    const ratio = vag.maxHp>0 ? vag.hp/vag.maxHp : 0;
    const bw=22,bh=4;
    const bx=s.x-bw/2, by=s.y-r-7;
    ctx.fillStyle="#220000";
    ctx.fillRect(bx,by,bw,bh);
    ctx.fillStyle="#66bb6a";
    ctx.fillRect(bx,by,bw*ratio,bh);
    ctx.strokeStyle="#111";
    ctx.strokeRect(bx,by,bw,bh);

    ctx.restore();
  }

drawSoldier(sol,camX,camY){
    if(sol.dead) return;
    const ctx=this.ctx;
    const s=this.worldToScreen(sol.x,sol.y,camX,camY);
    const r=11;
    ctx.save();

    // corps
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle="#607d8b";
    ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle="#263238";
    ctx.stroke();

    // bouclier
    ctx.beginPath();
    ctx.arc(s.x-5,s.y,5,Math.PI/2,Math.PI*3/2);
    ctx.fillStyle="#b0bec5";
    ctx.fill();
    ctx.strokeStyle="#37474f";
    ctx.stroke();

    // barre de vie
    const ratio = sol.maxHp>0 ? sol.hp/sol.maxHp : 0;
    const bw=22,bh=4;
    const bx=s.x-bw/2, by=s.y-r-7;
    ctx.fillStyle="#220000";
    ctx.fillRect(bx,by,bw,bh);
    ctx.fillStyle="#66bb6a";
    ctx.fillRect(bx,by,bw*ratio,bh);
    ctx.strokeStyle="#335533";
    ctx.strokeRect(bx,by,bw,bh);

    // Nom + niveau du soldat, coloré par alliance
    let label = sol.name || "Soldat";
    if(sol.level != null) label += " (Niv "+sol.level+")";
    ctx.font = "10px sans-serif";
    ctx.textAlign = "center";
    let col = "#ffffff";
    if(sol.allianceId != null){
      const al = this.getAllianceById(sol.allianceId);
      if(al && al.color) col = al.color;
    }
    ctx.fillStyle = col;
    ctx.fillText(label, s.x, by-3);

    ctx.restore();
  }

drawBackground(camX,camY){
    const ctx=this.ctx;
    const size=TILE_SIZE;
    const x0 = Math.floor(camX/size)-2;
    const x1 = Math.floor((camX+WINDOW_WIDTH)/size)+2;
    const y0 = Math.floor(camY/size)-2;
    const y1 = Math.floor((camY+WINDOW_HEIGHT)/size)+2;
    for(let gx=x0;gx<=x1;gx++){
      for(let gy=y0;gy<=y1;gy++){
        const wx=gx*size, wy=gy*size;
        const cx=wx+size/2, cy=wy+size/2;
        if(cx<0||cx>WORLD_WIDTH||cy<0||cy>WORLD_HEIGHT) continue;
        const tile = this.getTileAt(cx,cy);
        let c1="#35532d", c2="#3a5b34";
        if(tile===TILE.FOREST){ c1="#234f2b"; c2="#275733"; }
        else if(tile===TILE.MARSH){ c1="#26352c"; c2="#2b3b32"; }
        else if(tile===TILE.MOUNTAIN){ c1="#4b4f5a"; c2="#555b66"; }
        else if(tile===TILE.PLAINS){ c1="#3f6b29"; c2="#44752e"; }
        else if(tile===TILE.ROAD){ c1="#5c5243"; c2="#665b48"; }
        else if(tile===TILE.WATER){ c1="#1e88e5"; c2="#42a5f5"; }
        else if(tile===TILE.TOWN){ c1="#8d6e63"; c2="#a1887f"; }
        else if(tile===TILE.DEMON_CITY){ c1="#4a1f1f"; c2="#6a1f1f"; }
        else if(tile===TILE.ZONE){ c1="#4e342e"; c2="#6d4c41"; }

        const col = ((gx+gy)&1)===0 ? c1 : c2;
        const s=this.worldToScreen(wx,wy,camX,camY);
        ctx.fillStyle=col;
        ctx.fillRect(s.x,s.y,size+1,size+1);

        if(tile !== TILE.WATER){
          ctx.strokeStyle="rgba(0,0,0,0.18)";
          ctx.lineWidth=1;
          ctx.strokeRect(s.x,s.y,size+1,size+1);
        }
      }
    }
  }

  drawBridges(camX,camY){
    const ctx=this.ctx;
    for(const br of this.bridges){
      const s=this.worldToScreen(br.x,br.y,camX,camY);
      const w=42,h=16;
      ctx.fillStyle="#6d4c41";
      ctx.strokeStyle="#3e2723";
      ctx.lineWidth=2;
      ctx.fillRect(s.x-w/2,s.y-h/2,w,h);
      ctx.strokeRect(s.x-w/2,s.y-h/2,w,h);
      ctx.strokeStyle="#bcaaa4";
      ctx.beginPath(); ctx.moveTo(s.x-w/2,s.y-h/4); ctx.lineTo(s.x+w/2,s.y-h/4); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(s.x-w/2,s.y+h/4); ctx.lineTo(s.x+w/2,s.y+h/4); ctx.stroke();
    }
  }

  drawPoi(p,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(p.x,p.y,camX,camY);
    ctx.save();

    if(p.type==="town"){
      const r=20;
      // corps de la ville
      ctx.fillStyle = p.isDemonTown ? "#4a1f1f" : "#e0cda1";
      ctx.strokeStyle = p.isDemonTown ? "#b71c1c" : "#a38c6a";
      ctx.fillRect(s.x-r,s.y-r,2*r,2*r);
      ctx.strokeRect(s.x-r,s.y-r,2*r,2*r);

      // toit
      ctx.beginPath();
      ctx.moveTo(s.x-r,s.y-r);
      ctx.lineTo(s.x,s.y-r-15);
      ctx.lineTo(s.x+r,s.y-r);
      ctx.closePath();
      ctx.fillStyle = p.isDemonTown ? "#880e4f" : "#c14953";
      ctx.strokeStyle = p.isDemonTown ? "#4a148c" : "#7b2f36";
      ctx.fill();
      ctx.stroke();

      // barre de vie
      if(p.maxHp){
        const w=46,h=5;
        const bx=s.x-w/2, by=s.y+r+2;
        const ratio = clamp(p.hp||0,0,p.maxHp)/p.maxHp;
        ctx.fillStyle="#222";
        ctx.fillRect(bx,by,w,h);
        ctx.fillStyle = p.isDemonTown ? "#ef5350" : "#66bb6a";
        ctx.fillRect(bx,by,w*ratio,h);
        ctx.strokeStyle="#000";
        ctx.strokeRect(bx,by,w,h);
      }

      // nom + alliance
      const lvl = p.level || 1;
      const name = p.name || "Ville";
      ctx.font="8px Helvetica";
      ctx.textAlign="center";
      const colorName = p.isDemonTown ? "#ff8a80" : (p.allianceColor || "white");
      ctx.fillStyle = colorName;
      ctx.fillText(`${name} (Lv ${lvl})`, s.x, s.y+r+12);

      if(p.isDemonTown){
        ctx.font="7px Helvetica";
        ctx.fillStyle="#ff8a80";
        ctx.fillText("Ville démon", s.x, s.y+r+21);
      } else if(p.allianceName){
        ctx.font="7px Helvetica";
        ctx.fillStyle=p.allianceColor || "#cfd8dc";
        ctx.fillText(p.allianceName, s.x, s.y+r+21);
      }
    } else if(p.type==="forest"){
      const r=22;
      ctx.fillStyle="#21451c";
      ctx.beginPath();
      ctx.arc(s.x,s.y,r,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle="#0f260b";
      ctx.stroke();
      // petits arbres
      for(let i=0;i<5;i++){
        const ang = Math.random()*Math.PI*2;
        const distR = 4+Math.random()*r*0.6;
        const ax = s.x + Math.cos(ang)*distR;
        const ay = s.y + Math.sin(ang)*distR;
        ctx.beginPath();
        ctx.moveTo(ax,ay-6);
        ctx.lineTo(ax-4,ay+4);
        ctx.lineTo(ax+4,ay+4);
        ctx.closePath();
        ctx.fillStyle="#2e7d32";
        ctx.fill();
      }
      ctx.font="8px Helvetica";
      ctx.fillStyle="#c8e6c9";
      ctx.textAlign="center";
      ctx.fillText("Forêt",s.x,s.y+r+10);
    } else if(p.type==="zone"){
      const r=18;
      ctx.beginPath();
      ctx.arc(s.x,s.y,r,0,Math.PI*2);
      ctx.fillStyle="#311b92";
      ctx.fill();
      ctx.strokeStyle="#b39ddb";
      ctx.lineWidth=2;
      ctx.stroke();

      // runes
      ctx.beginPath();
      ctx.moveTo(s.x-r+6,s.y);
      ctx.lineTo(s.x,s.y-r+6);
      ctx.lineTo(s.x+r-6,s.y);
      ctx.lineTo(s.x,s.y+r-6);
      ctx.closePath();
      ctx.strokeStyle="#e1bee7";
      ctx.stroke();

      const lvl = p.level || 1;
      ctx.font="8px Helvetica";
      ctx.fillStyle="#ede7f6";
      ctx.textAlign="center";
      ctx.fillText(`Portail Lv ${lvl}`,s.x,s.y+r+12);
    }

    ctx.restore();
  }

  drawGold(g,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(g.x,g.y,camX,camY);
    const r=6;
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle="#ffdd33"; ctx.fill();
    ctx.strokeStyle="#aa9900"; ctx.stroke();
  }

  drawPotion(p,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(p.x,p.y,camX,camY);
    const r=7;
    ctx.fillStyle="#3399ff";
    ctx.strokeStyle="#115577";
    ctx.fillRect(s.x-r,s.y-r,2*r,2*r);
    ctx.strokeRect(s.x-r,s.y-r,2*r,2*r);
    ctx.fillStyle="#e6e6e6";
    ctx.fillRect(s.x-2,s.y-r-4,4,4);
    ctx.strokeStyle="#b0b0b0";
    ctx.strokeRect(s.x-2,s.y-r-4,4,4);
  }



  drawPreFragment(frag,camX,camY){
    const ctx = this.ctx;
    const s = this.worldToScreen(frag.x, frag.y, camX, camY);
    const r = 7;
    ctx.save();
    ctx.beginPath();
    ctx.arc(s.x, s.y, r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(180,120,255,0.6)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#ffeb3b";
    ctx.stroke();
    ctx.restore();
  }

  drawStableFragment(frag,camX,camY){
    const ctx = this.ctx;
    const s = this.worldToScreen(frag.x, frag.y, camX, camY);
    const r = 6;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(s.x, s.y-r);
    ctx.lineTo(s.x+r, s.y);
    ctx.lineTo(s.x, s.y+r);
    ctx.lineTo(s.x-r, s.y);
    ctx.closePath();
    ctx.fillStyle = "#ffd54f";
    ctx.fill();
    ctx.strokeStyle = "#ffb300";
    ctx.stroke();
    ctx.restore();
  }

  drawManaShard(shard,camX,camY){
    const ctx = this.ctx;
    const s = this.worldToScreen(shard.x, shard.y, camX, camY);
    const r = 6;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(s.x, s.y-r);
    ctx.lineTo(s.x+r, s.y);
    ctx.lineTo(s.x, s.y+r);
    ctx.lineTo(s.x-r, s.y);
    ctx.closePath();
    ctx.fillStyle = "#bb77ff";
    ctx.fill();
    ctx.strokeStyle = "#552299";
    ctx.stroke();
    ctx.restore();
  }

  drawChest(c,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(c.x,c.y,camX,camY);
    const w=16,h=12;
    ctx.fillStyle="#6d4c41";
    ctx.strokeStyle="#3e2723";
    ctx.fillRect(s.x-w/2,s.y-h/2,w,h);
    ctx.strokeRect(s.x-w/2,s.y-h/2,w,h);
    ctx.fillStyle="#c8a26b";
    ctx.fillRect(s.x-2,s.y-h/2+2,4,h-4);
  }

  drawShop(shop,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(shop.x,shop.y,camX,camY);
    const r=12;
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle="#ffb300";
    ctx.fill();
    ctx.strokeStyle="#3e2723";
    ctx.stroke();
    ctx.fillStyle="#212121";
    ctx.font="9px Helvetica";
    ctx.textAlign="center";
    ctx.fillText("$",s.x,s.y+3);
  }

  drawCaravan(car,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(car.x,car.y,camX,camY);
    const r=10;

    // trajet
    if(car.to){
      const dest=this.worldToScreen(car.to.x,car.to.y,camX,camY);
      ctx.save();
      ctx.setLineDash([4,4]);
      ctx.strokeStyle="rgba(255,255,255,0.35)";
      ctx.beginPath();
      ctx.moveTo(s.x,s.y);
      ctx.lineTo(dest.x,dest.y);
      ctx.stroke();
      ctx.restore();
    }

    ctx.save();
    ctx.fillStyle="#f4a261";
    ctx.strokeStyle="#7f5539";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.rect(s.x-r,s.y-r+3,r*2,r*0.9);
    ctx.fill();
    ctx.stroke();

    // roues
    ctx.beginPath();
    ctx.arc(s.x-r+5,s.y+r-2,3,0,Math.PI*2);
    ctx.arc(s.x+r-5,s.y+r-2,3,0,Math.PI*2);
    ctx.fillStyle="#3e2723";
    ctx.fill();

    // bannière
    ctx.beginPath();
    ctx.moveTo(s.x,s.y-r-2);
    ctx.lineTo(s.x,s.y-r-10);
    ctx.lineTo(s.x+10,s.y-r-6);
    ctx.closePath();
    ctx.fillStyle="#ffd166";
    ctx.fill();
    ctx.stroke();

    // icône de cargaison
    const goods = car.goods || {};
    const pot = goods.potions||0;
    const frg = goods.fragments||0;
    ctx.fillStyle="#1b4332";
    ctx.font="8px Helvetica";
    ctx.textAlign="center";
    ctx.fillText(`P${pot}/F${frg}`, s.x, s.y+3);
    ctx.restore();
  }

  // Neutres = "moutons" ronds avec niveau
  drawNeutral(n,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(n.x,n.y,camX,camY);
    const r = 10;

    ctx.save();

    let col = "#cfd8dc";
    if(n.type==="vache") col = "#ffe0b2";
    if(n.type==="poule") col = "#fff9c4";

    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle = col;
    ctx.fill();
    ctx.strokeStyle = "#455a64";
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.fillStyle="#000";
    ctx.beginPath();
    ctx.arc(s.x-2,s.y-2,1.5,0,Math.PI*2);
    ctx.fill();

    ctx.font="8px Helvetica";
    ctx.textAlign="center";
    ctx.fillStyle="#ffffff";
    ctx.fillText(`Lv ${n.level}`, s.x, s.y - r - 4);

    ctx.restore();
  }

  drawMonster(m,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(m.x,m.y,camX,camY);
    const r=14;

    const isLord = !!m.isDemonLord;

    let body;
    if(isLord) body="#1b0000";
    else if(m.special) body="#4a148c";
    else if(m.champion) body="#d4af37";
    else if(m.elite) body="#884444";
    else body="#557755";

    let ring=null;
    if(isLord) ring="#ff1744";
    else if(m.special) ring="#ff80ff";
    else if(m.biome==="montagnes") ring="#bcaaa4";
    else if(m.biome==="marais") ring="#004d40";
    else if(m.biome==="forêt") ring="#1b5e20";
    else if(m.biome==="plaines") ring="#fdd835";
    else if(m.biome==="collines") ring="#827717";
    else if(m.biome==="donjon") ring="#9c27b0";
    else if(m.biome==="portail") ring="#9c27b0";

    ctx.save();
    if(ring){
      ctx.beginPath();
      ctx.arc(s.x,s.y,r+3,0,Math.PI*2);
      ctx.strokeStyle=ring;
      ctx.lineWidth= m.special ? 3 : 2;
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle=body; ctx.fill();
    ctx.strokeStyle="#222"; ctx.stroke();

    if(m.special){
      ctx.beginPath();
      ctx.moveTo(s.x-6,s.y-8);
      ctx.lineTo(s.x-2,s.y-12);
      ctx.lineTo(s.x+2,s.y-8);
      ctx.moveTo(s.x+6,s.y-8);
      ctx.lineTo(s.x+2,s.y-12);
      ctx.strokeStyle="#ffeb3b";
      ctx.stroke();
    }
    if(isLord){
      ctx.beginPath();
      ctx.moveTo(s.x-5,s.y-10);
      ctx.lineTo(s.x,s.y-16);
      ctx.lineTo(s.x+5,s.y-10);
      ctx.closePath();
      ctx.strokeStyle="#ffc400";
      ctx.stroke();
    }

    ctx.fillStyle="#fff";
    ctx.fillRect(s.x-4,s.y-2,3,3);
    ctx.fillRect(s.x+1,s.y-2,3,3);
    ctx.fillStyle="#000";
    ctx.fillRect(s.x-3,s.y-1,1,1);
    ctx.fillRect(s.x+2,s.y-1,1,1);

    const ratio = m.maxHp>0 ? m.hp/m.maxHp : 0;
    const bw=26,bh=4;
    const bx1=s.x-bw/2, by1=s.y-r-8;
    ctx.fillStyle="#220000"; ctx.fillRect(bx1,by1,bw,bh);
    ctx.fillStyle = isLord ? "#ff1744" : (m.special ? "#ff80ab" : "#ff5555");
    ctx.fillRect(bx1,by1,bw*ratio,bh);
    ctx.strokeStyle="#440000"; ctx.strokeRect(bx1,by1,bw,bh);

    ctx.fillStyle = isLord ? "#ffe082" : (m.special ? "#ffb3ff" : "#ffcc66");
    ctx.font="8px Helvetica";
    ctx.textAlign="center";
    const name=m.name||"Démon";
    const lvl=m.level||1;
    ctx.fillText(`${name} (Lv ${lvl})`,s.x,s.y-r-14);
    ctx.restore();
  }

  drawVillageHero(vh,camX,camY){
    if(vh.dead) return;
    const ctx=this.ctx;
    const s=this.worldToScreen(vh.x,vh.y,camX,camY);
    const r=13;
    ctx.save();
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle=vh.bodyColor;
    ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle=vh.borderColor;
    ctx.stroke();

    ctx.fillStyle="#f1e0c5";
    ctx.fillRect(s.x-6,s.y-6,12,6);
    ctx.fillStyle="#000";
    ctx.fillRect(s.x-3,s.y-5,2,2);
    ctx.fillRect(s.x+1,s.y-5,2,2);
    ctx.fillStyle="rgba(0,0,0,0.4)";
    ctx.fillRect(s.x-7,s.y-8,14,3);

    const ratio = vh.maxHp>0 ? vh.hp/vh.maxHp : 0;
    const bw=24,bh=4;
    const bx=s.x-bw/2, by=s.y-r-8;
    ctx.fillStyle="#220000";
    ctx.fillRect(bx,by,bw,bh);
    ctx.fillStyle="#66bb6a";
    ctx.fillRect(bx,by,bw*ratio,bh);
    ctx.strokeStyle="#335533";
    ctx.strokeRect(bx,by,bw,bh);

    ctx.fillStyle="#ffffff";
    ctx.font="8px Helvetica";
    ctx.textAlign="center";
    ctx.fillText(`${vh.name} (Lv ${vh.level})`, s.x, s.y-r-16);

    ctx.restore();
  }

  drawHero(hero,camX,camY){
    const ctx=this.ctx;
    const s=this.worldToScreen(hero.x,hero.y,camX,camY);
    const r=16;
    ctx.save();
    ctx.beginPath();
    ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle="#4cc9f0"; ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle="#1d3557"; ctx.stroke();
    ctx.fillStyle="#f1e0c5";
    ctx.fillRect(s.x-6,s.y-6,12,6);
    ctx.fillStyle="#000";
    ctx.fillRect(s.x-3,s.y-5,2,2);
    ctx.fillRect(s.x+1,s.y-5,2,2);
    const ang=Math.atan2(hero.dirY,hero.dirX);
    const tipx=s.x+Math.cos(ang)*(r+6);
    const tipy=s.y+Math.sin(ang)*(r+6);
    const lx=s.x+Math.cos(ang+2.5)*r;
    const ly=s.y+Math.sin(ang+2.5)*r;
    const rx=s.x+Math.cos(ang-2.5)*r;
    const ry=s.y+Math.sin(ang-2.5)*r;
    ctx.beginPath();
    ctx.moveTo(tipx,tipy);
    ctx.lineTo(lx,ly);
    ctx.lineTo(rx,ry);
    ctx.closePath();
    ctx.fillStyle="#ffdd57";
    ctx.strokeStyle="#b38a00";
    ctx.fill(); ctx.stroke();

    if(hero.reflectTimer>0){
      const t = hero.reflectTimer;
      ctx.globalAlpha = 0.4 + 0.2*Math.sin(t*8);
      ctx.beginPath();
      ctx.arc(s.x,s.y,r+6,0,Math.PI*2);
      ctx.strokeStyle="#fff59d";
      ctx.lineWidth=3;
      ctx.stroke();
    }

    ctx.restore();
  }

  drawEffects(camX,camY){
    const ctx=this.ctx;
    for(const e of this.effects){
      const t=e.age/e.duration;
      const col=e.color;
      ctx.save();
      if((e.type==="projectile" || e.type==="reflectHit") && e.start && e.end){
        const s=this.worldToScreen(e.start.x,e.start.y,camX,camY);
        const f=this.worldToScreen(e.end.x,e.end.y,camX,camY);
        ctx.strokeStyle=col;
        ctx.globalAlpha = e.type==="reflectHit" ? (0.7*(1-t)) : (0.9*(1-t));
        ctx.lineWidth= e.type==="reflectHit" ? 5*(1-t) : 4*(1-t);
        ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(f.x,f.y); ctx.stroke();
      } else if(e.type==="aoe" && e.center){
        const c=this.worldToScreen(e.center.x,e.center.y,camX,camY);
        const radius=e.radius||100;
        const cr=radius*(0.5+0.5*t);
        ctx.fillStyle=col;
        ctx.globalAlpha=0.4*(1-t);
        ctx.beginPath(); ctx.arc(c.x,c.y,cr,0,Math.PI*2); ctx.fill();
      } else if(e.type==="heal" && e.center){
        const c=this.worldToScreen(e.center.x,e.center.y,camX,camY);
        const maxR=30;
        const cr=maxR*(0.5+0.5*Math.sin(Math.PI*t));
        ctx.fillStyle=col;
        ctx.globalAlpha=0.4;
        ctx.beginPath(); ctx.arc(c.x,c.y,cr,0,Math.PI*2); ctx.fill();
      } else if(e.type==="slow" && e.center){
        const c=this.worldToScreen(e.center.x,e.center.y,camX,camY);
        const radius=e.radius||150;
        ctx.strokeStyle=col;
        ctx.lineWidth=Math.max(1,6*(1-t));
        ctx.globalAlpha=0.7*(1-t);
        ctx.beginPath(); ctx.arc(c.x,c.y,radius,0,Math.PI*2); ctx.stroke();
      } else if(e.type==="reflect" && e.center){
        const c=this.worldToScreen(e.center.x,e.center.y,camX,camY);
        const r1=24+8*Math.sin(t*Math.PI);
        ctx.globalAlpha=0.4;
        ctx.strokeStyle=col;
        ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(c.x,c.y,r1,0,Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(c.x,c.y,r1+6,0,Math.PI*2); ctx.stroke();
      } else if(e.type==="slash" && e.center && e.dir){
        const c=this.worldToScreen(e.center.x,e.center.y,camX,camY);
        const ang = Math.atan2(e.dir.y,e.dir.x);
        const range = e.range || 120;
        const half = (e.angle||Math.PI/2)/2;
        ctx.globalAlpha = 0.45*(1-t);
        ctx.fillStyle=col;
        ctx.beginPath();
        ctx.moveTo(c.x,c.y);
        ctx.arc(c.x,c.y,range,ang-half,ang+half);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle="#ffecb3";
        ctx.lineWidth=1;
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  drawStatIcon(ctx,cx,cy,kind){
    const size=6;
    if(kind==="hp"){
      ctx.beginPath();
      ctx.moveTo(cx,cy+size);
      ctx.lineTo(cx-size*0.8,cy+size*0.2);
      ctx.lineTo(cx-size*0.8,cy-size*0.4);
      ctx.lineTo(cx,cy-size);
      ctx.lineTo(cx+size*0.8,cy-size*0.4);
      ctx.lineTo(cx+size*0.8,cy+size*0.2);
      ctx.closePath();
      ctx.fillStyle="#e66a6a"; ctx.fill();
      ctx.strokeStyle="#a64242"; ctx.stroke();
    } else if(kind==="mp"){
      ctx.beginPath();
      ctx.ellipse(cx,cy,size*0.7,size*0.6,0,0,Math.PI*2);
      ctx.fillStyle="#5b7bdc"; ctx.fill();
      ctx.strokeStyle="#3a4f8a"; ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx-size*0.4,cy-size*0.5);
      ctx.lineTo(cx+size*0.4,cy-size*0.5);
      ctx.lineTo(cx,cy-size);
      ctx.closePath();
      ctx.fill(); ctx.stroke();
    } else if(kind==="xp"){
      const pts=[];
      for(let i=0;i<5;i++){
        const ang=i*(2*Math.PI/5);
        const or=size*0.9, ir=size*0.4;
        pts.push([cx+or*Math.cos(ang),cy+or*Math.sin(ang)]);
        const ang2=ang+Math.PI/5;
        pts.push([cx+ir*Math.cos(ang2),cy+ir*Math.sin(ang2)]);
      }
      ctx.beginPath();
      ctx.moveTo(pts[0][0],pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
      ctx.closePath();
      ctx.fillStyle="#c0bf63"; ctx.fill();
      ctx.strokeStyle="#807f3d"; ctx.stroke();
    }
  }

  drawItemIcon(ctx,cx,cy,slotType){
    const r=10;
    if(slotType==="armure"){
      const pts=[
        [cx,cy-r],
        [cx+r*0.8,cy-r*0.3],
        [cx+r*0.8,cy+r*0.4],
        [cx,cy+r],
        [cx-r*0.8,cy+r*0.4],
        [cx-r*0.8,cy-r*0.3]
      ];
      ctx.beginPath();
      ctx.moveTo(pts[0][0],pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
      ctx.closePath();
      ctx.fillStyle="#779ecb"; ctx.fill();
      ctx.strokeStyle="#445d8e"; ctx.stroke();
    } else if(slotType==="épée"){
      ctx.strokeStyle="#d4af37";
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(cx,cy-r); ctx.lineTo(cx,cy+r*0.6); ctx.stroke();
      ctx.fillStyle="#8d6e63";
      ctx.beginPath();
      ctx.moveTo(cx-r*0.3,cy+r*0.6);
      ctx.lineTo(cx+r*0.3,cy+r*0.6);
      ctx.lineTo(cx,cy+r);
      ctx.closePath();
      ctx.fill();
    } else if(slotType==="relique"){
      const pts=[];
      for(let i=0;i<6;i++){
        const ang=i*(2*Math.PI/6);
        pts.push([cx+r*0.8*Math.cos(ang),cy+r*0.8*Math.sin(ang)]);
      }
      ctx.beginPath();
      ctx.moveTo(pts[0][0],pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
      ctx.closePath();
      ctx.fillStyle="#b39ddb"; ctx.fill();
      ctx.strokeStyle="#7e57c2"; ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.ellipse(cx,cy,r*0.8,r*0.8,0,0,Math.PI*2);
      ctx.fillStyle="#d7ccc8"; ctx.fill();
      ctx.strokeStyle="#8d6e63"; ctx.stroke();
    }
  }

  drawBar(ctx,x,y,w,h,ratio,color){
    ratio=clamp(ratio,0,1);
    ctx.fillStyle="#222b40";
    ctx.strokeStyle="#444c66";
    ctx.fillRect(x,y,w,h);
    ctx.strokeRect(x,y,w,h);
    ctx.fillStyle=color;
    ctx.fillRect(x,y,w*ratio,h);
  }

  drawSpellIcon(ctx, cx, cy, spell){
    if(!spell) return;
    const type = spell.type;
    const col = SPELL_COLORS[spell.name] || "#ffffff";
    ctx.save();
    ctx.translate(cx,cy);
    ctx.strokeStyle=col;
    ctx.fillStyle=col;
    ctx.lineWidth=2;

    if(type==="projectile"){
      ctx.beginPath();
      ctx.moveTo(-8,0);
      ctx.lineTo(6,0);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(6,0);
      ctx.lineTo(0,-5);
      ctx.lineTo(0,5);
      ctx.closePath();
      ctx.fill();
    } else if(type==="aoe"){
      ctx.globalAlpha=0.9;
      ctx.beginPath();
      ctx.arc(0,0,8,0,Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha=0.4;
      ctx.beginPath();
      ctx.arc(0,0,4,0,Math.PI*2);
      ctx.fill();
    } else if(type==="heal"){
      ctx.beginPath();
      ctx.rect(-6,-2,12,4);
      ctx.rect(-2,-6,4,12);
      ctx.fill();
    } else if(type==="slow"){
      ctx.beginPath();
      ctx.arc(0,0,7,0,Math.PI*1.5);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(4,4);
      ctx.stroke();
    } else if(type==="reflect"){
      ctx.beginPath();
      ctx.arc(0,0,7,0,Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(0,0,4,0,Math.PI*2);
      ctx.stroke();
    } else if(type==="slash"){
      ctx.beginPath();
      ctx.moveTo(-6,4);
      ctx.lineTo(0,-6);
      ctx.lineTo(6,4);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  drawUI(){
    const ctx=this.ctx;
    const hero=this.hero;
    const panelX=10,panelY=10,panelW=360,panelH=270;

    ctx.save();
    ctx.fillStyle="#0d1522";
    ctx.fillRect(panelX+2,panelY+2,panelW+2,panelH+2);
    ctx.fillStyle="#1a2435";
    ctx.strokeStyle="#445070";
    ctx.lineWidth=2;
    ctx.fillRect(panelX,panelY,panelW,panelH);
    ctx.strokeRect(panelX,panelY,panelW,panelH);

    const barW=230,barH=16;
    const mx=panelX+20,my=panelY+15;

    const hpRatio = hero.maxHp>0?hero.hp/hero.maxHp:0;
    this.drawStatIcon(ctx,mx-18,my+barH/2,"hp");
    this.drawBar(ctx,mx,my,barW,barH,hpRatio,"#e05555");
    ctx.fillStyle="white"; ctx.font="9px Helvetica"; ctx.textAlign="center";
    ctx.fillText(`PV ${Math.floor(hero.hp)}/${hero.maxHp}`,mx+barW/2,my+barH/2+3);

    const mpY=my+barH+8;
    const mpRatio = hero.maxMp>0?hero.mp/hero.maxMp:0;
    this.drawStatIcon(ctx,mx-18,mpY+barH/2,"mp");
    this.drawBar(ctx,mx,mpY,barW,barH,mpRatio,"#5577dd");
    ctx.fillStyle="white";
    ctx.fillText(`MP ${Math.floor(hero.mp)}/${hero.maxMp}`,mx+barW/2,mpY+barH/2+3);

    const xpY=mpY+barH+8;
    const xpRatio = hero.xpToNext>0?hero.xp/hero.xpToNext:0;
    this.drawStatIcon(ctx,mx-18,xpY+barH/2,"xp");
    this.drawBar(ctx,mx,xpY,barW,barH,xpRatio,"#88bb44");
    ctx.fillStyle="black";
    ctx.fillText(`XP ${hero.xp}/${hero.xpToNext} (Niv ${hero.level})`,mx+barW/2,xpY+barH/2+3);

    // Nom + mode + vague
    let infoY=xpY+barH+12;
    ctx.fillStyle="white";
    ctx.font="12px Helvetica";
    ctx.textAlign="left";
    ctx.fillText(`Héros : ${hero.name}`,mx,infoY);

    let modeY = infoY+14;
    ctx.font="9px Helvetica";
    ctx.fillStyle="#90caf9";
    if(this.inZone && this.currentZone){
      ctx.fillText(`Mode : Portail (Lv ${this.currentZone.level})`, mx, modeY);
      ctx.fillStyle="#ffcc80";
      ctx.fillText(`Portail : Vague ${this.currentZone.roomIndex+1}/${this.currentZone.roomCount}`, mx, modeY+12);
    } else {
      ctx.fillText(`Mode : Monde`, mx, modeY);
    }

    let statsY = this.inZone && this.currentZone ? modeY+28 : modeY+16;

    ctx.fillStyle="#cccccc"; ctx.font="9px Helvetica";
    ctx.fillText(`ATK ${hero.attack}   DEF ${hero.defense}   VIT ${Math.floor(hero.moveSpeed)}`,mx,statsY);
    let info2Y=statsY+16;
    const fragCount = hero.fragmentStableCount || 0;
    const fragLabel = hero.fragmentUltimateUnlocked ? "Mutation : Ultime prêt" : (`Mutation : ${fragCount}/10`);
    ctx.fillText(`Or : ${hero.gold}   Potions : ${hero.potionsCount}   Sac : ${hero.backpack.length}   Fragments : ${fragLabel}`,mx,info2Y);

    const caravanY = info2Y+14;
    const caravanCount = this.caravans ? this.caravans.length : 0;
    ctx.fillStyle="#a5d6a7"; ctx.font="9px Helvetica";
    ctx.fillText(`Commerce : ${caravanCount} caravane(s) en route`,mx,caravanY);

    const biome=this.getBiome(hero.x,hero.y);
    let biomeY=caravanY+14;
    ctx.fillStyle="#a5d6a7"; ctx.font="9px Helvetica";
    ctx.fillText(`Biome : ${biome.charAt(0).toUpperCase()+biome.slice(1)}`,mx,biomeY);

    // Passif
    const passiveY = biomeY+14;
    if(hero.passive){
      ctx.fillStyle="#ffd54f";
      ctx.font="9px Helvetica";
      ctx.fillText(`Passif : ${hero.passive.name}`, mx, passiveY);
      ctx.fillStyle="#cfd8dc";
      ctx.font="8px Helvetica";
      ctx.fillText(hero.passive.desc, mx, passiveY+11);
    }

    const targetDesc = (()=>{
      const target=hero.target;
      if(!target || !target.obj) return "Aucune";
      const obj=target.obj;
      if(obj.x===undefined || obj.y===undefined) return "Aucune";
      const distTo=Math.floor(dist(hero.x,hero.y,obj.x,obj.y));
      const suffix = `- ${distTo}u`;
      if(target.type==="monster"){
        const name=obj.name||"Démon";
        const lvl=obj.level||1;
        return `${name} niv ${lvl} ${suffix}`;
      }
      if(target.type==="potion") return `Potion ${suffix}`;
      if(target.type==="zone"){
        const lvl=obj.level||1;
        return `Portail niv ${lvl} ${suffix}`;
      }
      if(target.type==="town"){
        const name=obj.name||"Ville";
        return `${name} ${suffix}`;
      }
      if(target.type==="forest") return `Forêt ${suffix}`;
      if(target.type==="point") return `Position ${suffix}`;
      return "Aucune";
    })();
    const targetY=passiveY+26;
    ctx.fillStyle="#cfd8dc"; ctx.font="9px Helvetica";
    ctx.fillText(`Cible : ${targetDesc}`,mx,targetY);

    // Icône de sort + CD
    const spellName = hero.spell?hero.spell.name:"Aucun";
    const iconBoxX=panelX+panelW-84, iconBoxY=my;
    ctx.fillStyle="#2b3248";
    ctx.fillRect(iconBoxX,iconBoxY,54,54);
    ctx.strokeStyle="#707890"; ctx.strokeRect(iconBoxX,iconBoxY,54,54);

    ctx.fillStyle = hero.spellTimer>0 ? "#ffccbc" : "#c8e6c9";
    ctx.font="8px Helvetica";
    ctx.textAlign="center";
    if(hero.spell){
      if(hero.spellTimer>0)
        ctx.fillText(`${hero.spellTimer.toFixed(1)}s`, iconBoxX+27, iconBoxY+10);
      else
        ctx.fillText(`Prêt`, iconBoxX+27, iconBoxY+10);
    }
    this.drawSpellIcon(ctx,iconBoxX+27,iconBoxY+29,hero.spell);
    ctx.fillStyle="white"; ctx.font="8px Helvetica"; ctx.textAlign="center";
    ctx.fillText(spellName,iconBoxX+27,iconBoxY+52);

    // Buffs
    const buffBoxX = iconBoxX;
    const buffBoxY = iconBoxY + 58;
    ctx.fillStyle="#191f30";
    ctx.fillRect(buffBoxX,buffBoxY,54,32);
    ctx.strokeStyle="#445070";
    ctx.strokeRect(buffBoxX,buffBoxY,54,32);
    ctx.font="8px Helvetica";
    ctx.fillStyle="#bbbbbb";
    ctx.textAlign="center";
    ctx.fillText("Buffs", buffBoxX+27, buffBoxY+9);

    if(hero.reflectTimer>0){
      ctx.save();
      ctx.translate(buffBoxX+12,buffBoxY+19);
      ctx.strokeStyle="#fff59d";
      ctx.fillStyle="#fff59d";
      ctx.lineWidth=1.5;
      ctx.beginPath();
      ctx.arc(0,0,6,0,Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-3,0);
      ctx.lineTo(0,-4);
      ctx.lineTo(3,0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      ctx.fillStyle="#fff59d";
      ctx.textAlign="left";
      ctx.fillText(`Renvoi ${hero.reflectTimer.toFixed(1)}s`, buffBoxX+20, buffBoxY+20);
    }

    // Slots équipement
    const invX=panelX+20, invY=panelY+panelH-80;
    const slotSize=42, spacing=12;
    for(let i=0;i<3;i++){
      const sx=invX+i*(slotSize+spacing), sy=invY;
      const item=hero.inventory[i];
      let fill="#2a324a";
      if(item){
        const t=item.slotType;
        if(t==="armure") fill="#394d6a";
        else if(t==="épée") fill="#6a4d39";
        else if(t==="relique") fill="#5d3c5a";
        else fill="#5a5639";
      }
      ctx.fillStyle=fill;
      ctx.strokeStyle="#8890a8";
      ctx.fillRect(sx,sy,slotSize,slotSize);
      ctx.strokeRect(sx,sy,slotSize,slotSize);
      if(item){
        this.drawItemIcon(ctx,sx+slotSize/2,sy+slotSize/2,item.slotType);
        ctx.fillStyle="#eeeeee"; ctx.font="7px Helvetica"; ctx.textAlign="center";
        const stats=`${item.defenseBonus}/${item.attackBonus}/${item.speedBonus}`;
        ctx.fillText(stats,sx+slotSize/2,sy+slotSize-4);
      }
    }

    // Quête
    const qY = panelY+panelH+2;
    if(this.currentQuest){
      const q=this.currentQuest;
      ctx.fillStyle="#141a28";
      ctx.fillRect(panelX,qY,panelW,52);
      ctx.strokeStyle="#445070"; ctx.strokeRect(panelX,qY,panelW,52);
      ctx.fillStyle="#ffeb3b"; ctx.font="10px Helvetica"; ctx.textAlign="left";

      if(q.type==="destroyZone"){
        const lvl = q.area && q.area.level ? q.area.level : hero.level;
        ctx.fillText(`Quête : Détruire un portail Lv ${lvl}`,panelX+8,qY+14);
        ctx.fillStyle="#dddddd"; ctx.font="9px Helvetica";
        ctx.fillText(`Récompense spéciale : ${q.reward} or`,panelX+8,qY+28);
        ctx.fillText(`Progression : portail non détruit`,panelX+8,qY+40);
      } else if(q.type==="rescueTown"){
        const t = q.area;
        const townName = t ? t.name : "une ville";
        ctx.fillText(`Quête : Sauver ${townName}`,panelX+8,qY+14);
        ctx.fillStyle="#dddddd"; ctx.font="9px Helvetica";
        ctx.fillText(`Démons vaincus : ${this.questProgress}/${q.targetCount}`,panelX+8,qY+28);
        ctx.fillText(`Récompense : ${q.reward} or`,panelX+8,qY+40);
      } else if(q.type==="supplyTown"){
        const fromName = q.from ? q.from.name : "une ville";
        const toName = q.area ? q.area.name : "une autre ville";
        ctx.fillText("Quête : Livrer des provisions",panelX+8,qY+14);
        ctx.fillStyle="#dddddd"; ctx.font="9px Helvetica";
        ctx.fillText(`De ${fromName} vers ${toName}`,panelX+8,qY+28);
        ctx.fillText(`Récompense : ${q.reward} or`,panelX+8,qY+40);
      } else {
        const areaName = q.area ? (q.area.type==="zone" ? "Portail" : "Forêt") : "Zone";
        ctx.fillText(`Quête : Tuer ${q.targetCount} démons près de ${areaName}`,panelX+8,qY+14);
        ctx.fillStyle="#dddddd"; ctx.font="9px Helvetica";
        ctx.fillText(`Progression : ${this.questProgress}/${q.targetCount}`,panelX+8,qY+28);
        ctx.fillText(`Récompense : ${q.reward} or`,panelX+8,qY+40);
      }
    }

    // Message de mort
    if(this.lastDeathMsgTimer>0){
      ctx.fillStyle="rgba(0,0,0,0.5)";
      ctx.fillRect(0,WINDOW_HEIGHT-40,WINDOW_WIDTH,40);
      ctx.fillStyle="white";
      ctx.font="11px Helvetica";
      ctx.textAlign="center";
      ctx.fillText(this.lastDeathMsg,WINDOW_WIDTH/2,WINDOW_HEIGHT-18);
    }

    ctx.restore();

    // ---------- PANNEAU RANKING + LOG ----------

    const rightX = WINDOW_WIDTH - 250;
    const rankY = 10;
    const rankW = 240;
    const rankH = 110;

    ctx.save();

    // Ranking
    ctx.fillStyle="#111827";
    ctx.fillRect(rightX,rankY,rankW,rankH);
    ctx.strokeStyle="#475569";
    ctx.strokeRect(rightX,rankY,rankW,rankH);
    ctx.fillStyle="#e5e7eb";
    ctx.font="11px Helvetica";
    ctx.textAlign="left";
    ctx.fillText("Hall des héros", rightX+10, rankY+18);

    // Affichage de l'année du monde
    const year = this.worldYears || 0;
    ctx.font="10px Helvetica";
    ctx.fillStyle="#a5b4fc";
    ctx.fillText(`Année : ${year}`, rightX+140, rankY+18);

    ctx.font="9px Helvetica";
    if(this.heroRanking.length===0){
      ctx.fillStyle="#9ca3af";
      ctx.fillText("Aucun héros tombé pour l'instant.", rightX+10, rankY+36);
    } else {
      for(let i=0;i<this.heroRanking.length;i++){
        const h = this.heroRanking[i];
        const lineY = rankY+36 + i*14;
        ctx.fillStyle="#d1d5db";
        ctx.fillText(`#${i+1}  Niv ${h.level} – ${h.name}`, rightX+10, lineY);
      }
    }

    ctx.fillStyle="#a5b4fc";
    ctx.fillText(`Héros actuel : Niv ${hero.level}`, rightX+10, rankY+rankH-12);

    // Event log
    const logY = rankY + rankH + 8;
    const logH = 160;
    ctx.fillStyle="#020617";
    ctx.fillRect(rightX,logY,rankW,logH);
    ctx.strokeStyle="#334155";
    ctx.strokeRect(rightX,logY,rankW,logH);
    ctx.fillStyle="#e5e7eb";
    ctx.font="11px Helvetica";
    ctx.fillText("Journal", rightX+10, logY+18);

    ctx.font="9px Helvetica";
    ctx.textAlign="left";

    const startIndex = Math.max(0, this.eventLog.length-8);
    let lineY = logY+34;
    for(let i=startIndex;i<this.eventLog.length;i++){
      const msg = this.eventLog[i];
      ctx.fillStyle = (i === this.eventLog.length-1) ? "#facc15" : "#cbd5f5";
      ctx.fillText("• "+msg, rightX+10, lineY);
      lineY += 14;
    }

    ctx.restore();
  }
}

// ===================== LANCEMENT =====================

const canvas = document.getElementById("game");
const game = new Game(canvas);

function loop(){
  game.step();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
